{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/hexo-theme-butterfly/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/404.jpg","path":"img/404.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/air.png","path":"img/air.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/cherry.jpg","path":"img/cherry.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/chrome1.png","path":"img/chrome1.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/chrome2.png","path":"img/chrome2.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/chrome3.png","path":"img/chrome3.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/debugger.png","path":"img/debugger.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/defer.png","path":"img/defer.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/f.jpg","path":"img/f.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/git.jpg","path":"img/git.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/http.webp","path":"img/http.webp","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/http2.jpg","path":"img/http2.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/http3.jpg","path":"img/http3.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/http4.jpg","path":"img/http4.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/http5.jpg","path":"img/http5.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/http6.webp","path":"img/http6.webp","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/http7.jpg","path":"img/http7.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/http8.jpg","path":"img/http8.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/js原型链.webp","path":"img/js原型链.webp","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/ladder.webp","path":"img/ladder.webp","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/layout.jpeg","path":"img/layout.jpeg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/layout.webp","path":"img/layout.webp","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/nginx.jpg","path":"img/nginx.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/p.jpg","path":"img/p.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/p2.webp","path":"img/p2.webp","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/rrick.jpg","path":"img/rrick.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/tra.jpg","path":"img/tra.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/vue1.png","path":"img/vue1.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/vue_basic_1.jpg","path":"img/vue_basic_1.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/vue_basic_2.png","path":"img/vue_basic_2.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/zhihu.png","path":"img/zhihu.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/你知道的太多了.jpg","path":"img/你知道的太多了.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/img/无奈.webp","path":"img/无奈.webp","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/Git亲妈级教程.md","hash":"db407849b00353e792364291aec867db64abde2d","modified":1692582774316},{"_id":"source/_posts/HTTP版本演进：第一回.md","hash":"20453363b0ff5a44f561a7f34b114a84080da009","modified":1692582774316},{"_id":"source/_posts/HTTP版本演进：第三回.md","hash":"8341bc2e3295ffe1e9c7f33a6b915ed4128d22e3","modified":1692582774316},{"_id":"source/_posts/JS类型详论.md","hash":"78b588d0532d5a4c7f1932aaa00fec2d2811414d","modified":1692582774316},{"_id":"source/_posts/HTTP版本演进：第二回.md","hash":"332e486fe0fe60f30caccb7fad72e9e0a347bcab","modified":1692582774316},{"_id":"source/_posts/Nginx-简论.md","hash":"1f4e8dd9c7e60b5a786ff9016ec0167b50d67029","modified":1692584205520},{"_id":"source/_posts/Vue.js系列：patch.md","hash":"88a5303aadc1fad93ab4b206e195ccf9f15da86a","modified":1692582774316},{"_id":"source/_posts/Vue.js系列：vue的路由实现.md","hash":"70ec80360f4acc0579f40056ebaac0fbfbff20be","modified":1692582774316},{"_id":"source/_posts/Vue.js系列：实现一个自己的vue.md","hash":"1ea3fc4980375fcebf0592d89dad96b703d8ffef","modified":1692582774316},{"_id":"source/_posts/Vue.js系列：实现一个自己的vue续篇.md","hash":"1ba945de6a2321efcec7ba30dd240b3488634a99","modified":1692582774316},{"_id":"source/_posts/Vue.js系列：对象的变化侦测.md","hash":"4612bc95a012fa32ebea75dd0bc3facf62b987c1","modified":1692582774316},{"_id":"source/_posts/Vue.js系列：序章.md","hash":"5305365f58d24d77ebd41c864bee9ca7ee68a9ed","modified":1692582774332},{"_id":"source/_posts/Vue.js系列：数组变化的侦测.md","hash":"c565835b0fea125e13ee5114a3d9d1f6b45aa270","modified":1692582774332},{"_id":"source/_posts/Vue.js系列：虚拟dom.md","hash":"4b508bb23cfe65d5d36e6369c3e737f18643280a","modified":1692582774332},{"_id":"source/_posts/Vue.js系列：深入理解生命周期.md","hash":"d9962638c2d7af326faf27b91d1bd50d456ba15c","modified":1692582774332},{"_id":"source/_posts/Webkit系列：第一回.md","hash":"d3159f9111a05403d6287f96e2954886b720a0df","modified":1692582774332},{"_id":"source/_posts/Webpack系列：第一回.md","hash":"2ac0bc323b6a8085cb1a027ede1f0c5bb57a103f","modified":1692582774332},{"_id":"source/_posts/Webpack系列：第二回.md","hash":"65c7c43dd167002122f2d69d848ec6c34c51d1ad","modified":1692582774332},{"_id":"source/_posts/Webpack系列：第三回.md","hash":"5add994b4f6ea171c4780151c36ff33dc07840d3","modified":1692582774332},{"_id":"source/_posts/cookie、token相关.md","hash":"56a8355333b6ad087f3bcb8bdbeafbd35f4b4b08","modified":1692582774332},{"_id":"source/_posts/Webpack系列：第四回.md","hash":"9d53c0d0ae53da2f30e587cee3894beb23416e8b","modified":1692582774332},{"_id":"source/_posts/down视频资源时的偶然发现.md","hash":"c11aafb273bd2744cd4d804bdb85a1f55909717d","modified":1692582774332},{"_id":"source/_posts/js的上古规则-原型链那些事儿.md","hash":"89f3bec2928b0ba8ab5215023aef86425360df11","modified":1692585338646},{"_id":"source/_posts/js的转折分界-ES6.md","hash":"bf8788a03492acab8317cbc56e48c77c07cd43ea","modified":1692582774332},{"_id":"source/_posts/《万神殿》-上载智能.md","hash":"de586a8fc624395bee4200588531bcb2ead46666","modified":1692582774332},{"_id":"source/_posts/做好预备动作.md","hash":"7f79dc91463bb54f3021d5d84c49358a1c7fd18e","modified":1692582774332},{"_id":"source/_posts/关于所谓的“梯子”的实现逻辑.md","hash":"4726e44f8d73aec96191462fd7db4fd2c4849562","modified":1692582774332},{"_id":"source/_posts/性能的考量：第一回.md","hash":"4af90f8468aae658367d52de06d9347255d25cb3","modified":1692582774332},{"_id":"source/_posts/四轴无人机研究：第一回.md","hash":"c3344875e364e51a3fcf47ba7e04630b76ad9af3","modified":1692582774332},{"_id":"source/_posts/性能的考量：第三回.md","hash":"eca2c10c72532c47ee29a06cd6a2656316282eb7","modified":1692582774332},{"_id":"source/_posts/性能的考量：第四回.md","hash":"ec81ba43e65ea42644421197a894b146e2871d50","modified":1692582774332},{"_id":"source/_posts/拥塞窗口的策略机制.md","hash":"64dfb4ae0df451afc6156b05636f2e23d3982974","modified":1692582774332},{"_id":"source/_posts/性能的考量：第二回.md","hash":"8ec40406774967faa30c58d1ea20126e64247927","modified":1692582774332},{"_id":"source/_posts/谷歌插件流程：第一回.md","hash":"ccb8e79fd5148a67f55bdf6f8ce3073efa2345dc","modified":1692582774332},{"_id":"source/_posts/谷歌插件流程：第二回.md","hash":"a7321c89f7720071958e07637cfcfcf6065ba8fc","modified":1692582774332},{"_id":"source/_posts/设计模式：单例模式.md","hash":"39de00b92e8065ef5f9da3e60c064dd0fba926a7","modified":1692582774332},{"_id":"source/_posts/image.png","hash":"f1aea9c82718f5902c4d514a19cd53f8db7a9f99","modified":1692582774332},{"_id":"themes/hexo-theme-butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1692582774332},{"_id":"themes/hexo-theme-butterfly/README.md","hash":"4edab59e45ef63ce52b343a1e6e33d3b78729c33","modified":1692582774332},{"_id":"themes/hexo-theme-butterfly/_config.yml","hash":"38d4019818c176e953f3c4dd0b2cae683da79c57","modified":1692582774332},{"_id":"themes/hexo-theme-butterfly/package.json","hash":"a6a032654a36408d7b7274bc9cfe21f89946d29c","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/README_CN.md","hash":"3655a8e204132b7e98933785f4728370495c1657","modified":1692582774332},{"_id":"themes/hexo-theme-butterfly/plugins.yml","hash":"9d0a36c3b02595ed8b2a16dbb59372fd64049482","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/languages/default.yml","hash":"c2b1ebab3d14b43ffda003424964fd53f93c8038","modified":1692582774332},{"_id":"themes/hexo-theme-butterfly/languages/en.yml","hash":"141ce1903716d19385ff9da1681f4415209ea99c","modified":1692582774332},{"_id":"themes/hexo-theme-butterfly/languages/zh-CN.yml","hash":"8684fb6c5551c10953acfec7d1eb9cc264d640da","modified":1692582774332},{"_id":"themes/hexo-theme-butterfly/languages/zh-TW.yml","hash":"828b5756cbfffff09519076e9d9d406453eee3d8","modified":1692582774332},{"_id":"themes/hexo-theme-butterfly/layout/archive.pug","hash":"115fa5ee8864e5c97549eff91a17c66101d724ab","modified":1692582774332},{"_id":"themes/hexo-theme-butterfly/layout/category.pug","hash":"bf979aec88d78b644fc5d31518f8679ad7625792","modified":1692582774332},{"_id":"themes/hexo-theme-butterfly/layout/index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/layout/page.pug","hash":"bf2d6c6d2d156777b55292e51be02b0b3acf0af8","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/layout/tag.pug","hash":"4bb5efc6dabdf1626685bf6771aaa1467155ae86","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/layout/post.pug","hash":"fdbb508b5e6dec30fb8753c5a7fdd494410c4fc0","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/.github/workflows/stale.yml","hash":"4040c76547e270aaf184e9b219a44ca41bbb1b9f","modified":1692582774332},{"_id":"themes/hexo-theme-butterfly/.github/workflows/publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1692582774332},{"_id":"themes/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"d9ff4bad9c9664e12729c7a531169a05698a3fd1","modified":1692582774332},{"_id":"themes/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"92683cb785a29e5a73701b33dba73d3afac268c3","modified":1692582774332},{"_id":"themes/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"6e0f9470b18bd37d4891282ac73d61676b040e8c","modified":1692582774332},{"_id":"themes/hexo-theme-butterfly/layout/includes/additional-js.pug","hash":"50eea5aa78cdeb6c72dd22f0aeabc407cc0f712e","modified":1692582774332},{"_id":"themes/hexo-theme-butterfly/layout/includes/404.pug","hash":"aace9ddff469de4226e47a52ede1c81e66d66d5c","modified":1692582774332},{"_id":"themes/hexo-theme-butterfly/layout/includes/footer.pug","hash":"8715948b93e7508b84d913be1969b28c6b067b9b","modified":1692582774332},{"_id":"themes/hexo-theme-butterfly/layout/includes/head.pug","hash":"b50b0afdc41c54279587410c3f82c8cb3c5ff46d","modified":1692582774332},{"_id":"themes/hexo-theme-butterfly/layout/includes/layout.pug","hash":"96df62e34661d8ca4a45267286127479e5178a79","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/pagination.pug","hash":"c5c58714fb3cb839653e5c32e6094784c8662935","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/rightside.pug","hash":"c55f05400eb27ab051f47396ec8d4249ce6f71ec","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/sidebar.pug","hash":"9277fead4c29dbe93976f078adaa26e8f9253da3","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/scripts/events/404.js","hash":"f1d1c378356b776e9b2a8411e6dca88dc8c3245c","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/scripts/events/comment.js","hash":"95479790234c291b064d031577d71214cdd1d820","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/scripts/events/cdn.js","hash":"7864ba45716c51aef8d8b04fd4bc212e0008ce3b","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/scripts/events/init.js","hash":"ce68e84a9ccfcf91100befbaa9afc392a0cd93bb","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/scripts/events/welcome.js","hash":"f59e10305fef59ea3e62a7395106c0927582879d","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/scripts/filters/post_lazyload.js","hash":"5fd6c9659262dc8f61d87866d0417fd534292c88","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/scripts/events/stylus.js","hash":"218add7e9b39b6fb6e69921abb9e44891a6cc3ce","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/scripts/filters/random_cover.js","hash":"a3323fcb11cfd3f3e21230737341beb5d76b40aa","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/scripts/tag/button.js","hash":"164d5f1c2d1b4cb5a813a6fc574016743a53c019","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/scripts/tag/gallery.js","hash":"d6a5472a29ee2137db037d6c44062664cb7a3f35","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/scripts/tag/flink.js","hash":"3ba7677969ff01fab06fc6713455ddc6861f0024","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/scripts/tag/hide.js","hash":"5d08c3552f7d3c80a724ca628bff66321abe2e5a","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/scripts/tag/label.js","hash":"b013dc0a3d57d2caa18b89263f23871da9ec456d","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/scripts/tag/inlineImg.js","hash":"c863d2732ce4bdc084f2d0db92f50f80328c1007","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/scripts/tag/mermaid.js","hash":"289f85847c58f0b2b7d98a68e370a2896edb8949","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/scripts/tag/note.js","hash":"e68d8d21f3a86e3646907a3685550ee20e8d4a9f","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/scripts/tag/score.js","hash":"35d54adc92e717cc32e13515122b025fd1a98ea2","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/scripts/tag/series.js","hash":"dc56e5182dd3813dc977c9bf8556dcc7615e467b","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/scripts/tag/timeline.js","hash":"e611074a5a7f489a8b04afac0a3f7f882ce26532","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/scripts/tag/tabs.js","hash":"9b0d4f20acd54168547f2f0f3bef10b9357029e4","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/scripts/helpers/aside_archives.js","hash":"4f712b4ea383b59a3122683db1d54c04a79ccc5d","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/scripts/helpers/aside_categories.js","hash":"376e1884ea764404c38b1e73b16de0358ece519e","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/scripts/helpers/findArchiveLength.js","hash":"8ff03b35385f9162e1eb54dceb5fa7f781306caf","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/scripts/helpers/inject_head_js.js","hash":"7222102f9919f8e961d4f1688425845fb7775ada","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/scripts/helpers/page.js","hash":"6005907245dd74b153f03afdccfae1abb66bb482","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/scripts/helpers/related_post.js","hash":"76343ac8422c9c8539082e77eda6ffee4b877eb2","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/scripts/helpers/series.js","hash":"17c0095bc8d612a268cdcab000b1742dc4c6f811","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/source/css/index.styl","hash":"b13d96924a5534bff91d75566b196ac87b4fac22","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/var.styl","hash":"9e2bb08a1bf59c7baaff8c53418f8a10c2100815","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/img/cherry.jpg","hash":"44021a61fc08a9503fe4c0a07e04b28fd7af6246","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/img/chrome2.png","hash":"18fe14d0daf545860bb0985b8182a39753253ead","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/img/chrome1.png","hash":"b8cecdb5c18ea4f288136bacac28644d1e5df570","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/img/debugger.png","hash":"d31afdf7697916bf0829d662d3a325ea477873ff","modified":1692582774394},{"_id":"themes/hexo-theme-butterfly/source/img/defer.png","hash":"a14e47a4bbf3bad8533764b6efc1de502ad67b71","modified":1692582774394},{"_id":"themes/hexo-theme-butterfly/source/img/f.jpg","hash":"63e6faf361c4544360213f43418ca8993c25f4c4","modified":1692582774394},{"_id":"themes/hexo-theme-butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1692582774394},{"_id":"themes/hexo-theme-butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1692582774394},{"_id":"themes/hexo-theme-butterfly/source/img/http.webp","hash":"048494ed0b7ae060e26b98c3204f8c7813b59027","modified":1692582774394},{"_id":"themes/hexo-theme-butterfly/source/img/git.jpg","hash":"02f9c6c86ee87148781dfa3f978a034b20f40309","modified":1692582774394},{"_id":"themes/hexo-theme-butterfly/source/img/http3.jpg","hash":"c144b5bcaae5a82e84494a8cfc0697bce80e593f","modified":1692582774394},{"_id":"themes/hexo-theme-butterfly/source/img/http6.webp","hash":"68c8fd7a1d3e98ffc6271af8410cfbddbcc6bd94","modified":1692582774394},{"_id":"themes/hexo-theme-butterfly/source/img/http5.jpg","hash":"b6f0da80a04fd80bc2dcbcd479b8166a86a889ac","modified":1692582774394},{"_id":"themes/hexo-theme-butterfly/source/img/js原型链.webp","hash":"800fe38f669022c61e61be6b0a13f5e78e2ae49d","modified":1692585172149},{"_id":"themes/hexo-theme-butterfly/source/img/http8.jpg","hash":"8e6362a91f26fd11301d72dbb1fc5beff13cf2fd","modified":1692582774394},{"_id":"themes/hexo-theme-butterfly/source/img/ladder.webp","hash":"f90b7e15e28dd74927d11d0c4b4a7c0784409fc4","modified":1692582774394},{"_id":"themes/hexo-theme-butterfly/source/img/layout.jpeg","hash":"9f02179d493555d4b00a8e8c5738d51c1be1b7dd","modified":1692582774394},{"_id":"themes/hexo-theme-butterfly/source/img/layout.webp","hash":"6a7211f732bcee2fcff2ccf0fcb187a3138c65a9","modified":1692582774394},{"_id":"themes/hexo-theme-butterfly/source/img/nginx.jpg","hash":"7e02e60233e3180c23450a92a0dd6cbe9a038da0","modified":1692583780237},{"_id":"themes/hexo-theme-butterfly/source/img/p.jpg","hash":"a21a365d6d69d924a4ed7e886020d36e361b1289","modified":1692582774394},{"_id":"themes/hexo-theme-butterfly/source/img/p2.webp","hash":"73ddebc8e82dfc5ece5911197e8fb1dea1ec0184","modified":1692582774394},{"_id":"themes/hexo-theme-butterfly/source/img/vue1.png","hash":"7b82bc127dcb7a3287b4464d5c721688c3c00a31","modified":1692582774394},{"_id":"themes/hexo-theme-butterfly/source/img/vue_basic_1.jpg","hash":"60cb3ceae7fb4b846f658929bb66095a8bf0ffa3","modified":1692582774394},{"_id":"themes/hexo-theme-butterfly/source/img/vue_basic_2.png","hash":"aa8749a596a7a7a48a4ef67d474684cfec51826b","modified":1692582774394},{"_id":"themes/hexo-theme-butterfly/source/img/你知道的太多了.jpg","hash":"91ef0614c9f7890cab00160562a67ac2d3be6c87","modified":1692582774394},{"_id":"themes/hexo-theme-butterfly/source/img/无奈.webp","hash":"1688346de00d769630763a078cd44dbf835a87e4","modified":1692582774394},{"_id":"themes/hexo-theme-butterfly/source/js/tw_cn.js","hash":"a102a6cacf7b20183946a54580867a964f3674c4","modified":1692582774410},{"_id":"themes/hexo-theme-butterfly/source/js/main.js","hash":"4fd1cd7a02dedcb686caf6149c35fd8e1fbcafc9","modified":1692582774394},{"_id":"themes/hexo-theme-butterfly/source/js/utils.js","hash":"13b2b02118a0f4ec2e9e0bb1b90f5b1a30a70f44","modified":1692582774410},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/Open_Graph.pug","hash":"c8dbdfe6145a0bc6f7691c9551be8169a2698f0a","modified":1692582774332},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/analytics.pug","hash":"c7666a10448edd93f5ace37296051b7670495f1b","modified":1692582774332},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1692582774332},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/config.pug","hash":"f5207840c96df6b26ad227433babca4f8c362624","modified":1692582774332},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/noscript.pug","hash":"72efaa09ff60843567458bd54152e06f0cb2757e","modified":1692582774332},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/preconnect.pug","hash":"fd55f0e09827ef40c53c48d184a553464aac3e03","modified":1692582774332},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/config_site.pug","hash":"bd5dd5452e28a4fe94c3241a758ec6f4fdb7a149","modified":1692582774332},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1692582774332},{"_id":"themes/hexo-theme-butterfly/layout/includes/head/pwa.pug","hash":"6dc2c9b85df9ab4f5b554305339fd80a90a6cf43","modified":1692582774332},{"_id":"themes/hexo-theme-butterfly/layout/includes/header/index.pug","hash":"1bef867c799ba158c5417272fb137539951aa120","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/header/nav.pug","hash":"962ee70a35e60a13c31eea47d16b9f98069fe417","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/header/menu_item.pug","hash":"ca8bcd90ad9467819330bfe7c02b76322754bccf","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/header/post-info.pug","hash":"50b4b9c7f6a4771910be4198639cfcfc6d7b8925","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/header/social.pug","hash":"7a641b5dd45b970e1dafd1433eb32ea149e55cf2","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/loading/fullpage-loading.pug","hash":"766baca6ddce49d1724a02312387b292ff2d0bdc","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/loading/index.pug","hash":"00ae419f527d8225a2dc03d4f977cec737248423","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/loading/pace.pug","hash":"a6fde4835d6460ce7baf792fd5e1977fad73db25","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/mixins/article-sort.pug","hash":"9155f01d4c644a2e19b2b13b2d3c6d5e34dd0abf","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/mixins/post-ui.pug","hash":"bbed18e892116f617ec53c923eef5b2787264164","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/page/flink.pug","hash":"e37681bc9c169d4220f26ecda2b3d5c02b6b9a0f","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/page/default-page.pug","hash":"e9459f122af7b733398578f9f0f8ab3c5e12a217","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/page/tags.pug","hash":"12be059c536490af216a397e8f2a7abbf6d4610e","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/post/post-copyright.pug","hash":"cc1f7ae8a7ce5445277215821092e712ec8cc296","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/aplayer.pug","hash":"e939344fd389aeb11864ee697d5fd9b036d8325f","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/post/reward.pug","hash":"912df10a053db3135968e92b6fd1a707ee94c968","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/effect.pug","hash":"4e37535c63149708ecbedb262336014524ad8723","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/pangu.pug","hash":"f0898509da70388b5c532f19e762756d74080200","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/pjax.pug","hash":"82bb447a5d045980789cf3f9de9d49cc32011b13","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/prismjs.pug","hash":"08979afbfecb4476a5ae8e360947b92624d285b8","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/subtitle.pug","hash":"dfb5e16a7e7106bb20b2ac2d0df1251d0fc79609","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_announcement.pug","hash":"21e019bdc3b1e796bb00976bb29af2d51f873624","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_author.pug","hash":"ab037bf5794638bd30da4cf7cf106e5d03b5f696","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_newest_comment.pug","hash":"8e22f53886a57a68286970d8af8b4c950fd4a1d7","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_post_series.pug","hash":"2084b8065e63dd045bdca3dc5992014133601e28","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_post_toc.pug","hash":"59d979702fa21d960443824198614d63aaf69662","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_recent_post.pug","hash":"bb842d2aa6469d65bf06af1372f0a19a9e4ef44c","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_tags.pug","hash":"842b772a387b576550fa127030e1c2e9bf65716d","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/card_webinfo.pug","hash":"12185713f9ca08984fc74e3b69d8cd6828d23da8","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/layout/includes/widget/index.pug","hash":"8df529f71e25f1c0a00e533de7944ed3d1ba7bd8","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/source/css/_global/index.styl","hash":"9893656128c347d1c09c90784627c84c979b326f","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/source/css/_global/function.styl","hash":"431b4a252443e224872bd6b4f6aa76ed1679a82c","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/source/css/_highlight/theme.styl","hash":"3c178608406c31d768af355ef1d7326da37cc75f","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/aside.styl","hash":"3969f599e8657adf8c3ce287d83f5d0a23f276a9","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_highlight/highlight.styl","hash":"e43017dbc73e0ce95dcfcb9dfb4fcce0c1715dd4","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/chat.styl","hash":"792a04d36de32f230ca3256ad87a90fe8392f333","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/comments.styl","hash":"0abe05309a186682772a94e5e759b63f8028e61a","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/footer.styl","hash":"5e27f7842af82ff7498d4b59787ce9ca90fa9e6f","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/head.styl","hash":"20303c0dad28e5c5335ce2fa6582f1fafae5b628","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/loading.styl","hash":"f0b01bbf321c2c24fdccaee367dd9fd448031a72","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/pagination.styl","hash":"bd099f7d3adef4b7edd24c0a25a07415b156e587","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/post.styl","hash":"fc029f5e00d7904c0878efd20dd4e09fc55e1d03","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/relatedposts.styl","hash":"6dcf19c0933c8828a439f801b0f4b256447dec07","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/reward.styl","hash":"c0b11a1a5f52e3a6af4e312a8134c93eda18a7dd","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/rightside.styl","hash":"824b2b2d2ee72583b9e009c0bb13e29e806534cc","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/sidebar.styl","hash":"7e9b65dcae7ac54e0183bc841fea0f4bd4d78e5c","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_layout/third-party.styl","hash":"15ea7564b2e3bf46bc91fb6e49c94d057b37caaf","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_mode/darkmode.styl","hash":"9066a62e442affce3a923a06a90486bf9d364e0e","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_mode/readmode.styl","hash":"4c86c10f8ec0c8fb60b400a5a2f14699d3155be4","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_page/404.styl","hash":"a7223a8fcc4fa7b81e552c9a2554be7df9de312e","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_page/archives.styl","hash":"5dd1ba997741d02894ff846eda939ad8051c0bb2","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_page/categories.styl","hash":"68bc8cbea25dbb3cdc170f09f9b43ce130547717","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_page/common.styl","hash":"df7a51fcabbadab5aa31770e3202a47c9599bbb7","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_page/flink.styl","hash":"ecc2b2e28c179eb9406fc2c6f00e141078249cdd","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_page/homepage.styl","hash":"a977cd8161ef4d6ddd5293e81403519076657430","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_page/tags.styl","hash":"9e35f91847773b915c74a78b8aa66c7bdb950ad0","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_search/algolia.styl","hash":"37db99299af380e9111dce2a78a5049b301b13e0","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_search/index.styl","hash":"0b23010154e19f37f0c4af0110f9f834d6d41a13","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_search/local-search.styl","hash":"cf90ea339fbb7f345212319627fcd68964024e40","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_tags/button.styl","hash":"62da1de0d5b8453fcecbfacddb16985265638ba5","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_tags/gallery.styl","hash":"7c463ba25b3b54f0f46dfd75971d792816e942a8","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_tags/hexo.styl","hash":"985b183db7b7bfd8f9bdb60494549fb7f850348b","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_tags/hide.styl","hash":"b7cf7753479fcf2fe07287ffdb0e568adbba4c18","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_tags/inlineImg.styl","hash":"5a873d01fabebcf7ddf7a6b1c2e2e5e2714097f4","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_tags/label.styl","hash":"2f83bd145b870d80d4b18b0ac603235229a5694e","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_tags/note.styl","hash":"331c89ecfb79fab68466944a43e9e3d0ff49c646","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_tags/tabs.styl","hash":"ce2ca34b2483a1b612610ff5cbeca2007cb50b93","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_tags/timeline.styl","hash":"07ea7134db7a66c87658116f089fb1a2a6906563","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/js/search/algolia.js","hash":"bbe930d8425bdaee2a5ba3cade42b617cee42934","modified":1692582774394},{"_id":"themes/hexo-theme-butterfly/source/js/search/local-search.js","hash":"40e76d6da538cb3c1ef6b79ffc0adfa64fe6b8ba","modified":1692582774394},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"0010c7a10d265c4329f0fd4db85b4a9ea7ba06b5","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"19b5cfa1f77781246e02967cefe149f19170e45f","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"f4d21dcbc3b00eed9b1f604e132c4c6811a0a059","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/abcjs/index.pug","hash":"58f37823f6cd9a194fb50f7ca7c2233e49939034","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"4b98145d6584d586cabf033493282afc72ae816a","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"846cabae287ae31b3bbfac3da022475713dd5ecc","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"7e233f872aea6fd6beccdc9efd86b1bf9ec9f12d","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"716dc463fe4ef5112e7018ed60804125fdfa5cad","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"cd4fc9c5a61608a5dedf645c1295430a1623040f","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"c42bbce31fcd8846cf3360f4c383dec9368daeba","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/chat/chatra.pug","hash":"08a85e52fc800d3562df869e5e2613313e76fce6","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"0d960849d5b05d27ec87627b983ca35f2411b9e8","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/chat/crisp.pug","hash":"09d2ab2570b67e6f09244a898ccab5567cb82ace","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/chat/index.pug","hash":"1157118db9f5d7c0c5a0fc7c346f6e934ca00d52","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/chat/messenger.pug","hash":"799da8f3015e6fe440681b21644bcb3810a5518c","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/chat/tidio.pug","hash":"6d40b521eec4136f6742c548a4445ed593470b1b","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/comments/artalk.pug","hash":"b47698e153c73cb29286b19bec5ddd920cb7ffba","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/comments/disqus.pug","hash":"f8b73bc63ec1b45d86aa3891d8c81ef4d5980943","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"b19b123df682b23491b17dcca386d79062cd8f6e","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/comments/giscus.pug","hash":"a56edeb1ce2f1b1fb0e866a30543f274b9f7d69e","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"1a20b11fa0e6b1943e9b4d81e197a25ca36af66d","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/comments/index.pug","hash":"c5e131d65a7ad30f3cb98ac3b94cd2f6a94c22e9","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/comments/js.pug","hash":"3abbaaa4ea575c45b3cebffd40bad1acc6ffce84","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"7c7fbe27d82becc9ee509765f1195c69f5864a0b","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/comments/livere.pug","hash":"589f8503f264d4fda971c8daf2028f45c4f2867b","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/comments/remark42.pug","hash":"f618457d62ef35d78a31e7fb1e375a462f64b228","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"4bb4cf58e219dfb8787273c931b1ea978b2ab88f","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/comments/utterances.pug","hash":"386a2b371644c2682560733617561ba6e6bf9ab2","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/comments/waline.pug","hash":"6b0d28671afd5ed286a714f25ba16256a2e7d880","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/comments/valine.pug","hash":"cba55cbbd0962bf84b8956195e686b0e158ed247","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/math/index.pug","hash":"2afa4c21dd19890f47fb568cfb0d90efb676a253","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/math/mathjax.pug","hash":"bb944185f4bb9f9a9b9d70ee215f66ccd6d4c6cf","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/math/katex.pug","hash":"f0d3eddd2bed68e5517274b3530bfe0fa5057d8e","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/math/mermaid.pug","hash":"da94966a9650ef3e4c69f3ee93758b30fa42cb78","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"cfcfaed3a52fa47fff4cc65a053a2f025fb3b7b6","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"a6be932d1f64c6190f5d03b5b77fba09fa0fd6b8","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"4f8bd22c5c32d5430cbe08ab4e861b6f8b86f820","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"4fb998a05e51ef2302775945883307ee3039a544","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"f8b65460c399973090c1fb7ab81e3708c252e7cc","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"edd4ebf76a79fb74cfae03a286fab90f74324dbd","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"2f3af113713563e34b10bbe998cc15008f81c85a","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"ce4ab79c85df9f77395269eb01e9a023d7f96376","modified":1692582774347},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/search/algolia.pug","hash":"90338ac4cd114d324fe1caaaeea8be9ca05d6a46","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/search/index.pug","hash":"3adcf28a8d205ea3ee19828eda0e668702fac07a","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/search/docsearch.pug","hash":"ba04174d977da988a1d49c06641262c413352346","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/search/local-search.pug","hash":"4b9c35375e0eb9cf99ad246d5ca838eca64a635d","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/share/addtoany.pug","hash":"1f02a26730e5f36cc2dfec7ff4d5c93a099ed5ba","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/share/index.pug","hash":"c16ee69b5ca8db016db0508d014ae0867c4ce929","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/layout/includes/third-party/share/share-js.pug","hash":"8106bd031586f075a994956ee4438eb13be25d7b","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/source/css/_highlight/prismjs/diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"0b8aea62d1550113e1fcc237fae1b03743190208","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/source/css/_highlight/prismjs/index.styl","hash":"01ff9e77eb1bd454bec65a6ff5972c8e219bc708","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/source/css/_highlight/highlight/diff.styl","hash":"6e77f1ca0cfb0db6b028f5c0238780e66d344f3d","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/source/css/_highlight/highlight/index.styl","hash":"fc702a4614d0562a381907b083f71ba63d301d86","modified":1692582774363},{"_id":"themes/hexo-theme-butterfly/source/img/http2.jpg","hash":"cc0b4950de62b404661b9fff80d4fbab1411d4a7","modified":1692582774394},{"_id":"themes/hexo-theme-butterfly/source/img/http4.jpg","hash":"d37a9c42e705729dc7c124c7293661eeab523b06","modified":1692582774394},{"_id":"themes/hexo-theme-butterfly/source/img/http7.jpg","hash":"c5f76dd20729d89712debfb5bd1563b7290ba70b","modified":1692582774394},{"_id":"themes/hexo-theme-butterfly/source/img/chrome3.png","hash":"82a5fc0ee29a1585000af885dc64bca2decd054f","modified":1692582774394},{"_id":"themes/hexo-theme-butterfly/source/img/tra.jpg","hash":"04d067757a49b78acf8145daa7abaebb866e8283","modified":1692582774394},{"_id":"themes/hexo-theme-butterfly/source/img/air.png","hash":"4e2268189e42f21c1b4960a5a3208cc90ec13e63","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/img/rrick.jpg","hash":"955c42b436a99bd289eca219916a112128904de6","modified":1692582774394},{"_id":"themes/hexo-theme-butterfly/source/img/avatar.jpg","hash":"c49270e383f2d7deffea82222e8a8455ff356b02","modified":1692582774379},{"_id":"themes/hexo-theme-butterfly/source/img/zhihu.png","hash":"6a403681d190d3da5a209b82f982c0b5c74b6322","modified":1692582774394},{"_id":"public/sitemap.xml","hash":"f7afac81ca70be2f7066c20802c26ffcb4e2cb4b","modified":1692585898119},{"_id":"public/sitemap.txt","hash":"e0f60378f5d3d05d7df78f22e9a5e2d51288f626","modified":1692585898119},{"_id":"public/2023/07/25/Webpack系列：第四回/index.html","hash":"9a8baf6e1e46d029ed3ba5e248d7ec77dea72c8d","modified":1692585898119},{"_id":"public/2023/08/21/Nginx-简论/index.html","hash":"6d2ff038e15d8919ce4561eb0b8f310f3b71e51e","modified":1692585898119},{"_id":"public/2023/08/20/cookie、token相关/index.html","hash":"fc74c17fcb5a7b2651b0202bd727dc4c4ffb9fc7","modified":1692585898119},{"_id":"public/2023/08/11/Vue.js系列：vue的路由实现/index.html","hash":"3fc1b1c1affb53bf3cdeb2e6d83528d22142be38","modified":1692585898119},{"_id":"public/2023/08/13/Vue.js系列：深入理解生命周期/index.html","hash":"ff3ca23102954ae3acb8f8711c445df7e7bb10ec","modified":1692585898119},{"_id":"public/2023/08/10/Vue.js系列：数组变化的侦测/index.html","hash":"c373e5dca71f7e465eeea70008077eefa52547e7","modified":1692585898119},{"_id":"public/2023/08/09/拥塞窗口的策略机制/index.html","hash":"9e7169d2155ebca53391b23717f0793382e60505","modified":1692585898119},{"_id":"public/2023/08/09/Vue.js系列：实现一个自己的vue/index.html","hash":"313fe7cc05cac34cd1eabfc4a66eb236234bf375","modified":1692585898119},{"_id":"public/2023/08/09/Vue.js系列：实现一个自己的vue续篇/index.html","hash":"f3d9f42325ac91287a08530901df2f2e00d65401","modified":1692585898119},{"_id":"public/2023/08/07/Vue.js系列：patch/index.html","hash":"3bb53d2115d06ff2207de99bda0444b38cba528e","modified":1692585898119},{"_id":"public/2023/08/07/Vue.js系列：虚拟dom/index.html","hash":"09baed0e340382e6add9f5e80fa84d3be79079f3","modified":1692585898119},{"_id":"public/2023/08/07/Vue.js系列：对象的变化侦测/index.html","hash":"0b78c0689793eaff339aaf855480ea73c9734383","modified":1692585898119},{"_id":"public/2023/08/07/Vue.js系列：序章/index.html","hash":"6e6b59f7ea669784108d0c102dcb45d148fb223e","modified":1692585898119},{"_id":"public/2023/08/07/js的转折分界-ES6/index.html","hash":"7fcb6eb7f96a8cd091f9cf02ccbe72139992f6f9","modified":1692585898119},{"_id":"public/2023/08/07/谷歌插件流程：第二回/index.html","hash":"263a18ebebaf00645c23b4128797f88a4d988dc8","modified":1692585898119},{"_id":"public/2023/08/03/性能的考量：第四回/index.html","hash":"49be28a8c3a72a7ae9e134b3297ff1eb595c2f84","modified":1692585898119},{"_id":"public/2023/08/03/谷歌插件流程：第一回/index.html","hash":"66be6745133008c06f13dfe4a82977170354428d","modified":1692585898119},{"_id":"public/2023/08/03/性能的考量：第三回/index.html","hash":"4df2f60b043b3b2077fb605a7e872faf40dab040","modified":1692585898119},{"_id":"public/2023/08/03/性能的考量：第二回/index.html","hash":"41e460b9f19780107a8055e53ee1dbd971424fc5","modified":1692585898119},{"_id":"public/2023/08/03/性能的考量：第一回/index.html","hash":"7cd0b41bfa32642a5ac64d6af5f2580031278f11","modified":1692585898119},{"_id":"public/2023/08/03/设计模式：单例模式/index.html","hash":"667cac015dda5959a0e18bc428b33fa30a7579ee","modified":1692585898119},{"_id":"public/2023/08/03/js的上古规则-原型链那些事儿/index.html","hash":"276e4f335297d49999f6fd9899de8e0901ddd92c","modified":1692585898119},{"_id":"public/2023/08/03/JS类型详论/index.html","hash":"d521e078ba1a08c208a68880ff2b052b28c41901","modified":1692585898119},{"_id":"public/2023/08/03/Git亲妈级教程/index.html","hash":"248c438aded8a5e2e643731cbb416f8227ff81f4","modified":1692585898119},{"_id":"public/2023/08/03/关于所谓的“梯子”的实现逻辑/index.html","hash":"193855d3d8bf7491c10040f3807b33d413933abb","modified":1692585898119},{"_id":"public/2023/08/03/down视频资源时的偶然发现/index.html","hash":"dd6f044dbe2bc96e5a09fe8b898bfb7fef746eea","modified":1692585898119},{"_id":"public/2023/08/03/HTTP版本演进：第三回/index.html","hash":"5fe9dd461243604de0c065924d081f53bab80d3b","modified":1692585898119},{"_id":"public/2023/08/02/HTTP版本演进：第二回/index.html","hash":"1f6b46639eab83ad88a4337f14d8993e11e9e575","modified":1692585898119},{"_id":"public/2023/08/02/HTTP版本演进：第一回/index.html","hash":"44bd2490af7cc30b37e52afff67f6b61af5d9ee4","modified":1692585898119},{"_id":"public/2023/07/31/四轴无人机研究：第一回/index.html","hash":"c3b4c085668a7b91b672f476032ff2e7e7deedab","modified":1692585898119},{"_id":"public/2023/07/28/Webkit系列：第一回/index.html","hash":"991e9073b23475fe27930ee30e92aa40a4330d06","modified":1692585898119},{"_id":"public/2023/07/24/Webpack系列：第三回/index.html","hash":"2c633904efddcbd9371193ef9a50b5d7ac56cb8d","modified":1692585898119},{"_id":"public/2023/07/24/Webpack系列：第二回/index.html","hash":"595ad0bac047d0137a975f962d6e033761aab19c","modified":1692585898119},{"_id":"public/2023/07/24/Webpack系列：第一回/index.html","hash":"a8d870c19e8a9e34a2b2653e93f9f6b2149122ab","modified":1692585898119},{"_id":"public/2023/07/24/《万神殿》-上载智能/index.html","hash":"26bba7667c695053dc3d7f5dd440fd90a971376d","modified":1692585898119},{"_id":"public/2023/07/24/做好预备动作/index.html","hash":"a7e0e6387da40f55989e70912577bf749ab3e0db","modified":1692585898119},{"_id":"public/archives/index.html","hash":"f9ee3bed3a0a34299d86956e55358d0f300f35d6","modified":1692585898119},{"_id":"public/archives/page/2/index.html","hash":"e0649ffd8750fac71aa0d9d22eff064e08da9700","modified":1692585898119},{"_id":"public/archives/page/3/index.html","hash":"f1d6a03644f388b3449610b7a4daaf1949a2786f","modified":1692585898119},{"_id":"public/archives/page/4/index.html","hash":"548a6af65b17a02ca89964843e619a2d0d764273","modified":1692585898119},{"_id":"public/archives/2023/index.html","hash":"dc023a77fb77b457deedc7c1854ee3ca30b1c7d7","modified":1692585898119},{"_id":"public/archives/2023/page/2/index.html","hash":"4096ba1166c3735c538320c57d89687de68d484c","modified":1692585898119},{"_id":"public/archives/2023/page/3/index.html","hash":"9420774e5932b6c72be7394427fc4508710ce572","modified":1692585898119},{"_id":"public/archives/2023/page/4/index.html","hash":"7fb109efdd22d0ee53adc9700f65aef658a561fb","modified":1692585898119},{"_id":"public/archives/2023/07/index.html","hash":"a17505e576e66952cf3255c20365693f6566a7b7","modified":1692585898119},{"_id":"public/archives/2023/08/index.html","hash":"d44353aac9e791e9f174e74262c33b625371baba","modified":1692585898119},{"_id":"public/archives/2023/08/page/2/index.html","hash":"42b90c25421511a6707fd93b6a7801575291443a","modified":1692585898119},{"_id":"public/archives/2023/08/page/3/index.html","hash":"aa3da940c007ab13ccb3d85e93c338bb92cf0cf2","modified":1692585898119},{"_id":"public/categories/Webkit系列/index.html","hash":"addaf0c7688f0f1288df524385f4d9e635419a0d","modified":1692585898119},{"_id":"public/categories/无人机系列/index.html","hash":"6aaf91cb494be950873f3aea84f75d055839b938","modified":1692585898119},{"_id":"public/categories/大前端气宗专栏/index.html","hash":"0d686c75b109cbdb6e707480bbcb92c2eb2e3170","modified":1692585898119},{"_id":"public/categories/网络杂谈/index.html","hash":"529ebc135849d6724862f162ea98760a3f5aeeec","modified":1692585898119},{"_id":"public/categories/大前端剑宗专栏/index.html","hash":"92238af49939b00e6fe610e5065d322679ca2369","modified":1692585898119},{"_id":"public/categories/大前端剑宗专栏/page/2/index.html","hash":"ebba5a59b565576a7068263153b4fe32c33aff17","modified":1692585898119},{"_id":"public/categories/Webpack/index.html","hash":"59c38d80d9eea772de4428ae74f04926dd8bab16","modified":1692585898119},{"_id":"public/categories/杂谈/index.html","hash":"4c6cd59752e64be316c670ca268c5f26a6073d01","modified":1692585898119},{"_id":"public/categories/性能的考量/index.html","hash":"1d1d2716ddfb250ddce3182f47d203df9423b359","modified":1692585898119},{"_id":"public/index.html","hash":"5bfea111d272a6c0b470bc796597aba741c858a0","modified":1692585898119},{"_id":"public/page/3/index.html","hash":"615d50c4be382f9c6843f237f6e633a4d05c69bd","modified":1692585898119},{"_id":"public/page/2/index.html","hash":"891fe4d6b7d8f606343bd21149e56a0d3b0fa830","modified":1692585898119},{"_id":"public/page/4/index.html","hash":"a7d558f36f5178056ac2799eaf9e3670d7b237db","modified":1692585898119},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1692585898119},{"_id":"public/img/cherry.jpg","hash":"44021a61fc08a9503fe4c0a07e04b28fd7af6246","modified":1692585898119},{"_id":"public/img/chrome1.png","hash":"b8cecdb5c18ea4f288136bacac28644d1e5df570","modified":1692585898119},{"_id":"public/img/debugger.png","hash":"d31afdf7697916bf0829d662d3a325ea477873ff","modified":1692585898119},{"_id":"public/img/chrome2.png","hash":"18fe14d0daf545860bb0985b8182a39753253ead","modified":1692585898119},{"_id":"public/img/f.jpg","hash":"63e6faf361c4544360213f43418ca8993c25f4c4","modified":1692585898119},{"_id":"public/img/defer.png","hash":"a14e47a4bbf3bad8533764b6efc1de502ad67b71","modified":1692585898119},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1692585898119},{"_id":"public/img/git.jpg","hash":"02f9c6c86ee87148781dfa3f978a034b20f40309","modified":1692585898119},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1692585898119},{"_id":"public/img/http.webp","hash":"048494ed0b7ae060e26b98c3204f8c7813b59027","modified":1692585898119},{"_id":"public/img/http3.jpg","hash":"c144b5bcaae5a82e84494a8cfc0697bce80e593f","modified":1692585898119},{"_id":"public/img/http6.webp","hash":"68c8fd7a1d3e98ffc6271af8410cfbddbcc6bd94","modified":1692585898119},{"_id":"public/img/http5.jpg","hash":"b6f0da80a04fd80bc2dcbcd479b8166a86a889ac","modified":1692585898119},{"_id":"public/img/http8.jpg","hash":"8e6362a91f26fd11301d72dbb1fc5beff13cf2fd","modified":1692585898119},{"_id":"public/img/ladder.webp","hash":"f90b7e15e28dd74927d11d0c4b4a7c0784409fc4","modified":1692585898119},{"_id":"public/img/js原型链.webp","hash":"800fe38f669022c61e61be6b0a13f5e78e2ae49d","modified":1692585898119},{"_id":"public/img/layout.jpeg","hash":"9f02179d493555d4b00a8e8c5738d51c1be1b7dd","modified":1692585898119},{"_id":"public/img/layout.webp","hash":"6a7211f732bcee2fcff2ccf0fcb187a3138c65a9","modified":1692585898119},{"_id":"public/img/nginx.jpg","hash":"7e02e60233e3180c23450a92a0dd6cbe9a038da0","modified":1692585898119},{"_id":"public/img/p2.webp","hash":"73ddebc8e82dfc5ece5911197e8fb1dea1ec0184","modified":1692585898119},{"_id":"public/img/p.jpg","hash":"a21a365d6d69d924a4ed7e886020d36e361b1289","modified":1692585898119},{"_id":"public/img/vue1.png","hash":"7b82bc127dcb7a3287b4464d5c721688c3c00a31","modified":1692585898119},{"_id":"public/img/vue_basic_1.jpg","hash":"60cb3ceae7fb4b846f658929bb66095a8bf0ffa3","modified":1692585898119},{"_id":"public/img/vue_basic_2.png","hash":"aa8749a596a7a7a48a4ef67d474684cfec51826b","modified":1692585898119},{"_id":"public/img/无奈.webp","hash":"1688346de00d769630763a078cd44dbf835a87e4","modified":1692585898119},{"_id":"public/img/你知道的太多了.jpg","hash":"91ef0614c9f7890cab00160562a67ac2d3be6c87","modified":1692585898119},{"_id":"public/img/http2.jpg","hash":"cc0b4950de62b404661b9fff80d4fbab1411d4a7","modified":1692585898119},{"_id":"public/img/http4.jpg","hash":"d37a9c42e705729dc7c124c7293661eeab523b06","modified":1692585898119},{"_id":"public/img/http7.jpg","hash":"c5f76dd20729d89712debfb5bd1563b7290ba70b","modified":1692585898119},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1692585898119},{"_id":"public/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1692585898119},{"_id":"public/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1692585898119},{"_id":"public/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1692585898119},{"_id":"public/css/index.css","hash":"8b7de3ac431296a557cf85607735050f9101b5f1","modified":1692585898119},{"_id":"public/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1692585898119},{"_id":"public/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1692585898119},{"_id":"public/img/chrome3.png","hash":"82a5fc0ee29a1585000af885dc64bca2decd054f","modified":1692585898119},{"_id":"public/img/tra.jpg","hash":"04d067757a49b78acf8145daa7abaebb866e8283","modified":1692585898119},{"_id":"public/img/air.png","hash":"4e2268189e42f21c1b4960a5a3208cc90ec13e63","modified":1692585898119},{"_id":"public/img/rrick.jpg","hash":"955c42b436a99bd289eca219916a112128904de6","modified":1692585898119},{"_id":"public/img/avatar.jpg","hash":"c49270e383f2d7deffea82222e8a8455ff356b02","modified":1692585898119},{"_id":"public/img/zhihu.png","hash":"6a403681d190d3da5a209b82f982c0b5c74b6322","modified":1692585898119}],"Category":[{"name":"大前端气宗专栏","_id":"cllk9xxvk0002f8v7f7chhl36"},{"name":"网络杂谈","_id":"cllk9xxvo0006f8v7boeb7qi7"},{"name":"大前端剑宗专栏","_id":"cllk9xxvu000mf8v7b1ryhv1r"},{"name":"Webkit系列","_id":"cllk9xxw2001jf8v7dnj8eqvb"},{"name":"Webpack","_id":"cllk9xxw3001of8v7eo2m5ehk"},{"name":"杂谈","_id":"cllk9xxw90026f8v7h9u592ek"},{"name":"性能的考量","_id":"cllk9xxwa002cf8v71hjzgocn"},{"name":"无人机系列","_id":"cllk9xxwa002ff8v74e1b6fdg"}],"Data":[],"Page":[],"Post":[{"title":"Git亲妈级教程","date":"2023-08-03T03:20:52.000Z","_content":"\n- 一般的代码提交流程：\n```javascript\ngit add .\ngit commit -m 'message'\ngit push\n```\n提交到自己的分支，发起合并到dev分支的merge交由负责人审查合并代码。\n<img src=\"/img/git.jpg\" alt=\"图片描述\" width=\"500\">\n\n- 克隆分支并同步远端\n```javascript\ngit checkout -b '分支名'\ngit push origin '分支名'\n```\n\n- 查看哪些文件被修改及修改的内容\n```javascript\ngit diff --cached\n```\n\n- 本地仓库与远程主机仓库关联起来\n```javascript\ngit remote add origin \"https://github.com/kinglion580/shiyanlou.git\"\n```\n\n- 如何在本地给远程仓库创建一个分支？（就是远程仓库没有该分支）\n首先需要在本地新建一个分支： git checkout -b 分支名\n同步到远程：git push --set-upstream origin 分支名\n然后通过命令直接push到远程：git push\n\n- 如何在本地删除远程分支\n```javascript\n// 删除本地分支\ngit branch -d 分支名\n\n// 删除远程分支\ngit push origin --delete 分支名\n\n// 本地分支和远程同步\ngit remote update upstream --prune\n```\n\n- 有时候，我们在自己分支上写的好好的，突然需要切换到别的分支，而此时，我们又不想commit，咋办？\n**git stash,可以理解为暂时保存，切换到其他分支，干完后，回到自己的分支,git stash pop，恢复**\n\n- 如果代码写到一半，突然发现写错分支，该如何？\n**同7类似，即，执行暂存git stash,但是随后切换到正确分支，执行git stash pop,即将自己的一波操作释放到正确的分支上了**\n\n- 但我修改了一处小bug提交时，不想写个message做新的commit,转而合并最近一次提交，该如何？\n**git commit --amend,包您满意，实质就是，覆盖最近一次提交**\n\n- 当自己在主分支写测试代码后，没有add 和commit的情况下，想放弃在该分支上的所有修改切换回自己的分支，此种场景下，该如何？\n```javascript\n// 撤销对所有已修改但未提交的文件的修改，但不包括新增的文件\ngit checkout .\n// 撤销对指定文件的修改，[filename]为文件名\ngit checkout [filename] \n```\n- 撤销add\n```javascript\n// 撤销全部\ngit reset HEAD .\n// 撤销某文件或者文件夹\ngit reset HEAD -filename\n```\n\n- 撤销commit\n```javascript\ngit reset --soft HEAD~1\n```\n\n- 其他常用操作\n```javascript\n// 回退\ngit reset --hard git版本号 \ngit push -f\n// 查看当前分支数\ngit branch -a\n// 合并提交记录\ngit rebase -i HEAD~分枝数\ngit push -f\n\n// 查看本地的git配置信息\ngit config --global -l\ngit config --list 查看所有信息\n```\n\n- cherry-pic合并指定分支的某个提交\n<img src=\"/img/cherry.jpg\" alt=\"图片描述\" width=\"500\">\n\n- 团队协作相关\n在公司的开发过程中，一个项目的至少有三个分支。master（线上-在跑的代码）、stagging（类似于测试）、dev（开发分支）。**大体分成两种工作方式。**\n1. 所有的开发人员，在项目中都有自己的dev分支，通常命名dev_dadadad.....。每次开发完毕后，发起合并请求，负责人合并到stagging分支进行测试。\n2. 开发人员需要fork一下项目，相当于创建一个自己私人的项目。克隆到本地后做的第一件事情，就是关联主项目。设置origin和upstream仓库地址，分别是自己的项目和主项目的地址。\n```javascript\ngit remote add upstream + 主项目代码\n```\n这样，当我们通过git remote -v命令，在控制台打印当前fork项目的远程信息时，会出现下面所示：\n```javascript\norigin  fork地址 (fetch)\norigin  fork地址 (push)\nupstream        主项目地址(fetch)\nupstream        主项目地址(push)\n```\n每次开发前，通过如下命令拉取并合并主项目dev分支的最新代码：\n```javascript\ngit pull upstream dev\n```\n**注意，上面的命令做了两件事，第一，拉去目标分支代码，第二，自动合并到当前所在分支。**","source":"_posts/Git亲妈级教程.md","raw":"---\ntitle: Git亲妈级教程\ncategory: 大前端气宗专栏\ndate: 2023-08-03 11:20:52\ntags:\n---\n\n- 一般的代码提交流程：\n```javascript\ngit add .\ngit commit -m 'message'\ngit push\n```\n提交到自己的分支，发起合并到dev分支的merge交由负责人审查合并代码。\n<img src=\"/img/git.jpg\" alt=\"图片描述\" width=\"500\">\n\n- 克隆分支并同步远端\n```javascript\ngit checkout -b '分支名'\ngit push origin '分支名'\n```\n\n- 查看哪些文件被修改及修改的内容\n```javascript\ngit diff --cached\n```\n\n- 本地仓库与远程主机仓库关联起来\n```javascript\ngit remote add origin \"https://github.com/kinglion580/shiyanlou.git\"\n```\n\n- 如何在本地给远程仓库创建一个分支？（就是远程仓库没有该分支）\n首先需要在本地新建一个分支： git checkout -b 分支名\n同步到远程：git push --set-upstream origin 分支名\n然后通过命令直接push到远程：git push\n\n- 如何在本地删除远程分支\n```javascript\n// 删除本地分支\ngit branch -d 分支名\n\n// 删除远程分支\ngit push origin --delete 分支名\n\n// 本地分支和远程同步\ngit remote update upstream --prune\n```\n\n- 有时候，我们在自己分支上写的好好的，突然需要切换到别的分支，而此时，我们又不想commit，咋办？\n**git stash,可以理解为暂时保存，切换到其他分支，干完后，回到自己的分支,git stash pop，恢复**\n\n- 如果代码写到一半，突然发现写错分支，该如何？\n**同7类似，即，执行暂存git stash,但是随后切换到正确分支，执行git stash pop,即将自己的一波操作释放到正确的分支上了**\n\n- 但我修改了一处小bug提交时，不想写个message做新的commit,转而合并最近一次提交，该如何？\n**git commit --amend,包您满意，实质就是，覆盖最近一次提交**\n\n- 当自己在主分支写测试代码后，没有add 和commit的情况下，想放弃在该分支上的所有修改切换回自己的分支，此种场景下，该如何？\n```javascript\n// 撤销对所有已修改但未提交的文件的修改，但不包括新增的文件\ngit checkout .\n// 撤销对指定文件的修改，[filename]为文件名\ngit checkout [filename] \n```\n- 撤销add\n```javascript\n// 撤销全部\ngit reset HEAD .\n// 撤销某文件或者文件夹\ngit reset HEAD -filename\n```\n\n- 撤销commit\n```javascript\ngit reset --soft HEAD~1\n```\n\n- 其他常用操作\n```javascript\n// 回退\ngit reset --hard git版本号 \ngit push -f\n// 查看当前分支数\ngit branch -a\n// 合并提交记录\ngit rebase -i HEAD~分枝数\ngit push -f\n\n// 查看本地的git配置信息\ngit config --global -l\ngit config --list 查看所有信息\n```\n\n- cherry-pic合并指定分支的某个提交\n<img src=\"/img/cherry.jpg\" alt=\"图片描述\" width=\"500\">\n\n- 团队协作相关\n在公司的开发过程中，一个项目的至少有三个分支。master（线上-在跑的代码）、stagging（类似于测试）、dev（开发分支）。**大体分成两种工作方式。**\n1. 所有的开发人员，在项目中都有自己的dev分支，通常命名dev_dadadad.....。每次开发完毕后，发起合并请求，负责人合并到stagging分支进行测试。\n2. 开发人员需要fork一下项目，相当于创建一个自己私人的项目。克隆到本地后做的第一件事情，就是关联主项目。设置origin和upstream仓库地址，分别是自己的项目和主项目的地址。\n```javascript\ngit remote add upstream + 主项目代码\n```\n这样，当我们通过git remote -v命令，在控制台打印当前fork项目的远程信息时，会出现下面所示：\n```javascript\norigin  fork地址 (fetch)\norigin  fork地址 (push)\nupstream        主项目地址(fetch)\nupstream        主项目地址(push)\n```\n每次开发前，通过如下命令拉取并合并主项目dev分支的最新代码：\n```javascript\ngit pull upstream dev\n```\n**注意，上面的命令做了两件事，第一，拉去目标分支代码，第二，自动合并到当前所在分支。**","slug":"Git亲妈级教程","published":1,"updated":"2023-08-21T01:52:54.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxvf0000f8v75mrpbzet","content":"<ul>\n<li><p>一般的代码提交流程：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">&#x27;message&#x27;</span></span><br><span class=\"line\">git push</span><br></pre></td></tr></table></figure>\n<p>提交到自己的分支，发起合并到dev分支的merge交由负责人审查合并代码。</p>\n<img src=\"/img/git.jpg\" alt=\"图片描述\" width=\"500\">\n</li>\n<li><p>克隆分支并同步远端</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b <span class=\"string\">&#x27;分支名&#x27;</span></span><br><span class=\"line\">git push origin <span class=\"string\">&#x27;分支名&#x27;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看哪些文件被修改及修改的内容</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff --cached</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>本地仓库与远程主机仓库关联起来</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin <span class=\"string\">&quot;https://github.com/kinglion580/shiyanlou.git&quot;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如何在本地给远程仓库创建一个分支？（就是远程仓库没有该分支）<br>首先需要在本地新建一个分支： git checkout -b 分支名<br>同步到远程：git push –set-upstream origin 分支名<br>然后通过命令直接push到远程：git push</p>\n</li>\n<li><p>如何在本地删除远程分支</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除本地分支</span></span><br><span class=\"line\">git branch -d 分支名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除远程分支</span></span><br><span class=\"line\">git push origin --<span class=\"keyword\">delete</span> 分支名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 本地分支和远程同步</span></span><br><span class=\"line\">git remote update upstream --prune</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>有时候，我们在自己分支上写的好好的，突然需要切换到别的分支，而此时，我们又不想commit，咋办？<br><strong>git stash,可以理解为暂时保存，切换到其他分支，干完后，回到自己的分支,git stash pop，恢复</strong></p>\n</li>\n<li><p>如果代码写到一半，突然发现写错分支，该如何？<br><strong>同7类似，即，执行暂存git stash,但是随后切换到正确分支，执行git stash pop,即将自己的一波操作释放到正确的分支上了</strong></p>\n</li>\n<li><p>但我修改了一处小bug提交时，不想写个message做新的commit,转而合并最近一次提交，该如何？<br><strong>git commit –amend,包您满意，实质就是，覆盖最近一次提交</strong></p>\n</li>\n<li><p>当自己在主分支写测试代码后，没有add 和commit的情况下，想放弃在该分支上的所有修改切换回自己的分支，此种场景下，该如何？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 撤销对所有已修改但未提交的文件的修改，但不包括新增的文件</span></span><br><span class=\"line\">git checkout .</span><br><span class=\"line\"><span class=\"comment\">// 撤销对指定文件的修改，[filename]为文件名</span></span><br><span class=\"line\">git checkout [filename] </span><br></pre></td></tr></table></figure></li>\n<li><p>撤销add</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 撤销全部</span></span><br><span class=\"line\">git reset <span class=\"variable constant_\">HEAD</span> .</span><br><span class=\"line\"><span class=\"comment\">// 撤销某文件或者文件夹</span></span><br><span class=\"line\">git reset <span class=\"variable constant_\">HEAD</span> -filename</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>撤销commit</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --soft <span class=\"variable constant_\">HEAD</span>~<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>其他常用操作</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 回退</span></span><br><span class=\"line\">git reset --hard git版本号 </span><br><span class=\"line\">git push -f</span><br><span class=\"line\"><span class=\"comment\">// 查看当前分支数</span></span><br><span class=\"line\">git branch -a</span><br><span class=\"line\"><span class=\"comment\">// 合并提交记录</span></span><br><span class=\"line\">git rebase -i <span class=\"variable constant_\">HEAD</span>~分枝数</span><br><span class=\"line\">git push -f</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查看本地的git配置信息</span></span><br><span class=\"line\">git config --<span class=\"variable language_\">global</span> -l</span><br><span class=\"line\">git config --list 查看所有信息</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>cherry-pic合并指定分支的某个提交</p>\n<img src=\"/img/cherry.jpg\" alt=\"图片描述\" width=\"500\">\n</li>\n<li><p>团队协作相关<br>在公司的开发过程中，一个项目的至少有三个分支。master（线上-在跑的代码）、stagging（类似于测试）、dev（开发分支）。<strong>大体分成两种工作方式。</strong></p>\n</li>\n</ul>\n<ol>\n<li>所有的开发人员，在项目中都有自己的dev分支，通常命名dev_dadadad…..。每次开发完毕后，发起合并请求，负责人合并到stagging分支进行测试。</li>\n<li>开发人员需要fork一下项目，相当于创建一个自己私人的项目。克隆到本地后做的第一件事情，就是关联主项目。设置origin和upstream仓库地址，分别是自己的项目和主项目的地址。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add upstream + 主项目代码</span><br></pre></td></tr></table></figure>\n这样，当我们通过git remote -v命令，在控制台打印当前fork项目的远程信息时，会出现下面所示：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">origin  fork地址 (fetch)</span><br><span class=\"line\">origin  fork地址 (push)</span><br><span class=\"line\">upstream        主项目地址(fetch)</span><br><span class=\"line\">upstream        主项目地址(push)</span><br></pre></td></tr></table></figure>\n每次开发前，通过如下命令拉取并合并主项目dev分支的最新代码：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull upstream dev</span><br></pre></td></tr></table></figure>\n<strong>注意，上面的命令做了两件事，第一，拉去目标分支代码，第二，自动合并到当前所在分支。</strong></li>\n</ol>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<ul>\n<li><p>一般的代码提交流程：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">&#x27;message&#x27;</span></span><br><span class=\"line\">git push</span><br></pre></td></tr></table></figure>\n<p>提交到自己的分支，发起合并到dev分支的merge交由负责人审查合并代码。</p>\n<img src=\"/img/git.jpg\" alt=\"图片描述\" width=\"500\">\n</li>\n<li><p>克隆分支并同步远端</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b <span class=\"string\">&#x27;分支名&#x27;</span></span><br><span class=\"line\">git push origin <span class=\"string\">&#x27;分支名&#x27;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看哪些文件被修改及修改的内容</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff --cached</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>本地仓库与远程主机仓库关联起来</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin <span class=\"string\">&quot;https://github.com/kinglion580/shiyanlou.git&quot;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如何在本地给远程仓库创建一个分支？（就是远程仓库没有该分支）<br>首先需要在本地新建一个分支： git checkout -b 分支名<br>同步到远程：git push –set-upstream origin 分支名<br>然后通过命令直接push到远程：git push</p>\n</li>\n<li><p>如何在本地删除远程分支</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除本地分支</span></span><br><span class=\"line\">git branch -d 分支名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除远程分支</span></span><br><span class=\"line\">git push origin --<span class=\"keyword\">delete</span> 分支名</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 本地分支和远程同步</span></span><br><span class=\"line\">git remote update upstream --prune</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>有时候，我们在自己分支上写的好好的，突然需要切换到别的分支，而此时，我们又不想commit，咋办？<br><strong>git stash,可以理解为暂时保存，切换到其他分支，干完后，回到自己的分支,git stash pop，恢复</strong></p>\n</li>\n<li><p>如果代码写到一半，突然发现写错分支，该如何？<br><strong>同7类似，即，执行暂存git stash,但是随后切换到正确分支，执行git stash pop,即将自己的一波操作释放到正确的分支上了</strong></p>\n</li>\n<li><p>但我修改了一处小bug提交时，不想写个message做新的commit,转而合并最近一次提交，该如何？<br><strong>git commit –amend,包您满意，实质就是，覆盖最近一次提交</strong></p>\n</li>\n<li><p>当自己在主分支写测试代码后，没有add 和commit的情况下，想放弃在该分支上的所有修改切换回自己的分支，此种场景下，该如何？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 撤销对所有已修改但未提交的文件的修改，但不包括新增的文件</span></span><br><span class=\"line\">git checkout .</span><br><span class=\"line\"><span class=\"comment\">// 撤销对指定文件的修改，[filename]为文件名</span></span><br><span class=\"line\">git checkout [filename] </span><br></pre></td></tr></table></figure></li>\n<li><p>撤销add</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 撤销全部</span></span><br><span class=\"line\">git reset <span class=\"variable constant_\">HEAD</span> .</span><br><span class=\"line\"><span class=\"comment\">// 撤销某文件或者文件夹</span></span><br><span class=\"line\">git reset <span class=\"variable constant_\">HEAD</span> -filename</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>撤销commit</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --soft <span class=\"variable constant_\">HEAD</span>~<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>其他常用操作</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 回退</span></span><br><span class=\"line\">git reset --hard git版本号 </span><br><span class=\"line\">git push -f</span><br><span class=\"line\"><span class=\"comment\">// 查看当前分支数</span></span><br><span class=\"line\">git branch -a</span><br><span class=\"line\"><span class=\"comment\">// 合并提交记录</span></span><br><span class=\"line\">git rebase -i <span class=\"variable constant_\">HEAD</span>~分枝数</span><br><span class=\"line\">git push -f</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查看本地的git配置信息</span></span><br><span class=\"line\">git config --<span class=\"variable language_\">global</span> -l</span><br><span class=\"line\">git config --list 查看所有信息</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>cherry-pic合并指定分支的某个提交</p>\n<img src=\"/img/cherry.jpg\" alt=\"图片描述\" width=\"500\">\n</li>\n<li><p>团队协作相关<br>在公司的开发过程中，一个项目的至少有三个分支。master（线上-在跑的代码）、stagging（类似于测试）、dev（开发分支）。<strong>大体分成两种工作方式。</strong></p>\n</li>\n</ul>\n<ol>\n<li>所有的开发人员，在项目中都有自己的dev分支，通常命名dev_dadadad…..。每次开发完毕后，发起合并请求，负责人合并到stagging分支进行测试。</li>\n<li>开发人员需要fork一下项目，相当于创建一个自己私人的项目。克隆到本地后做的第一件事情，就是关联主项目。设置origin和upstream仓库地址，分别是自己的项目和主项目的地址。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add upstream + 主项目代码</span><br></pre></td></tr></table></figure>\n这样，当我们通过git remote -v命令，在控制台打印当前fork项目的远程信息时，会出现下面所示：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">origin  fork地址 (fetch)</span><br><span class=\"line\">origin  fork地址 (push)</span><br><span class=\"line\">upstream        主项目地址(fetch)</span><br><span class=\"line\">upstream        主项目地址(push)</span><br></pre></td></tr></table></figure>\n每次开发前，通过如下命令拉取并合并主项目dev分支的最新代码：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull upstream dev</span><br></pre></td></tr></table></figure>\n<strong>注意，上面的命令做了两件事，第一，拉去目标分支代码，第二，自动合并到当前所在分支。</strong></li>\n</ol>\n"},{"title":"HTTP版本演进：第一回","date":"2023-08-02T15:02:20.000Z","_content":"\n**本系列文章，会严重参考《高性能浏览器网络》和《HTTP权威指南》**\n\n**前言**：\nhttp的设计思路，起源于20世纪三十年代的一篇文章：《As we may think》，作者美国MIT工程学院的电子工程师Vannevar Bush，该文主要是研究了人们生产的信息量和社会消化信息的能力。一句话总结结论：**信息太多，查找信息太费劲。得设计一个更牛叉的东西，帮助我们提高效率。这就是http超文本概念的起源，超越文本的信息存在**。虽然概念的正式提出得30多年之后但是，在此还是由衷的对这些”仰望星空的前辈们致敬“。\nhttp和https：http就是超文本传输协议，所谓的协议就是一种约定，约定了在双方或者多方之间传输的数据的格式，仅此而已。这是1991年万维网之父伯纳斯李同学提出并设计的一套协议。主要目的就是机器之间能够互传资源，实现网络互联的真实需求。请求与响应。即：客户端向服务器发送资源请求，服务器端响应返回对应资源。https则是在http之外，又包了一层SSL，也就是安全套接层，用于加密传输，保证数据的可靠性。\n\n总体划分四个版本：0.9、1.0、1.1和2.0\n\n### 0.9版本\n该版本可以视为初代机，只有一个目标：机器之间实现通信。只支持get请求，ascii码字符流传输。没有请求头响应头,没有MIME类型。**说白了，就是只有文本，其他啥都没有。**流程：tcp三次握手建立链路，发送请求，获取响应，断开连接。前一个请求响应返回之后，发起第二个请求，过程周而复始。\n**注**：MIME是一种文本标记，常见的如text/plain、text/html、image/jpeg等。规则：对象类型/特定子类型\n\n```javascript\ntelnet google.com 80\nConnection to xxx.xxx.xxx.xxx\nGET /about/\nHTML response...\nconnection closed\n```\n\n### 1.0版本\n相较于0.9版本，除get请求，新增了post、put等其他方式。同时有了首部、状态码的概念，有了重定向、压缩等的功能加持。有了MIME类型，支持多媒体资源传输。那么从1.0开始，http严格意义上应该称之为HMTP（hypermedia transport）。请求响应流程还是0.9那一套。\n\n<img src=\"/img/http.webp\" alt=\"图片描述\" width=\"500\" height=\"300\">\n\n### 1.1版本\n同前两个版本比较，1.1版本的改进：\n- 长连接connection：keep-alive。这就意味着，多个请求可以共用一条链路（在不主动断开连接的情况下）。假设页面需要发送nci请求，在以前的版本中，耗时2 * n * rtt（单次往返耗时）。现在只需要(n + 1) * rtt\n- 数据切分成块乱序传输，响应按照请求的顺序返回。\n- 新增cache-control缓存资源，特定的资源无需发送请求。\n- 管道化。请求无需等待并行发送。\n\n<img src=\"/img/http2.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\">\n\n### 2.0版本\nhttp2.0的设计初衷只有一个，就是提高传输性能，包括低延时和高吞吐量。二进制分帧，将数据块分成更小的数据帧。多路复用，响应并行交错返回。头部压缩.详细介绍见后续文章\n","source":"_posts/HTTP版本演进：第一回.md","raw":"---\ntitle: HTTP版本演进：第一回\ncategory: 网络杂谈\ndate: 2023-08-02 23:02:20\ntags:\n---\n\n**本系列文章，会严重参考《高性能浏览器网络》和《HTTP权威指南》**\n\n**前言**：\nhttp的设计思路，起源于20世纪三十年代的一篇文章：《As we may think》，作者美国MIT工程学院的电子工程师Vannevar Bush，该文主要是研究了人们生产的信息量和社会消化信息的能力。一句话总结结论：**信息太多，查找信息太费劲。得设计一个更牛叉的东西，帮助我们提高效率。这就是http超文本概念的起源，超越文本的信息存在**。虽然概念的正式提出得30多年之后但是，在此还是由衷的对这些”仰望星空的前辈们致敬“。\nhttp和https：http就是超文本传输协议，所谓的协议就是一种约定，约定了在双方或者多方之间传输的数据的格式，仅此而已。这是1991年万维网之父伯纳斯李同学提出并设计的一套协议。主要目的就是机器之间能够互传资源，实现网络互联的真实需求。请求与响应。即：客户端向服务器发送资源请求，服务器端响应返回对应资源。https则是在http之外，又包了一层SSL，也就是安全套接层，用于加密传输，保证数据的可靠性。\n\n总体划分四个版本：0.9、1.0、1.1和2.0\n\n### 0.9版本\n该版本可以视为初代机，只有一个目标：机器之间实现通信。只支持get请求，ascii码字符流传输。没有请求头响应头,没有MIME类型。**说白了，就是只有文本，其他啥都没有。**流程：tcp三次握手建立链路，发送请求，获取响应，断开连接。前一个请求响应返回之后，发起第二个请求，过程周而复始。\n**注**：MIME是一种文本标记，常见的如text/plain、text/html、image/jpeg等。规则：对象类型/特定子类型\n\n```javascript\ntelnet google.com 80\nConnection to xxx.xxx.xxx.xxx\nGET /about/\nHTML response...\nconnection closed\n```\n\n### 1.0版本\n相较于0.9版本，除get请求，新增了post、put等其他方式。同时有了首部、状态码的概念，有了重定向、压缩等的功能加持。有了MIME类型，支持多媒体资源传输。那么从1.0开始，http严格意义上应该称之为HMTP（hypermedia transport）。请求响应流程还是0.9那一套。\n\n<img src=\"/img/http.webp\" alt=\"图片描述\" width=\"500\" height=\"300\">\n\n### 1.1版本\n同前两个版本比较，1.1版本的改进：\n- 长连接connection：keep-alive。这就意味着，多个请求可以共用一条链路（在不主动断开连接的情况下）。假设页面需要发送nci请求，在以前的版本中，耗时2 * n * rtt（单次往返耗时）。现在只需要(n + 1) * rtt\n- 数据切分成块乱序传输，响应按照请求的顺序返回。\n- 新增cache-control缓存资源，特定的资源无需发送请求。\n- 管道化。请求无需等待并行发送。\n\n<img src=\"/img/http2.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\">\n\n### 2.0版本\nhttp2.0的设计初衷只有一个，就是提高传输性能，包括低延时和高吞吐量。二进制分帧，将数据块分成更小的数据帧。多路复用，响应并行交错返回。头部压缩.详细介绍见后续文章\n","slug":"HTTP版本演进：第一回","published":1,"updated":"2023-08-21T01:52:54.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxvi0001f8v732j3dxcd","content":"<p><strong>本系列文章，会严重参考《高性能浏览器网络》和《HTTP权威指南》</strong></p>\n<p><strong>前言</strong>：<br>http的设计思路，起源于20世纪三十年代的一篇文章：《As we may think》，作者美国MIT工程学院的电子工程师Vannevar Bush，该文主要是研究了人们生产的信息量和社会消化信息的能力。一句话总结结论：<strong>信息太多，查找信息太费劲。得设计一个更牛叉的东西，帮助我们提高效率。这就是http超文本概念的起源，超越文本的信息存在</strong>。虽然概念的正式提出得30多年之后但是，在此还是由衷的对这些”仰望星空的前辈们致敬“。<br>http和https：http就是超文本传输协议，所谓的协议就是一种约定，约定了在双方或者多方之间传输的数据的格式，仅此而已。这是1991年万维网之父伯纳斯李同学提出并设计的一套协议。主要目的就是机器之间能够互传资源，实现网络互联的真实需求。请求与响应。即：客户端向服务器发送资源请求，服务器端响应返回对应资源。https则是在http之外，又包了一层SSL，也就是安全套接层，用于加密传输，保证数据的可靠性。</p>\n<p>总体划分四个版本：0.9、1.0、1.1和2.0</p>\n<h3 id=\"0-9版本\"><a href=\"#0-9版本\" class=\"headerlink\" title=\"0.9版本\"></a>0.9版本</h3><p>该版本可以视为初代机，只有一个目标：机器之间实现通信。只支持get请求，ascii码字符流传输。没有请求头响应头,没有MIME类型。<strong>说白了，就是只有文本，其他啥都没有。</strong>流程：tcp三次握手建立链路，发送请求，获取响应，断开连接。前一个请求响应返回之后，发起第二个请求，过程周而复始。<br><strong>注</strong>：MIME是一种文本标记，常见的如text&#x2F;plain、text&#x2F;html、image&#x2F;jpeg等。规则：对象类型&#x2F;特定子类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">telnet google.<span class=\"property\">com</span> <span class=\"number\">80</span></span><br><span class=\"line\"><span class=\"title class_\">Connection</span> to xxx.<span class=\"property\">xxx</span>.<span class=\"property\">xxx</span>.<span class=\"property\">xxx</span></span><br><span class=\"line\"><span class=\"variable constant_\">GET</span> /about/</span><br><span class=\"line\"><span class=\"variable constant_\">HTML</span> response...</span><br><span class=\"line\">connection closed</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-0版本\"><a href=\"#1-0版本\" class=\"headerlink\" title=\"1.0版本\"></a>1.0版本</h3><p>相较于0.9版本，除get请求，新增了post、put等其他方式。同时有了首部、状态码的概念，有了重定向、压缩等的功能加持。有了MIME类型，支持多媒体资源传输。那么从1.0开始，http严格意义上应该称之为HMTP（hypermedia transport）。请求响应流程还是0.9那一套。</p>\n<img src=\"/img/http.webp\" alt=\"图片描述\" width=\"500\" height=\"300\">\n\n<h3 id=\"1-1版本\"><a href=\"#1-1版本\" class=\"headerlink\" title=\"1.1版本\"></a>1.1版本</h3><p>同前两个版本比较，1.1版本的改进：</p>\n<ul>\n<li>长连接connection：keep-alive。这就意味着，多个请求可以共用一条链路（在不主动断开连接的情况下）。假设页面需要发送nci请求，在以前的版本中，耗时2 * n * rtt（单次往返耗时）。现在只需要(n + 1) * rtt</li>\n<li>数据切分成块乱序传输，响应按照请求的顺序返回。</li>\n<li>新增cache-control缓存资源，特定的资源无需发送请求。</li>\n<li>管道化。请求无需等待并行发送。</li>\n</ul>\n<img src=\"/img/http2.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\">\n\n<h3 id=\"2-0版本\"><a href=\"#2-0版本\" class=\"headerlink\" title=\"2.0版本\"></a>2.0版本</h3><p>http2.0的设计初衷只有一个，就是提高传输性能，包括低延时和高吞吐量。二进制分帧，将数据块分成更小的数据帧。多路复用，响应并行交错返回。头部压缩.详细介绍见后续文章</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p><strong>本系列文章，会严重参考《高性能浏览器网络》和《HTTP权威指南》</strong></p>\n<p><strong>前言</strong>：<br>http的设计思路，起源于20世纪三十年代的一篇文章：《As we may think》，作者美国MIT工程学院的电子工程师Vannevar Bush，该文主要是研究了人们生产的信息量和社会消化信息的能力。一句话总结结论：<strong>信息太多，查找信息太费劲。得设计一个更牛叉的东西，帮助我们提高效率。这就是http超文本概念的起源，超越文本的信息存在</strong>。虽然概念的正式提出得30多年之后但是，在此还是由衷的对这些”仰望星空的前辈们致敬“。<br>http和https：http就是超文本传输协议，所谓的协议就是一种约定，约定了在双方或者多方之间传输的数据的格式，仅此而已。这是1991年万维网之父伯纳斯李同学提出并设计的一套协议。主要目的就是机器之间能够互传资源，实现网络互联的真实需求。请求与响应。即：客户端向服务器发送资源请求，服务器端响应返回对应资源。https则是在http之外，又包了一层SSL，也就是安全套接层，用于加密传输，保证数据的可靠性。</p>\n<p>总体划分四个版本：0.9、1.0、1.1和2.0</p>\n<h3 id=\"0-9版本\"><a href=\"#0-9版本\" class=\"headerlink\" title=\"0.9版本\"></a>0.9版本</h3><p>该版本可以视为初代机，只有一个目标：机器之间实现通信。只支持get请求，ascii码字符流传输。没有请求头响应头,没有MIME类型。<strong>说白了，就是只有文本，其他啥都没有。</strong>流程：tcp三次握手建立链路，发送请求，获取响应，断开连接。前一个请求响应返回之后，发起第二个请求，过程周而复始。<br><strong>注</strong>：MIME是一种文本标记，常见的如text&#x2F;plain、text&#x2F;html、image&#x2F;jpeg等。规则：对象类型&#x2F;特定子类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">telnet google.<span class=\"property\">com</span> <span class=\"number\">80</span></span><br><span class=\"line\"><span class=\"title class_\">Connection</span> to xxx.<span class=\"property\">xxx</span>.<span class=\"property\">xxx</span>.<span class=\"property\">xxx</span></span><br><span class=\"line\"><span class=\"variable constant_\">GET</span> /about/</span><br><span class=\"line\"><span class=\"variable constant_\">HTML</span> response...</span><br><span class=\"line\">connection closed</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-0版本\"><a href=\"#1-0版本\" class=\"headerlink\" title=\"1.0版本\"></a>1.0版本</h3><p>相较于0.9版本，除get请求，新增了post、put等其他方式。同时有了首部、状态码的概念，有了重定向、压缩等的功能加持。有了MIME类型，支持多媒体资源传输。那么从1.0开始，http严格意义上应该称之为HMTP（hypermedia transport）。请求响应流程还是0.9那一套。</p>\n<img src=\"/img/http.webp\" alt=\"图片描述\" width=\"500\" height=\"300\">\n\n<h3 id=\"1-1版本\"><a href=\"#1-1版本\" class=\"headerlink\" title=\"1.1版本\"></a>1.1版本</h3><p>同前两个版本比较，1.1版本的改进：</p>\n<ul>\n<li>长连接connection：keep-alive。这就意味着，多个请求可以共用一条链路（在不主动断开连接的情况下）。假设页面需要发送nci请求，在以前的版本中，耗时2 * n * rtt（单次往返耗时）。现在只需要(n + 1) * rtt</li>\n<li>数据切分成块乱序传输，响应按照请求的顺序返回。</li>\n<li>新增cache-control缓存资源，特定的资源无需发送请求。</li>\n<li>管道化。请求无需等待并行发送。</li>\n</ul>\n<img src=\"/img/http2.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\">\n\n<h3 id=\"2-0版本\"><a href=\"#2-0版本\" class=\"headerlink\" title=\"2.0版本\"></a>2.0版本</h3><p>http2.0的设计初衷只有一个，就是提高传输性能，包括低延时和高吞吐量。二进制分帧，将数据块分成更小的数据帧。多路复用，响应并行交错返回。头部压缩.详细介绍见后续文章</p>\n"},{"title":"JS类型详论","date":"2023-08-03T06:47:06.000Z","_content":"**本文主旨： 极尽一切可能的，详细介绍js类型相关内容**\n\n### 主要数据类型两类\n- 基本类型： 变量存储值\n数字、布尔、undefined、null、字符串、Symbol\n- 引用类型：变量存储地址，类似于c语言中的指针\n函数、数组、对象\n\n### 判断数据类型\n1. typeof： 能够判断除了null和数组的所有数据类型\n```javascript\nconsole.log(typeof 'a')\nconsole.log(typeof true)\nconsole.log(typeof Symbol())\nconsole.log(typeof undefined)\nconsole.log(typeof null)\nconsole.log(typeof {})\nconsole.log(typeof function() {})\nconsole.log(typeof [])\n// 结果\nstring\nboolean\nsymbol\nundefined\nobject\nobject\nfunction\nobject\n```\n\n2. instanceof: 实话讲，该方法用的并不多，因为他明显没有typeof用的舒服，且他并不是用来做类型判断的。判断一个对象是否为另一个构造函数的实例。那么因为数组既是对象类型也是数组类型，因此，下面代码均会返回true\n```javascript\n    console.log(a instanceof Object)\n    console.log(a instanceof Array)\n```\n\n3. constructor: 判断变量的构造器\n```javascript\nconsole.log('a'.constructor)\nconsole.log(true.constructor)\nconsole.log(Symbol().constructor)\n// console.log(undefined.constructor)\n// console.log(null.constructor)\nconsole.log({}.constructor)\nconsole.log(function() {}.constructor)\nconsole.log([].constructor)\n// 结果\n[Function: String]\n[Function: Boolean]\n[Function: Symbol]\n[Function: Object]\n[Function: Function]\n[Function: Array] //打印出来等同于 Array\n除了undefined和null没有constructor，其他均打印出了各自的原型对象，包括数组。\n```\n4. Object.prototype.toString.call: 该方法最为彻底。能够打印变量的真实原型对象\n```javascript\nconsole.log(Object.prototype.toString.call('123'))\nconsole.log(Object.prototype.toString.call(123))\nconsole.log(Object.prototype.toString.call(true))\nconsole.log(Object.prototype.toString.call(undefined))\nconsole.log(Object.prototype.toString.call(null))\nconsole.log(Object.prototype.toString.call(Symbol(123)))\nconsole.log(Object.prototype.toString.call(function() {}))\nconsole.log(Object.prototype.toString.call([1, 2, 3, 4]))\nconsole.log(Object.prototype.toString.call({}))\n// 结果\n[object String]\n[object Number]\n[object Boolean]\n[object Undefined]\n[object Null]\n[object Symbol]\n[object Function]\n[object Array]\n[object Object]\n```\n**总结**：typeof最为便捷，若要判断数组，可以用constructor、tostring和Array.isArray(item)、instance方法。关于null，可以使用if(typeof x !== undefined && !x)结合判断。\n\n5. 事实上上面我们列举的九种数据类型并不是全部。比如还有类数组（能够像数组哪像通过下标获取值，也有length就是没有数组的那些api），NaN（一种不知道为何存在的值， (NaN === NaN) 输出false）等。同时还有与ts的强类型加持，还有什么any、never等等等。\n\n6. 以为精通了数据类型？来小试牛刀一下：\n```javascript\nlet x = '123'\nconsole.log(x instanceof String)\n```\n猜一猜输出会是啥？\n答案是false。原因我们之前说过，instanceof方法是用来判断一个对象是否为另一个构造函数的实例。那么此处怎么让他输出true呢？很简单：\nlet x = new String('123')\n\n7. js中值为false的情况：\n数字0、false、undefined、null、NaN和空字符串''。注意是空字符串，哪怕多一个空格字符都不行。\n\n8. console.log('3' + 3)的输出是啥？\n'33'。js会默认将数字3转换成字符串。\n\n9. 又觉得自己很懂了？再来看一个例子：\n```javascript\n  // jsone.js\n  import { change } from './jstwo'\n\n  let obj = {\n    name: 'hhvcg'\n  }\n  change(obj)\n  console.log('obj:', obj)\n\n// jstwo.js\n  const change = (obj) => {\n      obj.name = 'chnaged'\n      return 1\n  }\n\n  export { change }\n  // 输出：\n  obj: {name: 'chnaged'}\n```\n有没有被无语到。。。。。。\n\n事实上，通过本文上面的知识，这种情况我们已经能够解释，因为obj是一个对象，可以看成是指针，把这个对象通过参数传递出去，在change中做的改变就是改变的原来的obj，因为不管change定义的参数名是啥，他都是跟obj一样的指针，指向的是同一个数据。\n**但是，我必须说但是，这种骚操作，实在让我暂时无法接受。我想，学过c/c++或者其他主流语言的同学，看到这一幕，可能会一脸懵逼吧。。。这个东西类似于c语言中的指针，但是，也太随便了。**\n\n10. 最后一点补充： 对象的属性值判断方法。\n\nin和hasOwnProperty都可以用来判断一个属性是否在对象中存在但是，前者能够判断自有属性和原型属性，而后者，只专注于自有属性。所以，hasOwnProperty更加的专业。自行测试下面代码。\n```javascript\nconst obj = {\n  name: 'dddd'\n}\nconsole.log(obj.hasOwnProperty('constructor'))\nconsole.log('constructor' in obj)\n```\n\n### js的深拷贝与浅拷贝\n这个话题是因为引用类型触发的。所谓深拷贝，就是完全复制，而浅拷贝，可以理解为一枚硬币的正反两面，无论是正面还是反面，指定对象都是这枚硬币。\n最最简单粗暴的深拷贝：JSON的序列化反序列化大法。","source":"_posts/JS类型详论.md","raw":"---\ntitle: JS类型详论\ncategory: 大前端气宗专栏\ndate: 2023-08-03 14:47:06\ntags:\n---\n**本文主旨： 极尽一切可能的，详细介绍js类型相关内容**\n\n### 主要数据类型两类\n- 基本类型： 变量存储值\n数字、布尔、undefined、null、字符串、Symbol\n- 引用类型：变量存储地址，类似于c语言中的指针\n函数、数组、对象\n\n### 判断数据类型\n1. typeof： 能够判断除了null和数组的所有数据类型\n```javascript\nconsole.log(typeof 'a')\nconsole.log(typeof true)\nconsole.log(typeof Symbol())\nconsole.log(typeof undefined)\nconsole.log(typeof null)\nconsole.log(typeof {})\nconsole.log(typeof function() {})\nconsole.log(typeof [])\n// 结果\nstring\nboolean\nsymbol\nundefined\nobject\nobject\nfunction\nobject\n```\n\n2. instanceof: 实话讲，该方法用的并不多，因为他明显没有typeof用的舒服，且他并不是用来做类型判断的。判断一个对象是否为另一个构造函数的实例。那么因为数组既是对象类型也是数组类型，因此，下面代码均会返回true\n```javascript\n    console.log(a instanceof Object)\n    console.log(a instanceof Array)\n```\n\n3. constructor: 判断变量的构造器\n```javascript\nconsole.log('a'.constructor)\nconsole.log(true.constructor)\nconsole.log(Symbol().constructor)\n// console.log(undefined.constructor)\n// console.log(null.constructor)\nconsole.log({}.constructor)\nconsole.log(function() {}.constructor)\nconsole.log([].constructor)\n// 结果\n[Function: String]\n[Function: Boolean]\n[Function: Symbol]\n[Function: Object]\n[Function: Function]\n[Function: Array] //打印出来等同于 Array\n除了undefined和null没有constructor，其他均打印出了各自的原型对象，包括数组。\n```\n4. Object.prototype.toString.call: 该方法最为彻底。能够打印变量的真实原型对象\n```javascript\nconsole.log(Object.prototype.toString.call('123'))\nconsole.log(Object.prototype.toString.call(123))\nconsole.log(Object.prototype.toString.call(true))\nconsole.log(Object.prototype.toString.call(undefined))\nconsole.log(Object.prototype.toString.call(null))\nconsole.log(Object.prototype.toString.call(Symbol(123)))\nconsole.log(Object.prototype.toString.call(function() {}))\nconsole.log(Object.prototype.toString.call([1, 2, 3, 4]))\nconsole.log(Object.prototype.toString.call({}))\n// 结果\n[object String]\n[object Number]\n[object Boolean]\n[object Undefined]\n[object Null]\n[object Symbol]\n[object Function]\n[object Array]\n[object Object]\n```\n**总结**：typeof最为便捷，若要判断数组，可以用constructor、tostring和Array.isArray(item)、instance方法。关于null，可以使用if(typeof x !== undefined && !x)结合判断。\n\n5. 事实上上面我们列举的九种数据类型并不是全部。比如还有类数组（能够像数组哪像通过下标获取值，也有length就是没有数组的那些api），NaN（一种不知道为何存在的值， (NaN === NaN) 输出false）等。同时还有与ts的强类型加持，还有什么any、never等等等。\n\n6. 以为精通了数据类型？来小试牛刀一下：\n```javascript\nlet x = '123'\nconsole.log(x instanceof String)\n```\n猜一猜输出会是啥？\n答案是false。原因我们之前说过，instanceof方法是用来判断一个对象是否为另一个构造函数的实例。那么此处怎么让他输出true呢？很简单：\nlet x = new String('123')\n\n7. js中值为false的情况：\n数字0、false、undefined、null、NaN和空字符串''。注意是空字符串，哪怕多一个空格字符都不行。\n\n8. console.log('3' + 3)的输出是啥？\n'33'。js会默认将数字3转换成字符串。\n\n9. 又觉得自己很懂了？再来看一个例子：\n```javascript\n  // jsone.js\n  import { change } from './jstwo'\n\n  let obj = {\n    name: 'hhvcg'\n  }\n  change(obj)\n  console.log('obj:', obj)\n\n// jstwo.js\n  const change = (obj) => {\n      obj.name = 'chnaged'\n      return 1\n  }\n\n  export { change }\n  // 输出：\n  obj: {name: 'chnaged'}\n```\n有没有被无语到。。。。。。\n\n事实上，通过本文上面的知识，这种情况我们已经能够解释，因为obj是一个对象，可以看成是指针，把这个对象通过参数传递出去，在change中做的改变就是改变的原来的obj，因为不管change定义的参数名是啥，他都是跟obj一样的指针，指向的是同一个数据。\n**但是，我必须说但是，这种骚操作，实在让我暂时无法接受。我想，学过c/c++或者其他主流语言的同学，看到这一幕，可能会一脸懵逼吧。。。这个东西类似于c语言中的指针，但是，也太随便了。**\n\n10. 最后一点补充： 对象的属性值判断方法。\n\nin和hasOwnProperty都可以用来判断一个属性是否在对象中存在但是，前者能够判断自有属性和原型属性，而后者，只专注于自有属性。所以，hasOwnProperty更加的专业。自行测试下面代码。\n```javascript\nconst obj = {\n  name: 'dddd'\n}\nconsole.log(obj.hasOwnProperty('constructor'))\nconsole.log('constructor' in obj)\n```\n\n### js的深拷贝与浅拷贝\n这个话题是因为引用类型触发的。所谓深拷贝，就是完全复制，而浅拷贝，可以理解为一枚硬币的正反两面，无论是正面还是反面，指定对象都是这枚硬币。\n最最简单粗暴的深拷贝：JSON的序列化反序列化大法。","slug":"JS类型详论","published":1,"updated":"2023-08-21T01:52:54.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxvm0003f8v7eua7bjfb","content":"<p><strong>本文主旨： 极尽一切可能的，详细介绍js类型相关内容</strong></p>\n<h3 id=\"主要数据类型两类\"><a href=\"#主要数据类型两类\" class=\"headerlink\" title=\"主要数据类型两类\"></a>主要数据类型两类</h3><ul>\n<li>基本类型： 变量存储值<br>数字、布尔、undefined、null、字符串、Symbol</li>\n<li>引用类型：变量存储地址，类似于c语言中的指针<br>函数、数组、对象</li>\n</ul>\n<h3 id=\"判断数据类型\"><a href=\"#判断数据类型\" class=\"headerlink\" title=\"判断数据类型\"></a>判断数据类型</h3><ol>\n<li><p>typeof： 能够判断除了null和数组的所有数据类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"string\">&#x27;a&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"literal\">true</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"title class_\">Symbol</span>())</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"literal\">null</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> &#123;&#125;)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;&#125;)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> [])</span><br><span class=\"line\"><span class=\"comment\">// 结果</span></span><br><span class=\"line\">string</span><br><span class=\"line\">boolean</span><br><span class=\"line\">symbol</span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\">object</span><br><span class=\"line\">object</span><br><span class=\"line\"><span class=\"keyword\">function</span></span><br><span class=\"line\">object</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>instanceof: 实话讲，该方法用的并不多，因为他明显没有typeof用的舒服，且他并不是用来做类型判断的。判断一个对象是否为另一个构造函数的实例。那么因为数组既是对象类型也是数组类型，因此，下面代码均会返回true</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Object</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Array</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>constructor: 判断变量的构造器</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;a&#x27;</span>.<span class=\"property\">constructor</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"literal\">true</span>.<span class=\"property\">constructor</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Symbol</span>().<span class=\"property\">constructor</span>)</span><br><span class=\"line\"><span class=\"comment\">// console.log(undefined.constructor)</span></span><br><span class=\"line\"><span class=\"comment\">// console.log(null.constructor)</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(&#123;&#125;.<span class=\"property\">constructor</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;&#125;.<span class=\"property\">constructor</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>([].<span class=\"property\">constructor</span>)</span><br><span class=\"line\"><span class=\"comment\">// 结果</span></span><br><span class=\"line\">[<span class=\"title class_\">Function</span>: <span class=\"title class_\">String</span>]</span><br><span class=\"line\">[<span class=\"title class_\">Function</span>: <span class=\"title class_\">Boolean</span>]</span><br><span class=\"line\">[<span class=\"title class_\">Function</span>: <span class=\"title class_\">Symbol</span>]</span><br><span class=\"line\">[<span class=\"title class_\">Function</span>: <span class=\"title class_\">Object</span>]</span><br><span class=\"line\">[<span class=\"title class_\">Function</span>: <span class=\"title class_\">Function</span>]</span><br><span class=\"line\">[<span class=\"title class_\">Function</span>: <span class=\"title class_\">Array</span>] <span class=\"comment\">//打印出来等同于 Array</span></span><br><span class=\"line\">除了<span class=\"literal\">undefined</span>和<span class=\"literal\">null</span>没有constructor，其他均打印出了各自的原型对象，包括数组。</span><br></pre></td></tr></table></figure></li>\n<li><p>Object.prototype.toString.call: 该方法最为彻底。能够打印变量的真实原型对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">toString</span>.<span class=\"title function_\">call</span>(<span class=\"string\">&#x27;123&#x27;</span>))</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">toString</span>.<span class=\"title function_\">call</span>(<span class=\"number\">123</span>))</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">toString</span>.<span class=\"title function_\">call</span>(<span class=\"literal\">true</span>))</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">toString</span>.<span class=\"title function_\">call</span>(<span class=\"literal\">undefined</span>))</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">toString</span>.<span class=\"title function_\">call</span>(<span class=\"literal\">null</span>))</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">toString</span>.<span class=\"title function_\">call</span>(<span class=\"title class_\">Symbol</span>(<span class=\"number\">123</span>)))</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">toString</span>.<span class=\"title function_\">call</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;&#125;))</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">toString</span>.<span class=\"title function_\">call</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]))</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">toString</span>.<span class=\"title function_\">call</span>(&#123;&#125;))</span><br><span class=\"line\"><span class=\"comment\">// 结果</span></span><br><span class=\"line\">[object <span class=\"title class_\">String</span>]</span><br><span class=\"line\">[object <span class=\"title class_\">Number</span>]</span><br><span class=\"line\">[object <span class=\"title class_\">Boolean</span>]</span><br><span class=\"line\">[object <span class=\"title class_\">Undefined</span>]</span><br><span class=\"line\">[object <span class=\"title class_\">Null</span>]</span><br><span class=\"line\">[object <span class=\"title class_\">Symbol</span>]</span><br><span class=\"line\">[object <span class=\"title class_\">Function</span>]</span><br><span class=\"line\">[object <span class=\"title class_\">Array</span>]</span><br><span class=\"line\">[object <span class=\"title class_\">Object</span>]</span><br></pre></td></tr></table></figure>\n<p><strong>总结</strong>：typeof最为便捷，若要判断数组，可以用constructor、tostring和Array.isArray(item)、instance方法。关于null，可以使用if(typeof x !&#x3D;&#x3D; undefined &amp;&amp; !x)结合判断。</p>\n</li>\n<li><p>事实上上面我们列举的九种数据类型并不是全部。比如还有类数组（能够像数组哪像通过下标获取值，也有length就是没有数组的那些api），NaN（一种不知道为何存在的值， (NaN &#x3D;&#x3D;&#x3D; NaN) 输出false）等。同时还有与ts的强类型加持，还有什么any、never等等等。</p>\n</li>\n<li><p>以为精通了数据类型？来小试牛刀一下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"string\">&#x27;123&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x <span class=\"keyword\">instanceof</span> <span class=\"title class_\">String</span>)</span><br></pre></td></tr></table></figure>\n<p>猜一猜输出会是啥？<br>答案是false。原因我们之前说过，instanceof方法是用来判断一个对象是否为另一个构造函数的实例。那么此处怎么让他输出true呢？很简单：<br>let x &#x3D; new String(‘123’)</p>\n</li>\n<li><p>js中值为false的情况：<br>数字0、false、undefined、null、NaN和空字符串’’。注意是空字符串，哪怕多一个空格字符都不行。</p>\n</li>\n<li><p>console.log(‘3’ + 3)的输出是啥？<br>‘33’。js会默认将数字3转换成字符串。</p>\n</li>\n<li><p>又觉得自己很懂了？再来看一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">// jsone.js</span></span><br><span class=\"line\">  <span class=\"keyword\">import</span> &#123; change &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./jstwo&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;hhvcg&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">change</span>(obj)</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;obj:&#x27;</span>, obj)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// jstwo.js</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">change</span> = (<span class=\"params\">obj</span>) =&gt; &#123;</span><br><span class=\"line\">      obj.<span class=\"property\">name</span> = <span class=\"string\">&#x27;chnaged&#x27;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">export</span> &#123; change &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 输出：</span></span><br><span class=\"line\">  <span class=\"attr\">obj</span>: &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;chnaged&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>有没有被无语到。。。。。。</p>\n</li>\n</ol>\n<p>事实上，通过本文上面的知识，这种情况我们已经能够解释，因为obj是一个对象，可以看成是指针，把这个对象通过参数传递出去，在change中做的改变就是改变的原来的obj，因为不管change定义的参数名是啥，他都是跟obj一样的指针，指向的是同一个数据。<br><strong>但是，我必须说但是，这种骚操作，实在让我暂时无法接受。我想，学过c&#x2F;c++或者其他主流语言的同学，看到这一幕，可能会一脸懵逼吧。。。这个东西类似于c语言中的指针，但是，也太随便了。</strong></p>\n<ol start=\"10\">\n<li>最后一点补充： 对象的属性值判断方法。</li>\n</ol>\n<p>in和hasOwnProperty都可以用来判断一个属性是否在对象中存在但是，前者能够判断自有属性和原型属性，而后者，只专注于自有属性。所以，hasOwnProperty更加的专业。自行测试下面代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;dddd&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"title function_\">hasOwnProperty</span>(<span class=\"string\">&#x27;constructor&#x27;</span>))</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;constructor&#x27;</span> <span class=\"keyword\">in</span> obj)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"js的深拷贝与浅拷贝\"><a href=\"#js的深拷贝与浅拷贝\" class=\"headerlink\" title=\"js的深拷贝与浅拷贝\"></a>js的深拷贝与浅拷贝</h3><p>这个话题是因为引用类型触发的。所谓深拷贝，就是完全复制，而浅拷贝，可以理解为一枚硬币的正反两面，无论是正面还是反面，指定对象都是这枚硬币。<br>最最简单粗暴的深拷贝：JSON的序列化反序列化大法。</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p><strong>本文主旨： 极尽一切可能的，详细介绍js类型相关内容</strong></p>\n<h3 id=\"主要数据类型两类\"><a href=\"#主要数据类型两类\" class=\"headerlink\" title=\"主要数据类型两类\"></a>主要数据类型两类</h3><ul>\n<li>基本类型： 变量存储值<br>数字、布尔、undefined、null、字符串、Symbol</li>\n<li>引用类型：变量存储地址，类似于c语言中的指针<br>函数、数组、对象</li>\n</ul>\n<h3 id=\"判断数据类型\"><a href=\"#判断数据类型\" class=\"headerlink\" title=\"判断数据类型\"></a>判断数据类型</h3><ol>\n<li><p>typeof： 能够判断除了null和数组的所有数据类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"string\">&#x27;a&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"literal\">true</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"title class_\">Symbol</span>())</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"literal\">null</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> &#123;&#125;)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;&#125;)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> [])</span><br><span class=\"line\"><span class=\"comment\">// 结果</span></span><br><span class=\"line\">string</span><br><span class=\"line\">boolean</span><br><span class=\"line\">symbol</span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\">object</span><br><span class=\"line\">object</span><br><span class=\"line\"><span class=\"keyword\">function</span></span><br><span class=\"line\">object</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>instanceof: 实话讲，该方法用的并不多，因为他明显没有typeof用的舒服，且他并不是用来做类型判断的。判断一个对象是否为另一个构造函数的实例。那么因为数组既是对象类型也是数组类型，因此，下面代码均会返回true</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Object</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Array</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>constructor: 判断变量的构造器</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;a&#x27;</span>.<span class=\"property\">constructor</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"literal\">true</span>.<span class=\"property\">constructor</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Symbol</span>().<span class=\"property\">constructor</span>)</span><br><span class=\"line\"><span class=\"comment\">// console.log(undefined.constructor)</span></span><br><span class=\"line\"><span class=\"comment\">// console.log(null.constructor)</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(&#123;&#125;.<span class=\"property\">constructor</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;&#125;.<span class=\"property\">constructor</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>([].<span class=\"property\">constructor</span>)</span><br><span class=\"line\"><span class=\"comment\">// 结果</span></span><br><span class=\"line\">[<span class=\"title class_\">Function</span>: <span class=\"title class_\">String</span>]</span><br><span class=\"line\">[<span class=\"title class_\">Function</span>: <span class=\"title class_\">Boolean</span>]</span><br><span class=\"line\">[<span class=\"title class_\">Function</span>: <span class=\"title class_\">Symbol</span>]</span><br><span class=\"line\">[<span class=\"title class_\">Function</span>: <span class=\"title class_\">Object</span>]</span><br><span class=\"line\">[<span class=\"title class_\">Function</span>: <span class=\"title class_\">Function</span>]</span><br><span class=\"line\">[<span class=\"title class_\">Function</span>: <span class=\"title class_\">Array</span>] <span class=\"comment\">//打印出来等同于 Array</span></span><br><span class=\"line\">除了<span class=\"literal\">undefined</span>和<span class=\"literal\">null</span>没有constructor，其他均打印出了各自的原型对象，包括数组。</span><br></pre></td></tr></table></figure></li>\n<li><p>Object.prototype.toString.call: 该方法最为彻底。能够打印变量的真实原型对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">toString</span>.<span class=\"title function_\">call</span>(<span class=\"string\">&#x27;123&#x27;</span>))</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">toString</span>.<span class=\"title function_\">call</span>(<span class=\"number\">123</span>))</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">toString</span>.<span class=\"title function_\">call</span>(<span class=\"literal\">true</span>))</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">toString</span>.<span class=\"title function_\">call</span>(<span class=\"literal\">undefined</span>))</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">toString</span>.<span class=\"title function_\">call</span>(<span class=\"literal\">null</span>))</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">toString</span>.<span class=\"title function_\">call</span>(<span class=\"title class_\">Symbol</span>(<span class=\"number\">123</span>)))</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">toString</span>.<span class=\"title function_\">call</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;&#125;))</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">toString</span>.<span class=\"title function_\">call</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]))</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">toString</span>.<span class=\"title function_\">call</span>(&#123;&#125;))</span><br><span class=\"line\"><span class=\"comment\">// 结果</span></span><br><span class=\"line\">[object <span class=\"title class_\">String</span>]</span><br><span class=\"line\">[object <span class=\"title class_\">Number</span>]</span><br><span class=\"line\">[object <span class=\"title class_\">Boolean</span>]</span><br><span class=\"line\">[object <span class=\"title class_\">Undefined</span>]</span><br><span class=\"line\">[object <span class=\"title class_\">Null</span>]</span><br><span class=\"line\">[object <span class=\"title class_\">Symbol</span>]</span><br><span class=\"line\">[object <span class=\"title class_\">Function</span>]</span><br><span class=\"line\">[object <span class=\"title class_\">Array</span>]</span><br><span class=\"line\">[object <span class=\"title class_\">Object</span>]</span><br></pre></td></tr></table></figure>\n<p><strong>总结</strong>：typeof最为便捷，若要判断数组，可以用constructor、tostring和Array.isArray(item)、instance方法。关于null，可以使用if(typeof x !&#x3D;&#x3D; undefined &amp;&amp; !x)结合判断。</p>\n</li>\n<li><p>事实上上面我们列举的九种数据类型并不是全部。比如还有类数组（能够像数组哪像通过下标获取值，也有length就是没有数组的那些api），NaN（一种不知道为何存在的值， (NaN &#x3D;&#x3D;&#x3D; NaN) 输出false）等。同时还有与ts的强类型加持，还有什么any、never等等等。</p>\n</li>\n<li><p>以为精通了数据类型？来小试牛刀一下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"string\">&#x27;123&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x <span class=\"keyword\">instanceof</span> <span class=\"title class_\">String</span>)</span><br></pre></td></tr></table></figure>\n<p>猜一猜输出会是啥？<br>答案是false。原因我们之前说过，instanceof方法是用来判断一个对象是否为另一个构造函数的实例。那么此处怎么让他输出true呢？很简单：<br>let x &#x3D; new String(‘123’)</p>\n</li>\n<li><p>js中值为false的情况：<br>数字0、false、undefined、null、NaN和空字符串’’。注意是空字符串，哪怕多一个空格字符都不行。</p>\n</li>\n<li><p>console.log(‘3’ + 3)的输出是啥？<br>‘33’。js会默认将数字3转换成字符串。</p>\n</li>\n<li><p>又觉得自己很懂了？再来看一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">// jsone.js</span></span><br><span class=\"line\">  <span class=\"keyword\">import</span> &#123; change &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./jstwo&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;hhvcg&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">change</span>(obj)</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;obj:&#x27;</span>, obj)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// jstwo.js</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">change</span> = (<span class=\"params\">obj</span>) =&gt; &#123;</span><br><span class=\"line\">      obj.<span class=\"property\">name</span> = <span class=\"string\">&#x27;chnaged&#x27;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">export</span> &#123; change &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 输出：</span></span><br><span class=\"line\">  <span class=\"attr\">obj</span>: &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;chnaged&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>有没有被无语到。。。。。。</p>\n</li>\n</ol>\n<p>事实上，通过本文上面的知识，这种情况我们已经能够解释，因为obj是一个对象，可以看成是指针，把这个对象通过参数传递出去，在change中做的改变就是改变的原来的obj，因为不管change定义的参数名是啥，他都是跟obj一样的指针，指向的是同一个数据。<br><strong>但是，我必须说但是，这种骚操作，实在让我暂时无法接受。我想，学过c&#x2F;c++或者其他主流语言的同学，看到这一幕，可能会一脸懵逼吧。。。这个东西类似于c语言中的指针，但是，也太随便了。</strong></p>\n<ol start=\"10\">\n<li>最后一点补充： 对象的属性值判断方法。</li>\n</ol>\n<p>in和hasOwnProperty都可以用来判断一个属性是否在对象中存在但是，前者能够判断自有属性和原型属性，而后者，只专注于自有属性。所以，hasOwnProperty更加的专业。自行测试下面代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;dddd&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"title function_\">hasOwnProperty</span>(<span class=\"string\">&#x27;constructor&#x27;</span>))</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;constructor&#x27;</span> <span class=\"keyword\">in</span> obj)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"js的深拷贝与浅拷贝\"><a href=\"#js的深拷贝与浅拷贝\" class=\"headerlink\" title=\"js的深拷贝与浅拷贝\"></a>js的深拷贝与浅拷贝</h3><p>这个话题是因为引用类型触发的。所谓深拷贝，就是完全复制，而浅拷贝，可以理解为一枚硬币的正反两面，无论是正面还是反面，指定对象都是这枚硬币。<br>最最简单粗暴的深拷贝：JSON的序列化反序列化大法。</p>\n"},{"title":"HTTP版本演进：第三回","date":"2023-08-02T16:12:56.000Z","_content":"\n**本文的目的，就是要填前文留下的坑。**为了更加充分的使用c端和s端的效率，解决队首阻塞。两个方案：并行tcp链接，以及http2.0版本的多路复用。\n\n### 并行tcp链接\n这个方法简单粗暴。1.1版本的http协议不是严格执行串行传输嘛，那好，我们就多开几个tcp链接。同时s端开启多线程并行处理响应。目前主流的浏览器厂商都默认最大支持6条线路。至于为什么是6，而不是更大的数值，权衡的结果。这种方法，能在一定程度上，实现优化的效果，但是治标不治本，对于并行的每条链路而言，依然存在队首阻塞的问题。\n\n### HTTP的2.0\n该协议重大改进之一，就是实现了多路复用，摒弃了之前的串行传输。c端通过并行tcp链接最大并行六个请求同时发送。s端能在处理完成之后无需等待直接返回响应（在一个链路上）。\n\n那么。2.0版本的多路复用是如何实现的呢？**二进制分帧。**\n\n#### 二进制分帧\n如下图所示：\n<img src=\"/img/http6.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\">\n\n2.0版本的数据传输如下图所示，所有的数据传输都是基于一个TCP链接。一个完整的请求响应称为一个流，流又有请求消息和响应消息组成，而具体的消息就是帧。这样的解释更多的是逻辑上的理解。本质就是数据被二进制分帧，乱序发送与组装，解决队首阻塞问题。\n<img src=\"/img/http7.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\">\n\nhttp2.0版本的其他改进：\n\n#### 请求优先级。\n前端会发送很多请求，但并不是每个请求都同等重要。每个流都会带一个31比特的优先级值，0---2的31次方-1，从高到低。s端在准备好返回的数据时，会根据这个来决定返回顺序。\n\n#### 头部压缩。简言之就是减少重复的头部信息，加快响应速度。\n以前一直把这个同后端的gzip压缩搞混了，两者事实上是两码事。头部压缩指的是响应头和请求头，也就是header。如下图所示：\n\n<img src=\"/img/http8.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\">\n在2.0版本的机制中，c端和s端会维护自己的首部表来跟踪和存储之前发送的header中的键值对，对于相同的键值对，不会再发送。如上图所示，两个请求对比一下发现，除了请求路径不同，其他都没区别，因此发送的header帧中的信息，只有path字段及其对应的值。\n\n#### s端的“主动推送”\n2.0之前的版本中，c端和s端的请求响应是一对一的关系，即：一个请求，对应一个响应。我们知道一个站点通常有很多资源构成，所以理所当然的想法，为什么不让s端主动推送一些可能是c端必须的资源而不是每次都等他发送请求呢？2.0针对这点做了改进。依然依附于请求-响应的循环，但是不是一对一，而是一对多，即：一个请求对应多个响应。那么具体是怎么实现的？是怎么个逻辑?\ns端在发送响应之前，会主动发送一个PUSH_PROMISE帧信息，包含了s端想要主动推送的资源header，c端在收到这个帧信息后可以做取舍的决定，返回对应信息，最后由s端发送可能的多个响应。\n在1.x版本中，我们其实可以通过内嵌地址的方式，让后段“主动”推送响应资源，但是这种推送响应更多的是“强制性”的，前端无法进行取舍。对了，顺带提一个首部字段X-Associated-Content 。如果后端是Apache搭建的话，就可以通过这个字段识别出前端希望主动推送的资源。\n注意，一对多，有“一”才有后面的“多”，就是说，s端是不能在没有请求的情况下，向前端push资源的。还有一点是，2.0版本所做的改动，具体是由浏览器和服务器处理的，前端基本当着1.1版本用就行了。\n\n**总结一下就是**：多路复用（取代并行TCP，解决队首堵塞问题），头部压缩（降低时间开销），s端的主动推送。当然还有一个很重要的点，二进制分帧层（核心）。2.0版本关注的重点，是如何让数据高效的在c端和s端进行传输，减小一切可能的延迟。\n\n最后提一句：偶然间发现，chrome浏览器貌似都不显示http版本号了，火狐可以。且目前，2.0版本已经得到了普及。\n\n插个题外话：**SPDY**。\n这个东西可以看成http2.0的前身。因为现在的http所加持的能力，几乎都是出自于他。","source":"_posts/HTTP版本演进：第三回.md","raw":"---\ntitle: HTTP版本演进：第三回\ncategory: 网络杂谈\ndate: 2023-08-03 00:12:56\ntags:\n---\n\n**本文的目的，就是要填前文留下的坑。**为了更加充分的使用c端和s端的效率，解决队首阻塞。两个方案：并行tcp链接，以及http2.0版本的多路复用。\n\n### 并行tcp链接\n这个方法简单粗暴。1.1版本的http协议不是严格执行串行传输嘛，那好，我们就多开几个tcp链接。同时s端开启多线程并行处理响应。目前主流的浏览器厂商都默认最大支持6条线路。至于为什么是6，而不是更大的数值，权衡的结果。这种方法，能在一定程度上，实现优化的效果，但是治标不治本，对于并行的每条链路而言，依然存在队首阻塞的问题。\n\n### HTTP的2.0\n该协议重大改进之一，就是实现了多路复用，摒弃了之前的串行传输。c端通过并行tcp链接最大并行六个请求同时发送。s端能在处理完成之后无需等待直接返回响应（在一个链路上）。\n\n那么。2.0版本的多路复用是如何实现的呢？**二进制分帧。**\n\n#### 二进制分帧\n如下图所示：\n<img src=\"/img/http6.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\">\n\n2.0版本的数据传输如下图所示，所有的数据传输都是基于一个TCP链接。一个完整的请求响应称为一个流，流又有请求消息和响应消息组成，而具体的消息就是帧。这样的解释更多的是逻辑上的理解。本质就是数据被二进制分帧，乱序发送与组装，解决队首阻塞问题。\n<img src=\"/img/http7.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\">\n\nhttp2.0版本的其他改进：\n\n#### 请求优先级。\n前端会发送很多请求，但并不是每个请求都同等重要。每个流都会带一个31比特的优先级值，0---2的31次方-1，从高到低。s端在准备好返回的数据时，会根据这个来决定返回顺序。\n\n#### 头部压缩。简言之就是减少重复的头部信息，加快响应速度。\n以前一直把这个同后端的gzip压缩搞混了，两者事实上是两码事。头部压缩指的是响应头和请求头，也就是header。如下图所示：\n\n<img src=\"/img/http8.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\">\n在2.0版本的机制中，c端和s端会维护自己的首部表来跟踪和存储之前发送的header中的键值对，对于相同的键值对，不会再发送。如上图所示，两个请求对比一下发现，除了请求路径不同，其他都没区别，因此发送的header帧中的信息，只有path字段及其对应的值。\n\n#### s端的“主动推送”\n2.0之前的版本中，c端和s端的请求响应是一对一的关系，即：一个请求，对应一个响应。我们知道一个站点通常有很多资源构成，所以理所当然的想法，为什么不让s端主动推送一些可能是c端必须的资源而不是每次都等他发送请求呢？2.0针对这点做了改进。依然依附于请求-响应的循环，但是不是一对一，而是一对多，即：一个请求对应多个响应。那么具体是怎么实现的？是怎么个逻辑?\ns端在发送响应之前，会主动发送一个PUSH_PROMISE帧信息，包含了s端想要主动推送的资源header，c端在收到这个帧信息后可以做取舍的决定，返回对应信息，最后由s端发送可能的多个响应。\n在1.x版本中，我们其实可以通过内嵌地址的方式，让后段“主动”推送响应资源，但是这种推送响应更多的是“强制性”的，前端无法进行取舍。对了，顺带提一个首部字段X-Associated-Content 。如果后端是Apache搭建的话，就可以通过这个字段识别出前端希望主动推送的资源。\n注意，一对多，有“一”才有后面的“多”，就是说，s端是不能在没有请求的情况下，向前端push资源的。还有一点是，2.0版本所做的改动，具体是由浏览器和服务器处理的，前端基本当着1.1版本用就行了。\n\n**总结一下就是**：多路复用（取代并行TCP，解决队首堵塞问题），头部压缩（降低时间开销），s端的主动推送。当然还有一个很重要的点，二进制分帧层（核心）。2.0版本关注的重点，是如何让数据高效的在c端和s端进行传输，减小一切可能的延迟。\n\n最后提一句：偶然间发现，chrome浏览器貌似都不显示http版本号了，火狐可以。且目前，2.0版本已经得到了普及。\n\n插个题外话：**SPDY**。\n这个东西可以看成http2.0的前身。因为现在的http所加持的能力，几乎都是出自于他。","slug":"HTTP版本演进：第三回","published":1,"updated":"2023-08-21T01:52:54.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxvn0004f8v77jpb6xvl","content":"<p><strong>本文的目的，就是要填前文留下的坑。</strong>为了更加充分的使用c端和s端的效率，解决队首阻塞。两个方案：并行tcp链接，以及http2.0版本的多路复用。</p>\n<h3 id=\"并行tcp链接\"><a href=\"#并行tcp链接\" class=\"headerlink\" title=\"并行tcp链接\"></a>并行tcp链接</h3><p>这个方法简单粗暴。1.1版本的http协议不是严格执行串行传输嘛，那好，我们就多开几个tcp链接。同时s端开启多线程并行处理响应。目前主流的浏览器厂商都默认最大支持6条线路。至于为什么是6，而不是更大的数值，权衡的结果。这种方法，能在一定程度上，实现优化的效果，但是治标不治本，对于并行的每条链路而言，依然存在队首阻塞的问题。</p>\n<h3 id=\"HTTP的2-0\"><a href=\"#HTTP的2-0\" class=\"headerlink\" title=\"HTTP的2.0\"></a>HTTP的2.0</h3><p>该协议重大改进之一，就是实现了多路复用，摒弃了之前的串行传输。c端通过并行tcp链接最大并行六个请求同时发送。s端能在处理完成之后无需等待直接返回响应（在一个链路上）。</p>\n<p>那么。2.0版本的多路复用是如何实现的呢？<strong>二进制分帧。</strong></p>\n<h4 id=\"二进制分帧\"><a href=\"#二进制分帧\" class=\"headerlink\" title=\"二进制分帧\"></a>二进制分帧</h4><p>如下图所示：<br><img src=\"/img/http6.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\"></p>\n<p>2.0版本的数据传输如下图所示，所有的数据传输都是基于一个TCP链接。一个完整的请求响应称为一个流，流又有请求消息和响应消息组成，而具体的消息就是帧。这样的解释更多的是逻辑上的理解。本质就是数据被二进制分帧，乱序发送与组装，解决队首阻塞问题。<br><img src=\"/img/http7.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\"></p>\n<p>http2.0版本的其他改进：</p>\n<h4 id=\"请求优先级。\"><a href=\"#请求优先级。\" class=\"headerlink\" title=\"请求优先级。\"></a>请求优先级。</h4><p>前端会发送很多请求，但并不是每个请求都同等重要。每个流都会带一个31比特的优先级值，0—2的31次方-1，从高到低。s端在准备好返回的数据时，会根据这个来决定返回顺序。</p>\n<h4 id=\"头部压缩。简言之就是减少重复的头部信息，加快响应速度。\"><a href=\"#头部压缩。简言之就是减少重复的头部信息，加快响应速度。\" class=\"headerlink\" title=\"头部压缩。简言之就是减少重复的头部信息，加快响应速度。\"></a>头部压缩。简言之就是减少重复的头部信息，加快响应速度。</h4><p>以前一直把这个同后端的gzip压缩搞混了，两者事实上是两码事。头部压缩指的是响应头和请求头，也就是header。如下图所示：</p>\n<img src=\"/img/http8.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\">\n在2.0版本的机制中，c端和s端会维护自己的首部表来跟踪和存储之前发送的header中的键值对，对于相同的键值对，不会再发送。如上图所示，两个请求对比一下发现，除了请求路径不同，其他都没区别，因此发送的header帧中的信息，只有path字段及其对应的值。\n\n<h4 id=\"s端的“主动推送”\"><a href=\"#s端的“主动推送”\" class=\"headerlink\" title=\"s端的“主动推送”\"></a>s端的“主动推送”</h4><p>2.0之前的版本中，c端和s端的请求响应是一对一的关系，即：一个请求，对应一个响应。我们知道一个站点通常有很多资源构成，所以理所当然的想法，为什么不让s端主动推送一些可能是c端必须的资源而不是每次都等他发送请求呢？2.0针对这点做了改进。依然依附于请求-响应的循环，但是不是一对一，而是一对多，即：一个请求对应多个响应。那么具体是怎么实现的？是怎么个逻辑?<br>s端在发送响应之前，会主动发送一个PUSH_PROMISE帧信息，包含了s端想要主动推送的资源header，c端在收到这个帧信息后可以做取舍的决定，返回对应信息，最后由s端发送可能的多个响应。<br>在1.x版本中，我们其实可以通过内嵌地址的方式，让后段“主动”推送响应资源，但是这种推送响应更多的是“强制性”的，前端无法进行取舍。对了，顺带提一个首部字段X-Associated-Content 。如果后端是Apache搭建的话，就可以通过这个字段识别出前端希望主动推送的资源。<br>注意，一对多，有“一”才有后面的“多”，就是说，s端是不能在没有请求的情况下，向前端push资源的。还有一点是，2.0版本所做的改动，具体是由浏览器和服务器处理的，前端基本当着1.1版本用就行了。</p>\n<p><strong>总结一下就是</strong>：多路复用（取代并行TCP，解决队首堵塞问题），头部压缩（降低时间开销），s端的主动推送。当然还有一个很重要的点，二进制分帧层（核心）。2.0版本关注的重点，是如何让数据高效的在c端和s端进行传输，减小一切可能的延迟。</p>\n<p>最后提一句：偶然间发现，chrome浏览器貌似都不显示http版本号了，火狐可以。且目前，2.0版本已经得到了普及。</p>\n<p>插个题外话：<strong>SPDY</strong>。<br>这个东西可以看成http2.0的前身。因为现在的http所加持的能力，几乎都是出自于他。</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p><strong>本文的目的，就是要填前文留下的坑。</strong>为了更加充分的使用c端和s端的效率，解决队首阻塞。两个方案：并行tcp链接，以及http2.0版本的多路复用。</p>\n<h3 id=\"并行tcp链接\"><a href=\"#并行tcp链接\" class=\"headerlink\" title=\"并行tcp链接\"></a>并行tcp链接</h3><p>这个方法简单粗暴。1.1版本的http协议不是严格执行串行传输嘛，那好，我们就多开几个tcp链接。同时s端开启多线程并行处理响应。目前主流的浏览器厂商都默认最大支持6条线路。至于为什么是6，而不是更大的数值，权衡的结果。这种方法，能在一定程度上，实现优化的效果，但是治标不治本，对于并行的每条链路而言，依然存在队首阻塞的问题。</p>\n<h3 id=\"HTTP的2-0\"><a href=\"#HTTP的2-0\" class=\"headerlink\" title=\"HTTP的2.0\"></a>HTTP的2.0</h3><p>该协议重大改进之一，就是实现了多路复用，摒弃了之前的串行传输。c端通过并行tcp链接最大并行六个请求同时发送。s端能在处理完成之后无需等待直接返回响应（在一个链路上）。</p>\n<p>那么。2.0版本的多路复用是如何实现的呢？<strong>二进制分帧。</strong></p>\n<h4 id=\"二进制分帧\"><a href=\"#二进制分帧\" class=\"headerlink\" title=\"二进制分帧\"></a>二进制分帧</h4><p>如下图所示：<br><img src=\"/img/http6.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\"></p>\n<p>2.0版本的数据传输如下图所示，所有的数据传输都是基于一个TCP链接。一个完整的请求响应称为一个流，流又有请求消息和响应消息组成，而具体的消息就是帧。这样的解释更多的是逻辑上的理解。本质就是数据被二进制分帧，乱序发送与组装，解决队首阻塞问题。<br><img src=\"/img/http7.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\"></p>\n<p>http2.0版本的其他改进：</p>\n<h4 id=\"请求优先级。\"><a href=\"#请求优先级。\" class=\"headerlink\" title=\"请求优先级。\"></a>请求优先级。</h4><p>前端会发送很多请求，但并不是每个请求都同等重要。每个流都会带一个31比特的优先级值，0—2的31次方-1，从高到低。s端在准备好返回的数据时，会根据这个来决定返回顺序。</p>\n<h4 id=\"头部压缩。简言之就是减少重复的头部信息，加快响应速度。\"><a href=\"#头部压缩。简言之就是减少重复的头部信息，加快响应速度。\" class=\"headerlink\" title=\"头部压缩。简言之就是减少重复的头部信息，加快响应速度。\"></a>头部压缩。简言之就是减少重复的头部信息，加快响应速度。</h4><p>以前一直把这个同后端的gzip压缩搞混了，两者事实上是两码事。头部压缩指的是响应头和请求头，也就是header。如下图所示：</p>\n<img src=\"/img/http8.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\">\n在2.0版本的机制中，c端和s端会维护自己的首部表来跟踪和存储之前发送的header中的键值对，对于相同的键值对，不会再发送。如上图所示，两个请求对比一下发现，除了请求路径不同，其他都没区别，因此发送的header帧中的信息，只有path字段及其对应的值。\n\n<h4 id=\"s端的“主动推送”\"><a href=\"#s端的“主动推送”\" class=\"headerlink\" title=\"s端的“主动推送”\"></a>s端的“主动推送”</h4><p>2.0之前的版本中，c端和s端的请求响应是一对一的关系，即：一个请求，对应一个响应。我们知道一个站点通常有很多资源构成，所以理所当然的想法，为什么不让s端主动推送一些可能是c端必须的资源而不是每次都等他发送请求呢？2.0针对这点做了改进。依然依附于请求-响应的循环，但是不是一对一，而是一对多，即：一个请求对应多个响应。那么具体是怎么实现的？是怎么个逻辑?<br>s端在发送响应之前，会主动发送一个PUSH_PROMISE帧信息，包含了s端想要主动推送的资源header，c端在收到这个帧信息后可以做取舍的决定，返回对应信息，最后由s端发送可能的多个响应。<br>在1.x版本中，我们其实可以通过内嵌地址的方式，让后段“主动”推送响应资源，但是这种推送响应更多的是“强制性”的，前端无法进行取舍。对了，顺带提一个首部字段X-Associated-Content 。如果后端是Apache搭建的话，就可以通过这个字段识别出前端希望主动推送的资源。<br>注意，一对多，有“一”才有后面的“多”，就是说，s端是不能在没有请求的情况下，向前端push资源的。还有一点是，2.0版本所做的改动，具体是由浏览器和服务器处理的，前端基本当着1.1版本用就行了。</p>\n<p><strong>总结一下就是</strong>：多路复用（取代并行TCP，解决队首堵塞问题），头部压缩（降低时间开销），s端的主动推送。当然还有一个很重要的点，二进制分帧层（核心）。2.0版本关注的重点，是如何让数据高效的在c端和s端进行传输，减小一切可能的延迟。</p>\n<p>最后提一句：偶然间发现，chrome浏览器貌似都不显示http版本号了，火狐可以。且目前，2.0版本已经得到了普及。</p>\n<p>插个题外话：<strong>SPDY</strong>。<br>这个东西可以看成http2.0的前身。因为现在的http所加持的能力，几乎都是出自于他。</p>\n"},{"title":"HTTP版本演进：第二回","date":"2023-08-02T15:31:45.000Z","_content":"**续前文，本文将详细的介绍一下1.x版本的特性，主要就是1.1啦。**\n\n## 1.x版本的三个特点：\n- 长连接\n- 管道化\n- 串行传输\n\n#### 长连接\n1.0版本遵循的规则是：建立链路--发送请求--接收响应--断开链路。对于每一个请求而言，1.5个rtt（往返时延）是必须的。假使我们现在有n个请求，那么固定的时耗就是1.5 * n。那么1.1的重大改进，就是利用长连接，实现了多个请求共用一个TCP连接通道。这样除了第一个请求外，对于后面的每个请求，都能省去用于建立链路的1个rtt耗时，即：我们能够节省（n-1）次的rtt（往返时延）。这就是长连接带来的好处。\n\n插个题外话：我们知道，c端在发送资源请求之前，需要通过三次握手建立连接链路，时间损耗，就用掉了1.5个往返，这里有个细节我之前一直没在意。就是发送资源请求的时间点与建立连接的那最后0.5的往返时刻是同时发生的，可以理解为，1.5的往返耗时，包含了请求时间，见下图：\n<img src=\"/img/http3.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\">\n\n同时，通过上图，也能看出，为什么1.1版本的改进影响巨大。著名案例就是苹果的工程师们针对itunes的改进，有兴趣自行谷歌。\n\n但是，通过长连接虽然实现了公用tcp链路，我们发现了新的问题，因为规则，仍然是第二个请求必须等待第一个请求的响应返回之后，才能发出。如此一来，当s端返回第一个请求的响应后直到第二个请求到达前的这段时间，都是处于空闲状态。这就叫c端的响应阻塞。我们希望的是，s端能够在处理完第一个请求发出响应后，立刻开始处理第二个请求，甚至，可以并行处理多个请求，怎么破？具体实践方法：管道化。\n\n#### 管道化。\n1.1版本之前，每次请求都需要等待上次请求的响应返回才能发出，1.1版本开始实现了无需等待，对于c端的改动，就是无需等待串行发送请求，到达s端就是一个队列，s端能够挨个取出请求发出响应或者开启多线程并行处理，直至队列空。这样，能够一定程度上的充分利用s端的处理能力。这就是管道化。\n\n<img src=\"/img/http4.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\">\n共用一个tcp链路的情况下，c端先后发送html和css的请求。从图中发现，当s端返回html请求的响应后，一直处于空闲状态，直到css请求到达才开始处理。\n\n<img src=\"/img/http5.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\">\n**使用了管道化，c端串行发出请求，s端并行处理请求串行返回。理论上讲，通过长连接节省（n-1）个rtt基础上，再次节省了（n-1）个rtt。**\n\n但是，由于http1.x协议本身的局限性，严格规定执行串行传输的策略，串型传输就是先进先出，对c端而言，请求必须依次发出。对s端而言即使后到的请求率先处理完成，也得等待。他不允许一个连接上的多个响应交错到达（多路复用）。这就导致了一个问题：倘若c端并行发送了两个请求：一个请求html，另一个请求了css。s端也能够并行的处理请求，css文件20ms完成，html40ms完成，那么在css完成的时候，她不能直接返回，而是要再等待20ms，即html请求处理完成后，再吧css的响应发出。这就叫队首阻塞。\n\n怎么破？\n\n- 并行tcp发送请求。\n- http2.0多路复用。\n后文详解，敬请期待。","source":"_posts/HTTP版本演进：第二回.md","raw":"---\ntitle: HTTP版本演进：第二回\ncategory: 网络杂谈\ndate: 2023-08-02 23:31:45\ntags:\n---\n**续前文，本文将详细的介绍一下1.x版本的特性，主要就是1.1啦。**\n\n## 1.x版本的三个特点：\n- 长连接\n- 管道化\n- 串行传输\n\n#### 长连接\n1.0版本遵循的规则是：建立链路--发送请求--接收响应--断开链路。对于每一个请求而言，1.5个rtt（往返时延）是必须的。假使我们现在有n个请求，那么固定的时耗就是1.5 * n。那么1.1的重大改进，就是利用长连接，实现了多个请求共用一个TCP连接通道。这样除了第一个请求外，对于后面的每个请求，都能省去用于建立链路的1个rtt耗时，即：我们能够节省（n-1）次的rtt（往返时延）。这就是长连接带来的好处。\n\n插个题外话：我们知道，c端在发送资源请求之前，需要通过三次握手建立连接链路，时间损耗，就用掉了1.5个往返，这里有个细节我之前一直没在意。就是发送资源请求的时间点与建立连接的那最后0.5的往返时刻是同时发生的，可以理解为，1.5的往返耗时，包含了请求时间，见下图：\n<img src=\"/img/http3.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\">\n\n同时，通过上图，也能看出，为什么1.1版本的改进影响巨大。著名案例就是苹果的工程师们针对itunes的改进，有兴趣自行谷歌。\n\n但是，通过长连接虽然实现了公用tcp链路，我们发现了新的问题，因为规则，仍然是第二个请求必须等待第一个请求的响应返回之后，才能发出。如此一来，当s端返回第一个请求的响应后直到第二个请求到达前的这段时间，都是处于空闲状态。这就叫c端的响应阻塞。我们希望的是，s端能够在处理完第一个请求发出响应后，立刻开始处理第二个请求，甚至，可以并行处理多个请求，怎么破？具体实践方法：管道化。\n\n#### 管道化。\n1.1版本之前，每次请求都需要等待上次请求的响应返回才能发出，1.1版本开始实现了无需等待，对于c端的改动，就是无需等待串行发送请求，到达s端就是一个队列，s端能够挨个取出请求发出响应或者开启多线程并行处理，直至队列空。这样，能够一定程度上的充分利用s端的处理能力。这就是管道化。\n\n<img src=\"/img/http4.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\">\n共用一个tcp链路的情况下，c端先后发送html和css的请求。从图中发现，当s端返回html请求的响应后，一直处于空闲状态，直到css请求到达才开始处理。\n\n<img src=\"/img/http5.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\">\n**使用了管道化，c端串行发出请求，s端并行处理请求串行返回。理论上讲，通过长连接节省（n-1）个rtt基础上，再次节省了（n-1）个rtt。**\n\n但是，由于http1.x协议本身的局限性，严格规定执行串行传输的策略，串型传输就是先进先出，对c端而言，请求必须依次发出。对s端而言即使后到的请求率先处理完成，也得等待。他不允许一个连接上的多个响应交错到达（多路复用）。这就导致了一个问题：倘若c端并行发送了两个请求：一个请求html，另一个请求了css。s端也能够并行的处理请求，css文件20ms完成，html40ms完成，那么在css完成的时候，她不能直接返回，而是要再等待20ms，即html请求处理完成后，再吧css的响应发出。这就叫队首阻塞。\n\n怎么破？\n\n- 并行tcp发送请求。\n- http2.0多路复用。\n后文详解，敬请期待。","slug":"HTTP版本演进：第二回","published":1,"updated":"2023-08-21T01:52:54.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxvn0005f8v7dn2k7vco","content":"<p><strong>续前文，本文将详细的介绍一下1.x版本的特性，主要就是1.1啦。</strong></p>\n<h2 id=\"1-x版本的三个特点：\"><a href=\"#1-x版本的三个特点：\" class=\"headerlink\" title=\"1.x版本的三个特点：\"></a>1.x版本的三个特点：</h2><ul>\n<li>长连接</li>\n<li>管道化</li>\n<li>串行传输</li>\n</ul>\n<h4 id=\"长连接\"><a href=\"#长连接\" class=\"headerlink\" title=\"长连接\"></a>长连接</h4><p>1.0版本遵循的规则是：建立链路–发送请求–接收响应–断开链路。对于每一个请求而言，1.5个rtt（往返时延）是必须的。假使我们现在有n个请求，那么固定的时耗就是1.5 * n。那么1.1的重大改进，就是利用长连接，实现了多个请求共用一个TCP连接通道。这样除了第一个请求外，对于后面的每个请求，都能省去用于建立链路的1个rtt耗时，即：我们能够节省（n-1）次的rtt（往返时延）。这就是长连接带来的好处。</p>\n<p>插个题外话：我们知道，c端在发送资源请求之前，需要通过三次握手建立连接链路，时间损耗，就用掉了1.5个往返，这里有个细节我之前一直没在意。就是发送资源请求的时间点与建立连接的那最后0.5的往返时刻是同时发生的，可以理解为，1.5的往返耗时，包含了请求时间，见下图：<br><img src=\"/img/http3.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\"></p>\n<p>同时，通过上图，也能看出，为什么1.1版本的改进影响巨大。著名案例就是苹果的工程师们针对itunes的改进，有兴趣自行谷歌。</p>\n<p>但是，通过长连接虽然实现了公用tcp链路，我们发现了新的问题，因为规则，仍然是第二个请求必须等待第一个请求的响应返回之后，才能发出。如此一来，当s端返回第一个请求的响应后直到第二个请求到达前的这段时间，都是处于空闲状态。这就叫c端的响应阻塞。我们希望的是，s端能够在处理完第一个请求发出响应后，立刻开始处理第二个请求，甚至，可以并行处理多个请求，怎么破？具体实践方法：管道化。</p>\n<h4 id=\"管道化。\"><a href=\"#管道化。\" class=\"headerlink\" title=\"管道化。\"></a>管道化。</h4><p>1.1版本之前，每次请求都需要等待上次请求的响应返回才能发出，1.1版本开始实现了无需等待，对于c端的改动，就是无需等待串行发送请求，到达s端就是一个队列，s端能够挨个取出请求发出响应或者开启多线程并行处理，直至队列空。这样，能够一定程度上的充分利用s端的处理能力。这就是管道化。</p>\n<img src=\"/img/http4.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\">\n共用一个tcp链路的情况下，c端先后发送html和css的请求。从图中发现，当s端返回html请求的响应后，一直处于空闲状态，直到css请求到达才开始处理。\n\n<img src=\"/img/http5.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\">\n**使用了管道化，c端串行发出请求，s端并行处理请求串行返回。理论上讲，通过长连接节省（n-1）个rtt基础上，再次节省了（n-1）个rtt。**\n\n<p>但是，由于http1.x协议本身的局限性，严格规定执行串行传输的策略，串型传输就是先进先出，对c端而言，请求必须依次发出。对s端而言即使后到的请求率先处理完成，也得等待。他不允许一个连接上的多个响应交错到达（多路复用）。这就导致了一个问题：倘若c端并行发送了两个请求：一个请求html，另一个请求了css。s端也能够并行的处理请求，css文件20ms完成，html40ms完成，那么在css完成的时候，她不能直接返回，而是要再等待20ms，即html请求处理完成后，再吧css的响应发出。这就叫队首阻塞。</p>\n<p>怎么破？</p>\n<ul>\n<li>并行tcp发送请求。</li>\n<li>http2.0多路复用。<br>后文详解，敬请期待。</li>\n</ul>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p><strong>续前文，本文将详细的介绍一下1.x版本的特性，主要就是1.1啦。</strong></p>\n<h2 id=\"1-x版本的三个特点：\"><a href=\"#1-x版本的三个特点：\" class=\"headerlink\" title=\"1.x版本的三个特点：\"></a>1.x版本的三个特点：</h2><ul>\n<li>长连接</li>\n<li>管道化</li>\n<li>串行传输</li>\n</ul>\n<h4 id=\"长连接\"><a href=\"#长连接\" class=\"headerlink\" title=\"长连接\"></a>长连接</h4><p>1.0版本遵循的规则是：建立链路–发送请求–接收响应–断开链路。对于每一个请求而言，1.5个rtt（往返时延）是必须的。假使我们现在有n个请求，那么固定的时耗就是1.5 * n。那么1.1的重大改进，就是利用长连接，实现了多个请求共用一个TCP连接通道。这样除了第一个请求外，对于后面的每个请求，都能省去用于建立链路的1个rtt耗时，即：我们能够节省（n-1）次的rtt（往返时延）。这就是长连接带来的好处。</p>\n<p>插个题外话：我们知道，c端在发送资源请求之前，需要通过三次握手建立连接链路，时间损耗，就用掉了1.5个往返，这里有个细节我之前一直没在意。就是发送资源请求的时间点与建立连接的那最后0.5的往返时刻是同时发生的，可以理解为，1.5的往返耗时，包含了请求时间，见下图：<br><img src=\"/img/http3.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\"></p>\n<p>同时，通过上图，也能看出，为什么1.1版本的改进影响巨大。著名案例就是苹果的工程师们针对itunes的改进，有兴趣自行谷歌。</p>\n<p>但是，通过长连接虽然实现了公用tcp链路，我们发现了新的问题，因为规则，仍然是第二个请求必须等待第一个请求的响应返回之后，才能发出。如此一来，当s端返回第一个请求的响应后直到第二个请求到达前的这段时间，都是处于空闲状态。这就叫c端的响应阻塞。我们希望的是，s端能够在处理完第一个请求发出响应后，立刻开始处理第二个请求，甚至，可以并行处理多个请求，怎么破？具体实践方法：管道化。</p>\n<h4 id=\"管道化。\"><a href=\"#管道化。\" class=\"headerlink\" title=\"管道化。\"></a>管道化。</h4><p>1.1版本之前，每次请求都需要等待上次请求的响应返回才能发出，1.1版本开始实现了无需等待，对于c端的改动，就是无需等待串行发送请求，到达s端就是一个队列，s端能够挨个取出请求发出响应或者开启多线程并行处理，直至队列空。这样，能够一定程度上的充分利用s端的处理能力。这就是管道化。</p>\n<img src=\"/img/http4.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\">\n共用一个tcp链路的情况下，c端先后发送html和css的请求。从图中发现，当s端返回html请求的响应后，一直处于空闲状态，直到css请求到达才开始处理。\n\n<img src=\"/img/http5.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\">\n**使用了管道化，c端串行发出请求，s端并行处理请求串行返回。理论上讲，通过长连接节省（n-1）个rtt基础上，再次节省了（n-1）个rtt。**\n\n<p>但是，由于http1.x协议本身的局限性，严格规定执行串行传输的策略，串型传输就是先进先出，对c端而言，请求必须依次发出。对s端而言即使后到的请求率先处理完成，也得等待。他不允许一个连接上的多个响应交错到达（多路复用）。这就导致了一个问题：倘若c端并行发送了两个请求：一个请求html，另一个请求了css。s端也能够并行的处理请求，css文件20ms完成，html40ms完成，那么在css完成的时候，她不能直接返回，而是要再等待20ms，即html请求处理完成后，再吧css的响应发出。这就叫队首阻塞。</p>\n<p>怎么破？</p>\n<ul>\n<li>并行tcp发送请求。</li>\n<li>http2.0多路复用。<br>后文详解，敬请期待。</li>\n</ul>\n"},{"title":"Nginx--简论","date":"2023-08-21T02:01:48.000Z","_content":"### 本文会帮你解答一个问题，nginx这玩意儿是干嘛的\nNginx是啥，官方说法，一种高性能的http与反向代理的web服务器。什么叫高性能？说白了就是响应尽可能地快。\n一般的项目后端配置tomcat即可满足需求，因为一个站点在某个时刻不可能会有大量的请求达到。tomcat最高同时能够满足5、600的请求响应，所以说一般场景下基本hold住。但是总有些热门的站点。在某一时刻会有数以万计的请求，这个时候，tomcat就扛不住了，服务器直接飘红。为了解决这一问题，nginx就来了（最大支持50000请求）。\n<img src=\"/img/nginx.jpg\" alt=\"nginx\" width=\"500\">\n\n**反向代理、负载均衡、动静分离。**\n\n#### 反向代理\n先说明什么是正向代理。玩吃鸡这类游戏的时候，我们往往要挂个加速器（vpn），不然就很慢。关于为什么慢甚至无法访问，请移步\"梯子\"那篇文章。这里的加速器，就是**正向代理**，开启代理，我们触发的任何请求均是由加速器代替我们的客户端发出去的。即：**代理客户端就是正向代理**。\n而反向代理的典型就是nginx。当客户端的请求发送给服务端的时候，实际上被nginx拦截，代替服务端返回响应。即：**代理服务端就叫做反向代理。**两者的效果是一样的，就是在c端和s端之间加了一层。实际的操作区别在于，一个装在c端一个跑在s端，如此而已。同一个站点的服务器，往往不会是一台，可能会有很多台。通过nginx这层中间层，即可实现高性能的需求。**顺带说一句，从架构的层面来做考量，没有什么，是加一层中间层解决不了的。如果有，那就再加一层。**\n\n#### 负载均衡\n上面实际已经提到了。某个时刻发送了4个请求，如果此时只有一台服务器，那么这四个请求会被这台服务器挨个处理，挨个儿响应，假设一个请求耗时N，总耗时就是4N。那么如果此时服务器端有四台服务器，四个请求被四台服务器同时处理并返回，耗时为N。这就叫负载均衡。注意，默认情况下是通过轮询的方式把四个请求依次给到四台服务器。但是我们也可以通过“weight”权重关键字灵活配置，也就是所谓的加权轮询。\n\n#### 动静分离\n实际就是其字面意义。不赘述。\n```javascript\n常用命令：\n关闭nginx，快速停止nginx，可能并不保存相关信息\nnginx -s stop\n\n重新载入nginx，当配置信息修改需要重新加载配置是使用\nnginx -s reload\n```","source":"_posts/Nginx-简论.md","raw":"---\ntitle: Nginx--简论\ncategory: 网络杂谈\ndate: 2023-08-21 10:01:48\ntags:\n---\n### 本文会帮你解答一个问题，nginx这玩意儿是干嘛的\nNginx是啥，官方说法，一种高性能的http与反向代理的web服务器。什么叫高性能？说白了就是响应尽可能地快。\n一般的项目后端配置tomcat即可满足需求，因为一个站点在某个时刻不可能会有大量的请求达到。tomcat最高同时能够满足5、600的请求响应，所以说一般场景下基本hold住。但是总有些热门的站点。在某一时刻会有数以万计的请求，这个时候，tomcat就扛不住了，服务器直接飘红。为了解决这一问题，nginx就来了（最大支持50000请求）。\n<img src=\"/img/nginx.jpg\" alt=\"nginx\" width=\"500\">\n\n**反向代理、负载均衡、动静分离。**\n\n#### 反向代理\n先说明什么是正向代理。玩吃鸡这类游戏的时候，我们往往要挂个加速器（vpn），不然就很慢。关于为什么慢甚至无法访问，请移步\"梯子\"那篇文章。这里的加速器，就是**正向代理**，开启代理，我们触发的任何请求均是由加速器代替我们的客户端发出去的。即：**代理客户端就是正向代理**。\n而反向代理的典型就是nginx。当客户端的请求发送给服务端的时候，实际上被nginx拦截，代替服务端返回响应。即：**代理服务端就叫做反向代理。**两者的效果是一样的，就是在c端和s端之间加了一层。实际的操作区别在于，一个装在c端一个跑在s端，如此而已。同一个站点的服务器，往往不会是一台，可能会有很多台。通过nginx这层中间层，即可实现高性能的需求。**顺带说一句，从架构的层面来做考量，没有什么，是加一层中间层解决不了的。如果有，那就再加一层。**\n\n#### 负载均衡\n上面实际已经提到了。某个时刻发送了4个请求，如果此时只有一台服务器，那么这四个请求会被这台服务器挨个处理，挨个儿响应，假设一个请求耗时N，总耗时就是4N。那么如果此时服务器端有四台服务器，四个请求被四台服务器同时处理并返回，耗时为N。这就叫负载均衡。注意，默认情况下是通过轮询的方式把四个请求依次给到四台服务器。但是我们也可以通过“weight”权重关键字灵活配置，也就是所谓的加权轮询。\n\n#### 动静分离\n实际就是其字面意义。不赘述。\n```javascript\n常用命令：\n关闭nginx，快速停止nginx，可能并不保存相关信息\nnginx -s stop\n\n重新载入nginx，当配置信息修改需要重新加载配置是使用\nnginx -s reload\n```","slug":"Nginx-简论","published":1,"updated":"2023-08-21T02:16:45.520Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxvo0007f8v742m9hir5","content":"<h3 id=\"本文会帮你解答一个问题，nginx这玩意儿是干嘛的\"><a href=\"#本文会帮你解答一个问题，nginx这玩意儿是干嘛的\" class=\"headerlink\" title=\"本文会帮你解答一个问题，nginx这玩意儿是干嘛的\"></a>本文会帮你解答一个问题，nginx这玩意儿是干嘛的</h3><p>Nginx是啥，官方说法，一种高性能的http与反向代理的web服务器。什么叫高性能？说白了就是响应尽可能地快。<br>一般的项目后端配置tomcat即可满足需求，因为一个站点在某个时刻不可能会有大量的请求达到。tomcat最高同时能够满足5、600的请求响应，所以说一般场景下基本hold住。但是总有些热门的站点。在某一时刻会有数以万计的请求，这个时候，tomcat就扛不住了，服务器直接飘红。为了解决这一问题，nginx就来了（最大支持50000请求）。<br><img src=\"/img/nginx.jpg\" alt=\"nginx\" width=\"500\"></p>\n<p><strong>反向代理、负载均衡、动静分离。</strong></p>\n<h4 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h4><p>先说明什么是正向代理。玩吃鸡这类游戏的时候，我们往往要挂个加速器（vpn），不然就很慢。关于为什么慢甚至无法访问，请移步”梯子”那篇文章。这里的加速器，就是<strong>正向代理</strong>，开启代理，我们触发的任何请求均是由加速器代替我们的客户端发出去的。即：<strong>代理客户端就是正向代理</strong>。<br>而反向代理的典型就是nginx。当客户端的请求发送给服务端的时候，实际上被nginx拦截，代替服务端返回响应。即：<strong>代理服务端就叫做反向代理。</strong>两者的效果是一样的，就是在c端和s端之间加了一层。实际的操作区别在于，一个装在c端一个跑在s端，如此而已。同一个站点的服务器，往往不会是一台，可能会有很多台。通过nginx这层中间层，即可实现高性能的需求。<strong>顺带说一句，从架构的层面来做考量，没有什么，是加一层中间层解决不了的。如果有，那就再加一层。</strong></p>\n<h4 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h4><p>上面实际已经提到了。某个时刻发送了4个请求，如果此时只有一台服务器，那么这四个请求会被这台服务器挨个处理，挨个儿响应，假设一个请求耗时N，总耗时就是4N。那么如果此时服务器端有四台服务器，四个请求被四台服务器同时处理并返回，耗时为N。这就叫负载均衡。注意，默认情况下是通过轮询的方式把四个请求依次给到四台服务器。但是我们也可以通过“weight”权重关键字灵活配置，也就是所谓的加权轮询。</p>\n<h4 id=\"动静分离\"><a href=\"#动静分离\" class=\"headerlink\" title=\"动静分离\"></a>动静分离</h4><p>实际就是其字面意义。不赘述。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">常用命令：</span><br><span class=\"line\">关闭nginx，快速停止nginx，可能并不保存相关信息</span><br><span class=\"line\">nginx -s stop</span><br><span class=\"line\"></span><br><span class=\"line\">重新载入nginx，当配置信息修改需要重新加载配置是使用</span><br><span class=\"line\">nginx -s reload</span><br></pre></td></tr></table></figure>","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"本文会帮你解答一个问题，nginx这玩意儿是干嘛的\"><a href=\"#本文会帮你解答一个问题，nginx这玩意儿是干嘛的\" class=\"headerlink\" title=\"本文会帮你解答一个问题，nginx这玩意儿是干嘛的\"></a>本文会帮你解答一个问题，nginx这玩意儿是干嘛的</h3><p>Nginx是啥，官方说法，一种高性能的http与反向代理的web服务器。什么叫高性能？说白了就是响应尽可能地快。<br>一般的项目后端配置tomcat即可满足需求，因为一个站点在某个时刻不可能会有大量的请求达到。tomcat最高同时能够满足5、600的请求响应，所以说一般场景下基本hold住。但是总有些热门的站点。在某一时刻会有数以万计的请求，这个时候，tomcat就扛不住了，服务器直接飘红。为了解决这一问题，nginx就来了（最大支持50000请求）。<br><img src=\"/img/nginx.jpg\" alt=\"nginx\" width=\"500\"></p>\n<p><strong>反向代理、负载均衡、动静分离。</strong></p>\n<h4 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h4><p>先说明什么是正向代理。玩吃鸡这类游戏的时候，我们往往要挂个加速器（vpn），不然就很慢。关于为什么慢甚至无法访问，请移步”梯子”那篇文章。这里的加速器，就是<strong>正向代理</strong>，开启代理，我们触发的任何请求均是由加速器代替我们的客户端发出去的。即：<strong>代理客户端就是正向代理</strong>。<br>而反向代理的典型就是nginx。当客户端的请求发送给服务端的时候，实际上被nginx拦截，代替服务端返回响应。即：<strong>代理服务端就叫做反向代理。</strong>两者的效果是一样的，就是在c端和s端之间加了一层。实际的操作区别在于，一个装在c端一个跑在s端，如此而已。同一个站点的服务器，往往不会是一台，可能会有很多台。通过nginx这层中间层，即可实现高性能的需求。<strong>顺带说一句，从架构的层面来做考量，没有什么，是加一层中间层解决不了的。如果有，那就再加一层。</strong></p>\n<h4 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h4><p>上面实际已经提到了。某个时刻发送了4个请求，如果此时只有一台服务器，那么这四个请求会被这台服务器挨个处理，挨个儿响应，假设一个请求耗时N，总耗时就是4N。那么如果此时服务器端有四台服务器，四个请求被四台服务器同时处理并返回，耗时为N。这就叫负载均衡。注意，默认情况下是通过轮询的方式把四个请求依次给到四台服务器。但是我们也可以通过“weight”权重关键字灵活配置，也就是所谓的加权轮询。</p>\n<h4 id=\"动静分离\"><a href=\"#动静分离\" class=\"headerlink\" title=\"动静分离\"></a>动静分离</h4><p>实际就是其字面意义。不赘述。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">常用命令：</span><br><span class=\"line\">关闭nginx，快速停止nginx，可能并不保存相关信息</span><br><span class=\"line\">nginx -s stop</span><br><span class=\"line\"></span><br><span class=\"line\">重新载入nginx，当配置信息修改需要重新加载配置是使用</span><br><span class=\"line\">nginx -s reload</span><br></pre></td></tr></table></figure>"},{"title":"Vue.js系列：patch","date":"2023-08-07T15:49:03.000Z","_content":"\n节点的**patch（补丁）**操作，是虚拟dom核心中的核心,**就是对比出新旧节点中，变化了的那些部分**。本质上来讲就三种情况：**创建节点、删除节点和修改需要更新的节点**。\n1. 创建节点，两种情况。\n- 当oldVnode中不存在但是vnode中存在的某些节点时，需要创建新节点\n- 当新旧节点是完全不同的节点时，比如新节点时一个text，但是旧节点是一个div。此时需要删除旧的创建新的。\n\n2. 删除节点：上面提了不赘述\n\n3. 当两个节点是同一节点的时候，才需要进行更新节点的操作\n- 3.1 首先判断新旧节点是否为如下所示的静态节点：\n```javascript\n<p>asdasdasd</p>\n```\n所谓的**静态节点**就是不存在状态的标签节点。\n此时，直接跳过，因为他不会变化。\n\n- 3.2 新节点是否为**文本节点**\n3.2.1 新节点是文本节点： 旧节点有children删children，有text覆盖更新\n3.2.2 新节点不是文本节点，是元素节点\n3.2.2.1 新节点有children\n3.2.2.1.1 旧节点无children：遍历新节点children挨个添加\n3.2.2.1.2 旧节点有children： Diff后论\n3.2.2.2 新节点无children：旧节点有text删text，有children删children\n\n大致流程如上所述，下面稍微说一说更新子节点的diff算法。\n毫无疑问我们需要遍历。遍历新节点的children，挨个去旧节点的children中去找，如果没找到，说明该节点是由于状态变化新增的节点，那就要创建。如果找到了那就更新。当然还有一个可能，就是找是找到了，但是位置变了，这时，就需要移动该节点的位置。\n\n然后diff算法对比的具体过程遵循的几个原则：\n新前旧前、新后旧后、新后旧前、新前旧后。这是人家的算法规则，至于为什么这么搞....人家愿意\n暂且这样吧，有空再更...","source":"_posts/Vue.js系列：patch.md","raw":"---\ntitle: Vue.js系列：patch\ncategory: 大前端剑宗专栏\ndate: 2023-08-07 23:49:03\ntags:\n---\n\n节点的**patch（补丁）**操作，是虚拟dom核心中的核心,**就是对比出新旧节点中，变化了的那些部分**。本质上来讲就三种情况：**创建节点、删除节点和修改需要更新的节点**。\n1. 创建节点，两种情况。\n- 当oldVnode中不存在但是vnode中存在的某些节点时，需要创建新节点\n- 当新旧节点是完全不同的节点时，比如新节点时一个text，但是旧节点是一个div。此时需要删除旧的创建新的。\n\n2. 删除节点：上面提了不赘述\n\n3. 当两个节点是同一节点的时候，才需要进行更新节点的操作\n- 3.1 首先判断新旧节点是否为如下所示的静态节点：\n```javascript\n<p>asdasdasd</p>\n```\n所谓的**静态节点**就是不存在状态的标签节点。\n此时，直接跳过，因为他不会变化。\n\n- 3.2 新节点是否为**文本节点**\n3.2.1 新节点是文本节点： 旧节点有children删children，有text覆盖更新\n3.2.2 新节点不是文本节点，是元素节点\n3.2.2.1 新节点有children\n3.2.2.1.1 旧节点无children：遍历新节点children挨个添加\n3.2.2.1.2 旧节点有children： Diff后论\n3.2.2.2 新节点无children：旧节点有text删text，有children删children\n\n大致流程如上所述，下面稍微说一说更新子节点的diff算法。\n毫无疑问我们需要遍历。遍历新节点的children，挨个去旧节点的children中去找，如果没找到，说明该节点是由于状态变化新增的节点，那就要创建。如果找到了那就更新。当然还有一个可能，就是找是找到了，但是位置变了，这时，就需要移动该节点的位置。\n\n然后diff算法对比的具体过程遵循的几个原则：\n新前旧前、新后旧后、新后旧前、新前旧后。这是人家的算法规则，至于为什么这么搞....人家愿意\n暂且这样吧，有空再更...","slug":"Vue.js系列：patch","published":1,"updated":"2023-08-21T01:52:54.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxvp0008f8v7btj67axj","content":"<p>节点的<strong>patch（补丁）</strong>操作，是虚拟dom核心中的核心,<strong>就是对比出新旧节点中，变化了的那些部分</strong>。本质上来讲就三种情况：<strong>创建节点、删除节点和修改需要更新的节点</strong>。</p>\n<ol>\n<li>创建节点，两种情况。</li>\n</ol>\n<ul>\n<li>当oldVnode中不存在但是vnode中存在的某些节点时，需要创建新节点</li>\n<li>当新旧节点是完全不同的节点时，比如新节点时一个text，但是旧节点是一个div。此时需要删除旧的创建新的。</li>\n</ul>\n<ol start=\"2\">\n<li><p>删除节点：上面提了不赘述</p>\n</li>\n<li><p>当两个节点是同一节点的时候，才需要进行更新节点的操作</p>\n</li>\n</ol>\n<ul>\n<li><p>3.1 首先判断新旧节点是否为如下所示的静态节点：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;asdasdasd&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<p>所谓的<strong>静态节点</strong>就是不存在状态的标签节点。<br>此时，直接跳过，因为他不会变化。</p>\n</li>\n<li><p>3.2 新节点是否为<strong>文本节点</strong><br>3.2.1 新节点是文本节点： 旧节点有children删children，有text覆盖更新<br>3.2.2 新节点不是文本节点，是元素节点<br>3.2.2.1 新节点有children<br>3.2.2.1.1 旧节点无children：遍历新节点children挨个添加<br>3.2.2.1.2 旧节点有children： Diff后论<br>3.2.2.2 新节点无children：旧节点有text删text，有children删children</p>\n</li>\n</ul>\n<p>大致流程如上所述，下面稍微说一说更新子节点的diff算法。<br>毫无疑问我们需要遍历。遍历新节点的children，挨个去旧节点的children中去找，如果没找到，说明该节点是由于状态变化新增的节点，那就要创建。如果找到了那就更新。当然还有一个可能，就是找是找到了，但是位置变了，这时，就需要移动该节点的位置。</p>\n<p>然后diff算法对比的具体过程遵循的几个原则：<br>新前旧前、新后旧后、新后旧前、新前旧后。这是人家的算法规则，至于为什么这么搞….人家愿意<br>暂且这样吧，有空再更…</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>节点的<strong>patch（补丁）</strong>操作，是虚拟dom核心中的核心,<strong>就是对比出新旧节点中，变化了的那些部分</strong>。本质上来讲就三种情况：<strong>创建节点、删除节点和修改需要更新的节点</strong>。</p>\n<ol>\n<li>创建节点，两种情况。</li>\n</ol>\n<ul>\n<li>当oldVnode中不存在但是vnode中存在的某些节点时，需要创建新节点</li>\n<li>当新旧节点是完全不同的节点时，比如新节点时一个text，但是旧节点是一个div。此时需要删除旧的创建新的。</li>\n</ul>\n<ol start=\"2\">\n<li><p>删除节点：上面提了不赘述</p>\n</li>\n<li><p>当两个节点是同一节点的时候，才需要进行更新节点的操作</p>\n</li>\n</ol>\n<ul>\n<li><p>3.1 首先判断新旧节点是否为如下所示的静态节点：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;asdasdasd&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<p>所谓的<strong>静态节点</strong>就是不存在状态的标签节点。<br>此时，直接跳过，因为他不会变化。</p>\n</li>\n<li><p>3.2 新节点是否为<strong>文本节点</strong><br>3.2.1 新节点是文本节点： 旧节点有children删children，有text覆盖更新<br>3.2.2 新节点不是文本节点，是元素节点<br>3.2.2.1 新节点有children<br>3.2.2.1.1 旧节点无children：遍历新节点children挨个添加<br>3.2.2.1.2 旧节点有children： Diff后论<br>3.2.2.2 新节点无children：旧节点有text删text，有children删children</p>\n</li>\n</ul>\n<p>大致流程如上所述，下面稍微说一说更新子节点的diff算法。<br>毫无疑问我们需要遍历。遍历新节点的children，挨个去旧节点的children中去找，如果没找到，说明该节点是由于状态变化新增的节点，那就要创建。如果找到了那就更新。当然还有一个可能，就是找是找到了，但是位置变了，这时，就需要移动该节点的位置。</p>\n<p>然后diff算法对比的具体过程遵循的几个原则：<br>新前旧前、新后旧后、新后旧前、新前旧后。这是人家的算法规则，至于为什么这么搞….人家愿意<br>暂且这样吧，有空再更…</p>\n"},{"title":"Vue.js系列：vue的路由实现","date":"2023-08-10T16:45:40.000Z","_content":"\nvue-router存在的目的，就是实现纯前端的路由跳转，需要满足两点：**无刷新、内容切换**\n目下就是两种模式：**hash模式和history模式**\n\n#### Hash模式：\n#后面跟着路径（hash值），浏览器不会向后端发请求。因为#只是一个标识符。例如：http://www.xxx.com/#/info.html。\n**实现原理：**\n通过监听hashchange,获悉当前url，显示对应视图内容。\n```javascript\nwindow.addEventListener('hashchange', updateView)\n```\n\n#### history\nh5新增的api，通过history.pushstate跳转到对应路由，显示对应视图,也能实现一样的功能，但是因为少个#，所以更加的美观.例如：http://www.xxx.com/info.html\n\n但该方法准确的讲，是能够实现当用户没有刷新整个页面的情况下，实现视图的更新。如果强制刷新了页面，后端会收到该地址，若不处理，返回404，因为没有匹配到任何资源.因此这边需要后端做一个统一的处理，一般默认返回首页。\n如果要细究vue-router的底层逻辑，实质还是一个类，具体实现还是响应式的那一套，区别在于，vue-router监听的是地址栏里的url，而MVVM监听的是页面数据，仅此而已。","source":"_posts/Vue.js系列：vue的路由实现.md","raw":"---\ntitle: Vue.js系列：vue的路由实现\ndate: 2023-08-11 00:45:40\ncategory: 大前端剑宗专栏\ntags:\n---\n\nvue-router存在的目的，就是实现纯前端的路由跳转，需要满足两点：**无刷新、内容切换**\n目下就是两种模式：**hash模式和history模式**\n\n#### Hash模式：\n#后面跟着路径（hash值），浏览器不会向后端发请求。因为#只是一个标识符。例如：http://www.xxx.com/#/info.html。\n**实现原理：**\n通过监听hashchange,获悉当前url，显示对应视图内容。\n```javascript\nwindow.addEventListener('hashchange', updateView)\n```\n\n#### history\nh5新增的api，通过history.pushstate跳转到对应路由，显示对应视图,也能实现一样的功能，但是因为少个#，所以更加的美观.例如：http://www.xxx.com/info.html\n\n但该方法准确的讲，是能够实现当用户没有刷新整个页面的情况下，实现视图的更新。如果强制刷新了页面，后端会收到该地址，若不处理，返回404，因为没有匹配到任何资源.因此这边需要后端做一个统一的处理，一般默认返回首页。\n如果要细究vue-router的底层逻辑，实质还是一个类，具体实现还是响应式的那一套，区别在于，vue-router监听的是地址栏里的url，而MVVM监听的是页面数据，仅此而已。","slug":"Vue.js系列：vue的路由实现","published":1,"updated":"2023-08-21T01:52:54.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxvq000bf8v75djva9f8","content":"<p>vue-router存在的目的，就是实现纯前端的路由跳转，需要满足两点：<strong>无刷新、内容切换</strong><br>目下就是两种模式：<strong>hash模式和history模式</strong></p>\n<h4 id=\"Hash模式：\"><a href=\"#Hash模式：\" class=\"headerlink\" title=\"Hash模式：\"></a>Hash模式：</h4><p>#后面跟着路径（hash值），浏览器不会向后端发请求。因为#只是一个标识符。例如：<a href=\"http://www.xxx.com/#/info.html%E3%80%82\">http://www.xxx.com/#/info.html。</a><br><strong>实现原理：</strong><br>通过监听hashchange,获悉当前url，显示对应视图内容。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;hashchange&#x27;</span>, updateView)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"history\"><a href=\"#history\" class=\"headerlink\" title=\"history\"></a>history</h4><p>h5新增的api，通过history.pushstate跳转到对应路由，显示对应视图,也能实现一样的功能，但是因为少个#，所以更加的美观.例如：<a href=\"http://www.xxx.com/info.html\">http://www.xxx.com/info.html</a></p>\n<p>但该方法准确的讲，是能够实现当用户没有刷新整个页面的情况下，实现视图的更新。如果强制刷新了页面，后端会收到该地址，若不处理，返回404，因为没有匹配到任何资源.因此这边需要后端做一个统一的处理，一般默认返回首页。<br>如果要细究vue-router的底层逻辑，实质还是一个类，具体实现还是响应式的那一套，区别在于，vue-router监听的是地址栏里的url，而MVVM监听的是页面数据，仅此而已。</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>vue-router存在的目的，就是实现纯前端的路由跳转，需要满足两点：<strong>无刷新、内容切换</strong><br>目下就是两种模式：<strong>hash模式和history模式</strong></p>\n<h4 id=\"Hash模式：\"><a href=\"#Hash模式：\" class=\"headerlink\" title=\"Hash模式：\"></a>Hash模式：</h4><p>#后面跟着路径（hash值），浏览器不会向后端发请求。因为#只是一个标识符。例如：<a href=\"http://www.xxx.com/#/info.html%E3%80%82\">http://www.xxx.com/#/info.html。</a><br><strong>实现原理：</strong><br>通过监听hashchange,获悉当前url，显示对应视图内容。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;hashchange&#x27;</span>, updateView)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"history\"><a href=\"#history\" class=\"headerlink\" title=\"history\"></a>history</h4><p>h5新增的api，通过history.pushstate跳转到对应路由，显示对应视图,也能实现一样的功能，但是因为少个#，所以更加的美观.例如：<a href=\"http://www.xxx.com/info.html\">http://www.xxx.com/info.html</a></p>\n<p>但该方法准确的讲，是能够实现当用户没有刷新整个页面的情况下，实现视图的更新。如果强制刷新了页面，后端会收到该地址，若不处理，返回404，因为没有匹配到任何资源.因此这边需要后端做一个统一的处理，一般默认返回首页。<br>如果要细究vue-router的底层逻辑，实质还是一个类，具体实现还是响应式的那一套，区别在于，vue-router监听的是地址栏里的url，而MVVM监听的是页面数据，仅此而已。</p>\n"},{"title":"Vue.js系列：实现一个自己的vue","date":"2023-08-09T01:54:37.000Z","_content":"\n**本文开始，我们尝试着实现一个自个儿的vue框架（简陋版本）。**\n\n1. 首先我们的页面结构如下：\n```javascript\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>My_vue</title>\n</head>\n<script src=\"./Compile.js\"></script>\n<script src=\"./Myvue.js\"></script>\n<body>\n    <div id=\"app\">\n        <input type=\"text\" v-model=\"msg\">\n        <div>{{msg}}---{{info}}</div>\n    </div>\n</body>\n<script>\n    const mv = new MyVue({\n        el: '#app',\n        data: {\n            msg: 'hello',\n            info: 'world'\n        }\n    })\n\n</script>\n</html>\n```\n照葫芦画瓢，通过script标签引入我们的Myvue文件，然后在底部实例化mv。入参的名称参考vue。\n样子有了，具体页面呢？\n具体页面长这样：\n<img src=\"/img/vue_basic_1.jpg\" alt=\"主页面结构\" width=\"500\">\n\n其中输入框通过v-model绑定变量msg，另一个文本绑定了info。可为什么原样显示呢？废话，应为我们还啥都没做。目前的Myvue代码如下：\n```javascript\nclass MyVue {\n    constructor(vm) {\n        this.vm = vm\n        this.$data = vm.data\n        this.$el = document.querySelector(vm.el)\n        new Compile(this)\n    }\n}\n```\nMyvue就是一个class类，其中拥有三个属性，vm，当前myvue的实例，更直白的将就是描述当前组件的那个入参对象；$data: 设置的各个变量；$el: 绑定的div的dom节点。\nvue框架的做的第一件事情，就是页面渲染完成后，能够将其中的变量msg和info变成我们设置的值，而不是上面那副模样。这个过程，就是**模板编译**。即：**能自动的将html代码中的变量，变成对应的值**。比如我们预先定义的msg应该显示为hello,还能对v-model这样的指令进行解析，让input的value变成对应变量的值...\n注释：前端领域的**编译**和我们传统的计算机专业内定义的**编译**有些不同，但是内核精神是一致的。写过c或者java都知道，我们写的程序是一套代码，但是这套代码机器无法直接运行，因为机器只能执行二进制，此处概念的理解可以去看看《编码》这本书，他会告诉你，**cpu的本质，之际就是继电器。**回过头来，因为机器看不懂我们人类系的代码，所以需要**编译器**这个中介，将我们写的这一套代码，转换成机器能够执行的二进制代码。而前端领域中的**模板编译**，指的是将如上图中，页面绑定的各个变量，转换成其真实的值。顺带提一句，webpack中的各种loader也可以看成是各种编译器，如babel-loader，因为浏览器看不懂es6及其之后版本的js代码，那么babel-loader的作用就是转换之。但是总的来说，本质的精神内核是一致的：**自动转换**。\n\n#### 实现我们的编译器Compile函数，完成模板编译工作。\n具体的思路很清晰，就是找出存在msg或者info这样的变量所在的地方，然后用我们vue实例对象mv的data中的数据更新。\n首先在html文件中引入一个单独的Compile.js文件:\n```html\n<script src=\"./Compile.js\"></script>\n```\nCompile也是一个类。入参为当前的实例对象mv。具体代码如下：\n```javascript\n//  什么叫编译模板--->把template变成dom，如{{变量}}--->真实的数据\n\nclass Compile {\n    constructor(vm) {\n        this.vm = vm\n        this.el = vm.$el\n        const fragment = this.nodeToFragment()\n        this.compile(fragment)\n        this.vm.$el.appendChild(fragment)\n        // console.log('f', fragment)\n        // 编译文档片段，解析{{}}\n    }\n    // 解析出{{}},变量赋值\n    compile(fragment) {\n        const nList = fragment.childNodes\n        nList.forEach((node) => {\n            const nType = node.nodeType\n            if (nType === 3) {\n                this.compileText(node)\n                // 解析文本\n            } else if (nType === 1) {\n                this.compileElement(node)\n                // 元素节点\n                \n            }\n            if (node.childNodes && node.childNodes !== 0) {\n                this.compile(node)\n            }\n        })\n    }\n    compileElement(node) {\n        const attrs = node.attributes\n        if (!!attrs.length) {\n            const attrsArr = Array.from(attrs)\n            attrsArr.forEach((att) => {\n                if(att.nodeName === 'v-model') {\n                    const val = att.value\n                    node.value = this.vm.$data[val]\n                }\n            })\n        }\n    }\n    compileText(node) {\n        const con = node.textContent\n        const reg = /\\{\\{(.+?)\\}\\}/g\n        if(reg.test(con)) {\n            console.log(node)\n            const newVal = con.replace(reg, (...arg) => {\n                return this.vm.$data[arg[1]]\n            })\n            node.textContent = newVal\n        }\n    }\n    nodeToFragment() {\n        const f = document.createDocumentFragment()\n        while(this.el.firstChild) {\n            f.appendChild(this.el.firstChild)\n        }\n        return f\n    }\n}\n```\n逐一解释：\n- 1. 两个属性：vm绑定实例mv，el绑定真实的dom。初始化时通过nodeToFragment方法拿到了一个输出，然后调用compile方法，其结果的输出直接被覆盖式的添加到了el中，完成编译工作。\n- 2. **nodeToFragment做了啥？**\n```javascript\n    nodeToFragment() {\n        const f = document.createDocumentFragment()\n        while(this.el.firstChild) {\n            f.appendChild(this.el.firstChild)\n        }\n        return f\n    }\n```\n创建了一个文档片段，然后自毁式遍历当前的el的儿子元素，依次添加到了文档片段f中。这里需要解释的一点是，当我们将el.firstChild添加到f中后，el的firstChild会变成之前的第二个，以此类推所以称之为自毁。但是呢，dom被添加到f中后，此时页面只会少不会增。可以理解为我们暂时性的找了个盒子，专门用来存放这些真实的dom。所以nodeToFragment函数的作用，就是把所有的真实儿子节点给到了文档片段f。然后以其作为输入，调用compile。\n- 3. **compile干了啥？找出所有的data中的变量**\n```javascript\n    // 解析出{{}},变量赋值\n    compile(fragment) {\n        const nList = fragment.childNodes\n        nList.forEach((node) => {\n            const nType = node.nodeType\n            if (nType === 3) {\n                this.compileText(node)\n                // 解析文本\n            } else if (nType === 1) {\n                this.compileElement(node)\n                // 元素节点\n                \n            }\n            if (node.childNodes && node.childNodes !== 0) {\n                this.compile(node)\n            }\n        })\n    }\n```\n该函数就是一个中转函数，然后交给对应的编译节点函数处理。遍历所有的子节点，然后根据nodeType分别处理。nodeType时节点的类型字段，比如，3就是文本text，1就是元素如div。\n**对于文本节点的处理：**\n```javascript\n    compileText(node) {\n        const con = node.textContent\n        const reg = /\\{\\{(.+?)\\}\\}/g\n        if(reg.test(con)) {\n            console.log(node)\n            const newVal = con.replace(reg, (...arg) => {\n                return this.vm.$data[arg[1]]\n            })\n            node.textContent = newVal\n        }\n    }\n```\n通过textContent属性，获取文本节点的具体内容，然后通过正则匹配双括号的规则，匹配出变量如{{msg}}、{{info}}等。再根据vm.$data中对应的变量值，覆盖文本节点的textContent 。**至此完成文本节点的变量--->值的页面赋值。**\n\n**对于元素节点的处理：**\n```javascript\n    compileElement(node) {\n        const attrs = node.attributes\n        if (!!attrs.length) {\n            const attrsArr = Array.from(attrs)\n            attrsArr.forEach((att) => {\n                if(att.nodeName === 'v-model') {\n                    const val = att.value\n                    node.value = this.vm.$data[val]\n                }\n            })\n        }\n    }\n```\n对元素节点的解析是为了处理像v-model这样的自定应属性。通过attributes属性获取该元素的所有属性。找到v-model对应的变量名，然后改写node.value完成元素节点的变量--->值的页面赋值。\n\n- 4. **将文档片段直接塞入容器dom---el。更新页面中的所有绑定变量数据，完成模板解析。**\n```javascript\nthis.vm.$el.appendChild(fragment)\n```\n\n<img src=\"/img/vue_basic_2.png\" alt=\"插入文档片段，完成编译\" width=\"500\">\n","source":"_posts/Vue.js系列：实现一个自己的vue.md","raw":"---\ntitle: Vue.js系列：实现一个自己的vue\ndate: 2023-08-09 09:54:37\ncategory: 大前端剑宗专栏\ntags:\n---\n\n**本文开始，我们尝试着实现一个自个儿的vue框架（简陋版本）。**\n\n1. 首先我们的页面结构如下：\n```javascript\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>My_vue</title>\n</head>\n<script src=\"./Compile.js\"></script>\n<script src=\"./Myvue.js\"></script>\n<body>\n    <div id=\"app\">\n        <input type=\"text\" v-model=\"msg\">\n        <div>{{msg}}---{{info}}</div>\n    </div>\n</body>\n<script>\n    const mv = new MyVue({\n        el: '#app',\n        data: {\n            msg: 'hello',\n            info: 'world'\n        }\n    })\n\n</script>\n</html>\n```\n照葫芦画瓢，通过script标签引入我们的Myvue文件，然后在底部实例化mv。入参的名称参考vue。\n样子有了，具体页面呢？\n具体页面长这样：\n<img src=\"/img/vue_basic_1.jpg\" alt=\"主页面结构\" width=\"500\">\n\n其中输入框通过v-model绑定变量msg，另一个文本绑定了info。可为什么原样显示呢？废话，应为我们还啥都没做。目前的Myvue代码如下：\n```javascript\nclass MyVue {\n    constructor(vm) {\n        this.vm = vm\n        this.$data = vm.data\n        this.$el = document.querySelector(vm.el)\n        new Compile(this)\n    }\n}\n```\nMyvue就是一个class类，其中拥有三个属性，vm，当前myvue的实例，更直白的将就是描述当前组件的那个入参对象；$data: 设置的各个变量；$el: 绑定的div的dom节点。\nvue框架的做的第一件事情，就是页面渲染完成后，能够将其中的变量msg和info变成我们设置的值，而不是上面那副模样。这个过程，就是**模板编译**。即：**能自动的将html代码中的变量，变成对应的值**。比如我们预先定义的msg应该显示为hello,还能对v-model这样的指令进行解析，让input的value变成对应变量的值...\n注释：前端领域的**编译**和我们传统的计算机专业内定义的**编译**有些不同，但是内核精神是一致的。写过c或者java都知道，我们写的程序是一套代码，但是这套代码机器无法直接运行，因为机器只能执行二进制，此处概念的理解可以去看看《编码》这本书，他会告诉你，**cpu的本质，之际就是继电器。**回过头来，因为机器看不懂我们人类系的代码，所以需要**编译器**这个中介，将我们写的这一套代码，转换成机器能够执行的二进制代码。而前端领域中的**模板编译**，指的是将如上图中，页面绑定的各个变量，转换成其真实的值。顺带提一句，webpack中的各种loader也可以看成是各种编译器，如babel-loader，因为浏览器看不懂es6及其之后版本的js代码，那么babel-loader的作用就是转换之。但是总的来说，本质的精神内核是一致的：**自动转换**。\n\n#### 实现我们的编译器Compile函数，完成模板编译工作。\n具体的思路很清晰，就是找出存在msg或者info这样的变量所在的地方，然后用我们vue实例对象mv的data中的数据更新。\n首先在html文件中引入一个单独的Compile.js文件:\n```html\n<script src=\"./Compile.js\"></script>\n```\nCompile也是一个类。入参为当前的实例对象mv。具体代码如下：\n```javascript\n//  什么叫编译模板--->把template变成dom，如{{变量}}--->真实的数据\n\nclass Compile {\n    constructor(vm) {\n        this.vm = vm\n        this.el = vm.$el\n        const fragment = this.nodeToFragment()\n        this.compile(fragment)\n        this.vm.$el.appendChild(fragment)\n        // console.log('f', fragment)\n        // 编译文档片段，解析{{}}\n    }\n    // 解析出{{}},变量赋值\n    compile(fragment) {\n        const nList = fragment.childNodes\n        nList.forEach((node) => {\n            const nType = node.nodeType\n            if (nType === 3) {\n                this.compileText(node)\n                // 解析文本\n            } else if (nType === 1) {\n                this.compileElement(node)\n                // 元素节点\n                \n            }\n            if (node.childNodes && node.childNodes !== 0) {\n                this.compile(node)\n            }\n        })\n    }\n    compileElement(node) {\n        const attrs = node.attributes\n        if (!!attrs.length) {\n            const attrsArr = Array.from(attrs)\n            attrsArr.forEach((att) => {\n                if(att.nodeName === 'v-model') {\n                    const val = att.value\n                    node.value = this.vm.$data[val]\n                }\n            })\n        }\n    }\n    compileText(node) {\n        const con = node.textContent\n        const reg = /\\{\\{(.+?)\\}\\}/g\n        if(reg.test(con)) {\n            console.log(node)\n            const newVal = con.replace(reg, (...arg) => {\n                return this.vm.$data[arg[1]]\n            })\n            node.textContent = newVal\n        }\n    }\n    nodeToFragment() {\n        const f = document.createDocumentFragment()\n        while(this.el.firstChild) {\n            f.appendChild(this.el.firstChild)\n        }\n        return f\n    }\n}\n```\n逐一解释：\n- 1. 两个属性：vm绑定实例mv，el绑定真实的dom。初始化时通过nodeToFragment方法拿到了一个输出，然后调用compile方法，其结果的输出直接被覆盖式的添加到了el中，完成编译工作。\n- 2. **nodeToFragment做了啥？**\n```javascript\n    nodeToFragment() {\n        const f = document.createDocumentFragment()\n        while(this.el.firstChild) {\n            f.appendChild(this.el.firstChild)\n        }\n        return f\n    }\n```\n创建了一个文档片段，然后自毁式遍历当前的el的儿子元素，依次添加到了文档片段f中。这里需要解释的一点是，当我们将el.firstChild添加到f中后，el的firstChild会变成之前的第二个，以此类推所以称之为自毁。但是呢，dom被添加到f中后，此时页面只会少不会增。可以理解为我们暂时性的找了个盒子，专门用来存放这些真实的dom。所以nodeToFragment函数的作用，就是把所有的真实儿子节点给到了文档片段f。然后以其作为输入，调用compile。\n- 3. **compile干了啥？找出所有的data中的变量**\n```javascript\n    // 解析出{{}},变量赋值\n    compile(fragment) {\n        const nList = fragment.childNodes\n        nList.forEach((node) => {\n            const nType = node.nodeType\n            if (nType === 3) {\n                this.compileText(node)\n                // 解析文本\n            } else if (nType === 1) {\n                this.compileElement(node)\n                // 元素节点\n                \n            }\n            if (node.childNodes && node.childNodes !== 0) {\n                this.compile(node)\n            }\n        })\n    }\n```\n该函数就是一个中转函数，然后交给对应的编译节点函数处理。遍历所有的子节点，然后根据nodeType分别处理。nodeType时节点的类型字段，比如，3就是文本text，1就是元素如div。\n**对于文本节点的处理：**\n```javascript\n    compileText(node) {\n        const con = node.textContent\n        const reg = /\\{\\{(.+?)\\}\\}/g\n        if(reg.test(con)) {\n            console.log(node)\n            const newVal = con.replace(reg, (...arg) => {\n                return this.vm.$data[arg[1]]\n            })\n            node.textContent = newVal\n        }\n    }\n```\n通过textContent属性，获取文本节点的具体内容，然后通过正则匹配双括号的规则，匹配出变量如{{msg}}、{{info}}等。再根据vm.$data中对应的变量值，覆盖文本节点的textContent 。**至此完成文本节点的变量--->值的页面赋值。**\n\n**对于元素节点的处理：**\n```javascript\n    compileElement(node) {\n        const attrs = node.attributes\n        if (!!attrs.length) {\n            const attrsArr = Array.from(attrs)\n            attrsArr.forEach((att) => {\n                if(att.nodeName === 'v-model') {\n                    const val = att.value\n                    node.value = this.vm.$data[val]\n                }\n            })\n        }\n    }\n```\n对元素节点的解析是为了处理像v-model这样的自定应属性。通过attributes属性获取该元素的所有属性。找到v-model对应的变量名，然后改写node.value完成元素节点的变量--->值的页面赋值。\n\n- 4. **将文档片段直接塞入容器dom---el。更新页面中的所有绑定变量数据，完成模板解析。**\n```javascript\nthis.vm.$el.appendChild(fragment)\n```\n\n<img src=\"/img/vue_basic_2.png\" alt=\"插入文档片段，完成编译\" width=\"500\">\n","slug":"Vue.js系列：实现一个自己的vue","published":1,"updated":"2023-08-21T01:52:54.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxvr000cf8v7g4o7b1al","content":"<p><strong>本文开始，我们尝试着实现一个自个儿的vue框架（简陋版本）。</strong></p>\n<ol>\n<li>首先我们的页面结构如下：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!<span class=\"variable constant_\">DOCTYPE</span> html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class=\"line\">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;My_vue&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;script src=&quot;./Compile.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=&quot;./Myvue.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">        &lt;input type=&quot;text&quot; v-model=&quot;msg&quot;&gt;</span><br><span class=\"line\">        &lt;div&gt;&#123;&#123;msg&#125;&#125;---&#123;&#123;info&#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    const mv = new MyVue(&#123;</span><br><span class=\"line\">        el: &#x27;#app&#x27;,</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">            msg: &#x27;hello&#x27;,</span><br><span class=\"line\">            info: &#x27;world&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n照葫芦画瓢，通过script标签引入我们的Myvue文件，然后在底部实例化mv。入参的名称参考vue。<br>样子有了，具体页面呢？<br>具体页面长这样：<img src=\"/img/vue_basic_1.jpg\" alt=\"主页面结构\" width=\"500\"></li>\n</ol>\n<p>其中输入框通过v-model绑定变量msg，另一个文本绑定了info。可为什么原样显示呢？废话，应为我们还啥都没做。目前的Myvue代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyVue</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">vm</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">vm</span> = vm</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">$data</span> = vm.<span class=\"property\">data</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">$el</span> = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(vm.<span class=\"property\">el</span>)</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Compile</span>(<span class=\"variable language_\">this</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Myvue就是一个class类，其中拥有三个属性，vm，当前myvue的实例，更直白的将就是描述当前组件的那个入参对象；$data: 设置的各个变量；$el: 绑定的div的dom节点。<br>vue框架的做的第一件事情，就是页面渲染完成后，能够将其中的变量msg和info变成我们设置的值，而不是上面那副模样。这个过程，就是<strong>模板编译</strong>。即：<strong>能自动的将html代码中的变量，变成对应的值</strong>。比如我们预先定义的msg应该显示为hello,还能对v-model这样的指令进行解析，让input的value变成对应变量的值…<br>注释：前端领域的<strong>编译</strong>和我们传统的计算机专业内定义的<strong>编译</strong>有些不同，但是内核精神是一致的。写过c或者java都知道，我们写的程序是一套代码，但是这套代码机器无法直接运行，因为机器只能执行二进制，此处概念的理解可以去看看《编码》这本书，他会告诉你，<strong>cpu的本质，之际就是继电器。</strong>回过头来，因为机器看不懂我们人类系的代码，所以需要<strong>编译器</strong>这个中介，将我们写的这一套代码，转换成机器能够执行的二进制代码。而前端领域中的<strong>模板编译</strong>，指的是将如上图中，页面绑定的各个变量，转换成其真实的值。顺带提一句，webpack中的各种loader也可以看成是各种编译器，如babel-loader，因为浏览器看不懂es6及其之后版本的js代码，那么babel-loader的作用就是转换之。但是总的来说，本质的精神内核是一致的：<strong>自动转换</strong>。</p>\n<h4 id=\"实现我们的编译器Compile函数，完成模板编译工作。\"><a href=\"#实现我们的编译器Compile函数，完成模板编译工作。\" class=\"headerlink\" title=\"实现我们的编译器Compile函数，完成模板编译工作。\"></a>实现我们的编译器Compile函数，完成模板编译工作。</h4><p>具体的思路很清晰，就是找出存在msg或者info这样的变量所在的地方，然后用我们vue实例对象mv的data中的数据更新。<br>首先在html文件中引入一个单独的Compile.js文件:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;./Compile.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>Compile也是一个类。入参为当前的实例对象mv。具体代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  什么叫编译模板---&gt;把template变成dom，如&#123;&#123;变量&#125;&#125;---&gt;真实的数据</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Compile</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">vm</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">vm</span> = vm</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">el</span> = vm.<span class=\"property\">$el</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> fragment = <span class=\"variable language_\">this</span>.<span class=\"title function_\">nodeToFragment</span>()</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">compile</span>(fragment)</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">vm</span>.<span class=\"property\">$el</span>.<span class=\"title function_\">appendChild</span>(fragment)</span><br><span class=\"line\">        <span class=\"comment\">// console.log(&#x27;f&#x27;, fragment)</span></span><br><span class=\"line\">        <span class=\"comment\">// 编译文档片段，解析&#123;&#123;&#125;&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 解析出&#123;&#123;&#125;&#125;,变量赋值</span></span><br><span class=\"line\">    <span class=\"title function_\">compile</span>(<span class=\"params\">fragment</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> nList = fragment.<span class=\"property\">childNodes</span></span><br><span class=\"line\">        nList.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">node</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> nType = node.<span class=\"property\">nodeType</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nType === <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">                <span class=\"variable language_\">this</span>.<span class=\"title function_\">compileText</span>(node)</span><br><span class=\"line\">                <span class=\"comment\">// 解析文本</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nType === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"variable language_\">this</span>.<span class=\"title function_\">compileElement</span>(node)</span><br><span class=\"line\">                <span class=\"comment\">// 元素节点</span></span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.<span class=\"property\">childNodes</span> &amp;&amp; node.<span class=\"property\">childNodes</span> !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"variable language_\">this</span>.<span class=\"title function_\">compile</span>(node)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">compileElement</span>(<span class=\"params\">node</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> attrs = node.<span class=\"property\">attributes</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!!attrs.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> attrsArr = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(attrs)</span><br><span class=\"line\">            attrsArr.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">att</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(att.<span class=\"property\">nodeName</span> === <span class=\"string\">&#x27;v-model&#x27;</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">const</span> val = att.<span class=\"property\">value</span></span><br><span class=\"line\">                    node.<span class=\"property\">value</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">vm</span>.<span class=\"property\">$data</span>[val]</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">compileText</span>(<span class=\"params\">node</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> con = node.<span class=\"property\">textContent</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> reg = <span class=\"regexp\">/\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/g</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(reg.<span class=\"title function_\">test</span>(con)) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(node)</span><br><span class=\"line\">            <span class=\"keyword\">const</span> newVal = con.<span class=\"title function_\">replace</span>(reg, <span class=\"function\">(<span class=\"params\">...arg</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">vm</span>.<span class=\"property\">$data</span>[arg[<span class=\"number\">1</span>]]</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            node.<span class=\"property\">textContent</span> = newVal</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">nodeToFragment</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> f = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createDocumentFragment</span>()</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">el</span>.<span class=\"property\">firstChild</span>) &#123;</span><br><span class=\"line\">            f.<span class=\"title function_\">appendChild</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">el</span>.<span class=\"property\">firstChild</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>逐一解释：</p>\n<ul>\n<li><ol>\n<li>两个属性：vm绑定实例mv，el绑定真实的dom。初始化时通过nodeToFragment方法拿到了一个输出，然后调用compile方法，其结果的输出直接被覆盖式的添加到了el中，完成编译工作。</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li><strong>nodeToFragment做了啥？</strong><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">nodeToFragment</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> f = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createDocumentFragment</span>()</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">el</span>.<span class=\"property\">firstChild</span>) &#123;</span><br><span class=\"line\">        f.<span class=\"title function_\">appendChild</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">el</span>.<span class=\"property\">firstChild</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n创建了一个文档片段，然后自毁式遍历当前的el的儿子元素，依次添加到了文档片段f中。这里需要解释的一点是，当我们将el.firstChild添加到f中后，el的firstChild会变成之前的第二个，以此类推所以称之为自毁。但是呢，dom被添加到f中后，此时页面只会少不会增。可以理解为我们暂时性的找了个盒子，专门用来存放这些真实的dom。所以nodeToFragment函数的作用，就是把所有的真实儿子节点给到了文档片段f。然后以其作为输入，调用compile。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li><strong>compile干了啥？找出所有的data中的变量</strong><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 解析出&#123;&#123;&#125;&#125;,变量赋值</span></span><br><span class=\"line\"><span class=\"title function_\">compile</span>(<span class=\"params\">fragment</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nList = fragment.<span class=\"property\">childNodes</span></span><br><span class=\"line\">    nList.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">node</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> nType = node.<span class=\"property\">nodeType</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nType === <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"title function_\">compileText</span>(node)</span><br><span class=\"line\">            <span class=\"comment\">// 解析文本</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nType === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"title function_\">compileElement</span>(node)</span><br><span class=\"line\">            <span class=\"comment\">// 元素节点</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.<span class=\"property\">childNodes</span> &amp;&amp; node.<span class=\"property\">childNodes</span> !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"title function_\">compile</span>(node)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n该函数就是一个中转函数，然后交给对应的编译节点函数处理。遍历所有的子节点，然后根据nodeType分别处理。nodeType时节点的类型字段，比如，3就是文本text，1就是元素如div。<br><strong>对于文本节点的处理：</strong><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">compileText</span>(<span class=\"params\">node</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> con = node.<span class=\"property\">textContent</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> reg = <span class=\"regexp\">/\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/g</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(reg.<span class=\"title function_\">test</span>(con)) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(node)</span><br><span class=\"line\">        <span class=\"keyword\">const</span> newVal = con.<span class=\"title function_\">replace</span>(reg, <span class=\"function\">(<span class=\"params\">...arg</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">vm</span>.<span class=\"property\">$data</span>[arg[<span class=\"number\">1</span>]]</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        node.<span class=\"property\">textContent</span> = newVal</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n通过textContent属性，获取文本节点的具体内容，然后通过正则匹配双括号的规则，匹配出变量如、等。再根据vm.$data中对应的变量值，覆盖文本节点的textContent 。<strong>至此完成文本节点的变量—&gt;值的页面赋值。</strong></li>\n</ol>\n</li>\n</ul>\n<p><strong>对于元素节点的处理：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">compileElement</span>(<span class=\"params\">node</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> attrs = node.<span class=\"property\">attributes</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!!attrs.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> attrsArr = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(attrs)</span><br><span class=\"line\">        attrsArr.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">att</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(att.<span class=\"property\">nodeName</span> === <span class=\"string\">&#x27;v-model&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">const</span> val = att.<span class=\"property\">value</span></span><br><span class=\"line\">                node.<span class=\"property\">value</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">vm</span>.<span class=\"property\">$data</span>[val]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对元素节点的解析是为了处理像v-model这样的自定应属性。通过attributes属性获取该元素的所有属性。找到v-model对应的变量名，然后改写node.value完成元素节点的变量—&gt;值的页面赋值。</p>\n<ul>\n<li><ol start=\"4\">\n<li><strong>将文档片段直接塞入容器dom—el。更新页面中的所有绑定变量数据，完成模板解析。</strong><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">vm</span>.<span class=\"property\">$el</span>.<span class=\"title function_\">appendChild</span>(fragment)</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ul>\n<img src=\"/img/vue_basic_2.png\" alt=\"插入文档片段，完成编译\" width=\"500\">\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p><strong>本文开始，我们尝试着实现一个自个儿的vue框架（简陋版本）。</strong></p>\n<ol>\n<li>首先我们的页面结构如下：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!<span class=\"variable constant_\">DOCTYPE</span> html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class=\"line\">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;My_vue&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;script src=&quot;./Compile.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=&quot;./Myvue.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=&quot;app&quot;&gt;</span><br><span class=\"line\">        &lt;input type=&quot;text&quot; v-model=&quot;msg&quot;&gt;</span><br><span class=\"line\">        &lt;div&gt;&#123;&#123;msg&#125;&#125;---&#123;&#123;info&#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    const mv = new MyVue(&#123;</span><br><span class=\"line\">        el: &#x27;#app&#x27;,</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">            msg: &#x27;hello&#x27;,</span><br><span class=\"line\">            info: &#x27;world&#x27;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n照葫芦画瓢，通过script标签引入我们的Myvue文件，然后在底部实例化mv。入参的名称参考vue。<br>样子有了，具体页面呢？<br>具体页面长这样：<img src=\"/img/vue_basic_1.jpg\" alt=\"主页面结构\" width=\"500\"></li>\n</ol>\n<p>其中输入框通过v-model绑定变量msg，另一个文本绑定了info。可为什么原样显示呢？废话，应为我们还啥都没做。目前的Myvue代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyVue</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">vm</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">vm</span> = vm</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">$data</span> = vm.<span class=\"property\">data</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">$el</span> = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(vm.<span class=\"property\">el</span>)</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Compile</span>(<span class=\"variable language_\">this</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Myvue就是一个class类，其中拥有三个属性，vm，当前myvue的实例，更直白的将就是描述当前组件的那个入参对象；$data: 设置的各个变量；$el: 绑定的div的dom节点。<br>vue框架的做的第一件事情，就是页面渲染完成后，能够将其中的变量msg和info变成我们设置的值，而不是上面那副模样。这个过程，就是<strong>模板编译</strong>。即：<strong>能自动的将html代码中的变量，变成对应的值</strong>。比如我们预先定义的msg应该显示为hello,还能对v-model这样的指令进行解析，让input的value变成对应变量的值…<br>注释：前端领域的<strong>编译</strong>和我们传统的计算机专业内定义的<strong>编译</strong>有些不同，但是内核精神是一致的。写过c或者java都知道，我们写的程序是一套代码，但是这套代码机器无法直接运行，因为机器只能执行二进制，此处概念的理解可以去看看《编码》这本书，他会告诉你，<strong>cpu的本质，之际就是继电器。</strong>回过头来，因为机器看不懂我们人类系的代码，所以需要<strong>编译器</strong>这个中介，将我们写的这一套代码，转换成机器能够执行的二进制代码。而前端领域中的<strong>模板编译</strong>，指的是将如上图中，页面绑定的各个变量，转换成其真实的值。顺带提一句，webpack中的各种loader也可以看成是各种编译器，如babel-loader，因为浏览器看不懂es6及其之后版本的js代码，那么babel-loader的作用就是转换之。但是总的来说，本质的精神内核是一致的：<strong>自动转换</strong>。</p>\n<h4 id=\"实现我们的编译器Compile函数，完成模板编译工作。\"><a href=\"#实现我们的编译器Compile函数，完成模板编译工作。\" class=\"headerlink\" title=\"实现我们的编译器Compile函数，完成模板编译工作。\"></a>实现我们的编译器Compile函数，完成模板编译工作。</h4><p>具体的思路很清晰，就是找出存在msg或者info这样的变量所在的地方，然后用我们vue实例对象mv的data中的数据更新。<br>首先在html文件中引入一个单独的Compile.js文件:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;./Compile.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>Compile也是一个类。入参为当前的实例对象mv。具体代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  什么叫编译模板---&gt;把template变成dom，如&#123;&#123;变量&#125;&#125;---&gt;真实的数据</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Compile</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">vm</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">vm</span> = vm</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">el</span> = vm.<span class=\"property\">$el</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> fragment = <span class=\"variable language_\">this</span>.<span class=\"title function_\">nodeToFragment</span>()</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">compile</span>(fragment)</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">vm</span>.<span class=\"property\">$el</span>.<span class=\"title function_\">appendChild</span>(fragment)</span><br><span class=\"line\">        <span class=\"comment\">// console.log(&#x27;f&#x27;, fragment)</span></span><br><span class=\"line\">        <span class=\"comment\">// 编译文档片段，解析&#123;&#123;&#125;&#125;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 解析出&#123;&#123;&#125;&#125;,变量赋值</span></span><br><span class=\"line\">    <span class=\"title function_\">compile</span>(<span class=\"params\">fragment</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> nList = fragment.<span class=\"property\">childNodes</span></span><br><span class=\"line\">        nList.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">node</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> nType = node.<span class=\"property\">nodeType</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nType === <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">                <span class=\"variable language_\">this</span>.<span class=\"title function_\">compileText</span>(node)</span><br><span class=\"line\">                <span class=\"comment\">// 解析文本</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nType === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"variable language_\">this</span>.<span class=\"title function_\">compileElement</span>(node)</span><br><span class=\"line\">                <span class=\"comment\">// 元素节点</span></span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.<span class=\"property\">childNodes</span> &amp;&amp; node.<span class=\"property\">childNodes</span> !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"variable language_\">this</span>.<span class=\"title function_\">compile</span>(node)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">compileElement</span>(<span class=\"params\">node</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> attrs = node.<span class=\"property\">attributes</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!!attrs.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> attrsArr = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(attrs)</span><br><span class=\"line\">            attrsArr.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">att</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(att.<span class=\"property\">nodeName</span> === <span class=\"string\">&#x27;v-model&#x27;</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">const</span> val = att.<span class=\"property\">value</span></span><br><span class=\"line\">                    node.<span class=\"property\">value</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">vm</span>.<span class=\"property\">$data</span>[val]</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">compileText</span>(<span class=\"params\">node</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> con = node.<span class=\"property\">textContent</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> reg = <span class=\"regexp\">/\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/g</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(reg.<span class=\"title function_\">test</span>(con)) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(node)</span><br><span class=\"line\">            <span class=\"keyword\">const</span> newVal = con.<span class=\"title function_\">replace</span>(reg, <span class=\"function\">(<span class=\"params\">...arg</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">vm</span>.<span class=\"property\">$data</span>[arg[<span class=\"number\">1</span>]]</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            node.<span class=\"property\">textContent</span> = newVal</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">nodeToFragment</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> f = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createDocumentFragment</span>()</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">el</span>.<span class=\"property\">firstChild</span>) &#123;</span><br><span class=\"line\">            f.<span class=\"title function_\">appendChild</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">el</span>.<span class=\"property\">firstChild</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>逐一解释：</p>\n<ul>\n<li><ol>\n<li>两个属性：vm绑定实例mv，el绑定真实的dom。初始化时通过nodeToFragment方法拿到了一个输出，然后调用compile方法，其结果的输出直接被覆盖式的添加到了el中，完成编译工作。</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li><strong>nodeToFragment做了啥？</strong><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">nodeToFragment</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> f = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createDocumentFragment</span>()</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">el</span>.<span class=\"property\">firstChild</span>) &#123;</span><br><span class=\"line\">        f.<span class=\"title function_\">appendChild</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">el</span>.<span class=\"property\">firstChild</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n创建了一个文档片段，然后自毁式遍历当前的el的儿子元素，依次添加到了文档片段f中。这里需要解释的一点是，当我们将el.firstChild添加到f中后，el的firstChild会变成之前的第二个，以此类推所以称之为自毁。但是呢，dom被添加到f中后，此时页面只会少不会增。可以理解为我们暂时性的找了个盒子，专门用来存放这些真实的dom。所以nodeToFragment函数的作用，就是把所有的真实儿子节点给到了文档片段f。然后以其作为输入，调用compile。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li><strong>compile干了啥？找出所有的data中的变量</strong><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 解析出&#123;&#123;&#125;&#125;,变量赋值</span></span><br><span class=\"line\"><span class=\"title function_\">compile</span>(<span class=\"params\">fragment</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nList = fragment.<span class=\"property\">childNodes</span></span><br><span class=\"line\">    nList.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">node</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> nType = node.<span class=\"property\">nodeType</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nType === <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"title function_\">compileText</span>(node)</span><br><span class=\"line\">            <span class=\"comment\">// 解析文本</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nType === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"title function_\">compileElement</span>(node)</span><br><span class=\"line\">            <span class=\"comment\">// 元素节点</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.<span class=\"property\">childNodes</span> &amp;&amp; node.<span class=\"property\">childNodes</span> !== <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"title function_\">compile</span>(node)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n该函数就是一个中转函数，然后交给对应的编译节点函数处理。遍历所有的子节点，然后根据nodeType分别处理。nodeType时节点的类型字段，比如，3就是文本text，1就是元素如div。<br><strong>对于文本节点的处理：</strong><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">compileText</span>(<span class=\"params\">node</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> con = node.<span class=\"property\">textContent</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> reg = <span class=\"regexp\">/\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/g</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(reg.<span class=\"title function_\">test</span>(con)) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(node)</span><br><span class=\"line\">        <span class=\"keyword\">const</span> newVal = con.<span class=\"title function_\">replace</span>(reg, <span class=\"function\">(<span class=\"params\">...arg</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">vm</span>.<span class=\"property\">$data</span>[arg[<span class=\"number\">1</span>]]</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        node.<span class=\"property\">textContent</span> = newVal</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n通过textContent属性，获取文本节点的具体内容，然后通过正则匹配双括号的规则，匹配出变量如、等。再根据vm.$data中对应的变量值，覆盖文本节点的textContent 。<strong>至此完成文本节点的变量—&gt;值的页面赋值。</strong></li>\n</ol>\n</li>\n</ul>\n<p><strong>对于元素节点的处理：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">compileElement</span>(<span class=\"params\">node</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> attrs = node.<span class=\"property\">attributes</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!!attrs.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> attrsArr = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(attrs)</span><br><span class=\"line\">        attrsArr.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">att</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(att.<span class=\"property\">nodeName</span> === <span class=\"string\">&#x27;v-model&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">const</span> val = att.<span class=\"property\">value</span></span><br><span class=\"line\">                node.<span class=\"property\">value</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">vm</span>.<span class=\"property\">$data</span>[val]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对元素节点的解析是为了处理像v-model这样的自定应属性。通过attributes属性获取该元素的所有属性。找到v-model对应的变量名，然后改写node.value完成元素节点的变量—&gt;值的页面赋值。</p>\n<ul>\n<li><ol start=\"4\">\n<li><strong>将文档片段直接塞入容器dom—el。更新页面中的所有绑定变量数据，完成模板解析。</strong><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"property\">vm</span>.<span class=\"property\">$el</span>.<span class=\"title function_\">appendChild</span>(fragment)</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ul>\n<img src=\"/img/vue_basic_2.png\" alt=\"插入文档片段，完成编译\" width=\"500\">\n"},{"title":"Vue.js系列：实现一个自己的vue续篇","date":"2023-08-09T02:30:11.000Z","_content":"\n在前文中，我们已经实现了**模板编译**的功能。即用我们自己写的vue，已经能够自动的解析页面中的变量，给予展示。那么接下来，我们要更进一步：**当变量的值变化的时候，我们能够感知到这种变化，并同步更新到视图。**\n目标拆分： **感知变化,更新视图**\n\n#### 感知变化\n通俗点说，我们需要知道变量值改变的时刻。如何实现？借助defineProperty将目标变量变成响应式。写一个类实现之：\n```javascript\nclass Obsever {\n    constructor(vm) {\n        this.vm = vm\n        this.data = vm.$data\n        this.obsever()\n    }\n    obsever() {\n        const dep = new Dep()\n        for (let key in this.data) {\n            let val = this.data[key]\n            Object.defineProperty(this.data, key, {\n                enumerable: true,\n                get() {\n                    Dep.target && dep.addSub(Dep.target)\n                    console.log('搜集依赖')\n                    return val\n                },\n                set(newVal) {\n                    console.log('触发以来')\n                    val = newVal\n                    dep.notify()\n                }\n            })\n        }\n    }\n}\n```\n关于这个前面有文章详细介绍过，不赘述。总之一句话：**在get中搜集依赖，在set中触发依赖。**\n\n#### 更新视图\n我们捕捉到了值变化的时刻，然后就需要更新视图。很简单，无非就是模板编译那一套再拿来套一套。在模板编译代码中加几行，以compileText为例：\n```javascript\n    compileText(node) {\n        const con = node.textContent\n        // const con = '{{msg}}---{{info}}'\n        const reg = /\\{\\{(.+?)\\}\\}/g\n        if(reg.test(con)) {\n            const newVal = con.replace(reg, (...arg) => {\n                // arg[1]就是data中的变量名，此处为msg、info\n                new Watcher(this.vm, arg[1], () => {\n                    const xx = con.replace(reg, (...arg) => {\n                        return this.vm.$data[arg[1]]\n                     })\n                    node.textContent = xx\n                })\n                return this.vm.$data[arg[1]]\n            })\n            node.textContent = newVal\n        }\n    }\n```\n在用正则匹配出模板中我们写的变量名时，new一个watcher。这个watcher的作用，就是当监听到变量改变时，执行update更新回调，代码如下:\n```javascript\nclass Watcher {\n    constructor(vm, key, cb) {\n        this.vm = vm\n        this.cb = cb\n        this.oldVaL = this.getOldVal(key, vm)\n    }\n    getOldVal(key, vm) {\n        Dep.target = this\n        const oldVal = compileUtil.getValue(key, vm)\n        Dep.target = null\n        return oldVal\n    }\n    update() {\n        this.cb()\n    }\n```\n我们看到，watcher的私有变量三个，分别是vm、回调函数cb和旧值oldVaL 。getOldVal函数的执行，会触发目标对象属性的get函数，等同于订阅的动作。Dep.target赋值为this，这里的this，就是当前的watcher实例。注意obsever方法中的一行关键代码：\n```javascript\nDep.target && dep.addSub(Dep.target)\n```\n**Dep.target暂存了wather实例对象，意思就是，订阅动作的触发，会把这个watcher实例塞入订阅者数组中。然后当我们改变变量值的时候，notify所有订阅者，所有的的订阅者会调用update也就是回调函数，更新页面内容。其中的dep也是一个类，如下所示：**\n```javascript\nclass Dep{\n    constructor() {\n        this.subList = []\n    }\n    addSub(watcher) {\n        console.log(watcher)\n        this.subList.push(watcher)\n    }\n    notify() {\n        console.log('当前的总wacther>>>', this.subList)\n        this.subList.forEach((sub) => {\n            sub.update()\n        })\n    }\n}\n```\n实现我们改变变量值，更新视图的需求。本文毕。","source":"_posts/Vue.js系列：实现一个自己的vue续篇.md","raw":"---\ntitle: Vue.js系列：实现一个自己的vue续篇\ncategory: 大前端剑宗专栏\ndate: 2023-08-09 10:30:11\ntags:\n---\n\n在前文中，我们已经实现了**模板编译**的功能。即用我们自己写的vue，已经能够自动的解析页面中的变量，给予展示。那么接下来，我们要更进一步：**当变量的值变化的时候，我们能够感知到这种变化，并同步更新到视图。**\n目标拆分： **感知变化,更新视图**\n\n#### 感知变化\n通俗点说，我们需要知道变量值改变的时刻。如何实现？借助defineProperty将目标变量变成响应式。写一个类实现之：\n```javascript\nclass Obsever {\n    constructor(vm) {\n        this.vm = vm\n        this.data = vm.$data\n        this.obsever()\n    }\n    obsever() {\n        const dep = new Dep()\n        for (let key in this.data) {\n            let val = this.data[key]\n            Object.defineProperty(this.data, key, {\n                enumerable: true,\n                get() {\n                    Dep.target && dep.addSub(Dep.target)\n                    console.log('搜集依赖')\n                    return val\n                },\n                set(newVal) {\n                    console.log('触发以来')\n                    val = newVal\n                    dep.notify()\n                }\n            })\n        }\n    }\n}\n```\n关于这个前面有文章详细介绍过，不赘述。总之一句话：**在get中搜集依赖，在set中触发依赖。**\n\n#### 更新视图\n我们捕捉到了值变化的时刻，然后就需要更新视图。很简单，无非就是模板编译那一套再拿来套一套。在模板编译代码中加几行，以compileText为例：\n```javascript\n    compileText(node) {\n        const con = node.textContent\n        // const con = '{{msg}}---{{info}}'\n        const reg = /\\{\\{(.+?)\\}\\}/g\n        if(reg.test(con)) {\n            const newVal = con.replace(reg, (...arg) => {\n                // arg[1]就是data中的变量名，此处为msg、info\n                new Watcher(this.vm, arg[1], () => {\n                    const xx = con.replace(reg, (...arg) => {\n                        return this.vm.$data[arg[1]]\n                     })\n                    node.textContent = xx\n                })\n                return this.vm.$data[arg[1]]\n            })\n            node.textContent = newVal\n        }\n    }\n```\n在用正则匹配出模板中我们写的变量名时，new一个watcher。这个watcher的作用，就是当监听到变量改变时，执行update更新回调，代码如下:\n```javascript\nclass Watcher {\n    constructor(vm, key, cb) {\n        this.vm = vm\n        this.cb = cb\n        this.oldVaL = this.getOldVal(key, vm)\n    }\n    getOldVal(key, vm) {\n        Dep.target = this\n        const oldVal = compileUtil.getValue(key, vm)\n        Dep.target = null\n        return oldVal\n    }\n    update() {\n        this.cb()\n    }\n```\n我们看到，watcher的私有变量三个，分别是vm、回调函数cb和旧值oldVaL 。getOldVal函数的执行，会触发目标对象属性的get函数，等同于订阅的动作。Dep.target赋值为this，这里的this，就是当前的watcher实例。注意obsever方法中的一行关键代码：\n```javascript\nDep.target && dep.addSub(Dep.target)\n```\n**Dep.target暂存了wather实例对象，意思就是，订阅动作的触发，会把这个watcher实例塞入订阅者数组中。然后当我们改变变量值的时候，notify所有订阅者，所有的的订阅者会调用update也就是回调函数，更新页面内容。其中的dep也是一个类，如下所示：**\n```javascript\nclass Dep{\n    constructor() {\n        this.subList = []\n    }\n    addSub(watcher) {\n        console.log(watcher)\n        this.subList.push(watcher)\n    }\n    notify() {\n        console.log('当前的总wacther>>>', this.subList)\n        this.subList.forEach((sub) => {\n            sub.update()\n        })\n    }\n}\n```\n实现我们改变变量值，更新视图的需求。本文毕。","slug":"Vue.js系列：实现一个自己的vue续篇","published":1,"updated":"2023-08-21T01:52:54.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxvs000ff8v72ev6hcka","content":"<p>在前文中，我们已经实现了<strong>模板编译</strong>的功能。即用我们自己写的vue，已经能够自动的解析页面中的变量，给予展示。那么接下来，我们要更进一步：<strong>当变量的值变化的时候，我们能够感知到这种变化，并同步更新到视图。</strong><br>目标拆分： <strong>感知变化,更新视图</strong></p>\n<h4 id=\"感知变化\"><a href=\"#感知变化\" class=\"headerlink\" title=\"感知变化\"></a>感知变化</h4><p>通俗点说，我们需要知道变量值改变的时刻。如何实现？借助defineProperty将目标变量变成响应式。写一个类实现之：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Obsever</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">vm</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">vm</span> = vm</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">data</span> = vm.<span class=\"property\">$data</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">obsever</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">obsever</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> dep = <span class=\"keyword\">new</span> <span class=\"title class_\">Dep</span>()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> val = <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>[key]</span><br><span class=\"line\">            <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">data</span>, key, &#123;</span><br><span class=\"line\">                <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                <span class=\"title function_\">get</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">                    <span class=\"title class_\">Dep</span>.<span class=\"property\">target</span> &amp;&amp; dep.<span class=\"title function_\">addSub</span>(<span class=\"title class_\">Dep</span>.<span class=\"property\">target</span>)</span><br><span class=\"line\">                    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;搜集依赖&#x27;</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> val</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                <span class=\"title function_\">set</span>(<span class=\"params\">newVal</span>) &#123;</span><br><span class=\"line\">                    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;触发以来&#x27;</span>)</span><br><span class=\"line\">                    val = newVal</span><br><span class=\"line\">                    dep.<span class=\"title function_\">notify</span>()</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关于这个前面有文章详细介绍过，不赘述。总之一句话：<strong>在get中搜集依赖，在set中触发依赖。</strong></p>\n<h4 id=\"更新视图\"><a href=\"#更新视图\" class=\"headerlink\" title=\"更新视图\"></a>更新视图</h4><p>我们捕捉到了值变化的时刻，然后就需要更新视图。很简单，无非就是模板编译那一套再拿来套一套。在模板编译代码中加几行，以compileText为例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">compileText</span>(<span class=\"params\">node</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> con = node.<span class=\"property\">textContent</span></span><br><span class=\"line\">    <span class=\"comment\">// const con = &#x27;&#123;&#123;msg&#125;&#125;---&#123;&#123;info&#125;&#125;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> reg = <span class=\"regexp\">/\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/g</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(reg.<span class=\"title function_\">test</span>(con)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> newVal = con.<span class=\"title function_\">replace</span>(reg, <span class=\"function\">(<span class=\"params\">...arg</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// arg[1]就是data中的变量名，此处为msg、info</span></span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Watcher</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">vm</span>, arg[<span class=\"number\">1</span>], <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">const</span> xx = con.<span class=\"title function_\">replace</span>(reg, <span class=\"function\">(<span class=\"params\">...arg</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">vm</span>.<span class=\"property\">$data</span>[arg[<span class=\"number\">1</span>]]</span><br><span class=\"line\">                 &#125;)</span><br><span class=\"line\">                node.<span class=\"property\">textContent</span> = xx</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">vm</span>.<span class=\"property\">$data</span>[arg[<span class=\"number\">1</span>]]</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        node.<span class=\"property\">textContent</span> = newVal</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在用正则匹配出模板中我们写的变量名时，new一个watcher。这个watcher的作用，就是当监听到变量改变时，执行update更新回调，代码如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Watcher</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">vm, key, cb</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">vm</span> = vm</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">cb</span> = cb</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">oldVaL</span> = <span class=\"variable language_\">this</span>.<span class=\"title function_\">getOldVal</span>(key, vm)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">getOldVal</span>(<span class=\"params\">key, vm</span>) &#123;</span><br><span class=\"line\">        <span class=\"title class_\">Dep</span>.<span class=\"property\">target</span> = <span class=\"variable language_\">this</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> oldVal = compileUtil.<span class=\"title function_\">getValue</span>(key, vm)</span><br><span class=\"line\">        <span class=\"title class_\">Dep</span>.<span class=\"property\">target</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldVal</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">update</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">cb</span>()</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>我们看到，watcher的私有变量三个，分别是vm、回调函数cb和旧值oldVaL 。getOldVal函数的执行，会触发目标对象属性的get函数，等同于订阅的动作。Dep.target赋值为this，这里的this，就是当前的watcher实例。注意obsever方法中的一行关键代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Dep</span>.<span class=\"property\">target</span> &amp;&amp; dep.<span class=\"title function_\">addSub</span>(<span class=\"title class_\">Dep</span>.<span class=\"property\">target</span>)</span><br></pre></td></tr></table></figure>\n<p><strong>Dep.target暂存了wather实例对象，意思就是，订阅动作的触发，会把这个watcher实例塞入订阅者数组中。然后当我们改变变量值的时候，notify所有订阅者，所有的的订阅者会调用update也就是回调函数，更新页面内容。其中的dep也是一个类，如下所示：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dep</span>&#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">subList</span> = []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">addSub</span>(<span class=\"params\">watcher</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(watcher)</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">subList</span>.<span class=\"title function_\">push</span>(watcher)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">notify</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;当前的总wacther&gt;&gt;&gt;&#x27;</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">subList</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">subList</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">sub</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            sub.<span class=\"title function_\">update</span>()</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现我们改变变量值，更新视图的需求。本文毕。</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>在前文中，我们已经实现了<strong>模板编译</strong>的功能。即用我们自己写的vue，已经能够自动的解析页面中的变量，给予展示。那么接下来，我们要更进一步：<strong>当变量的值变化的时候，我们能够感知到这种变化，并同步更新到视图。</strong><br>目标拆分： <strong>感知变化,更新视图</strong></p>\n<h4 id=\"感知变化\"><a href=\"#感知变化\" class=\"headerlink\" title=\"感知变化\"></a>感知变化</h4><p>通俗点说，我们需要知道变量值改变的时刻。如何实现？借助defineProperty将目标变量变成响应式。写一个类实现之：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Obsever</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">vm</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">vm</span> = vm</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">data</span> = vm.<span class=\"property\">$data</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">obsever</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">obsever</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> dep = <span class=\"keyword\">new</span> <span class=\"title class_\">Dep</span>()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> val = <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>[key]</span><br><span class=\"line\">            <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">data</span>, key, &#123;</span><br><span class=\"line\">                <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                <span class=\"title function_\">get</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">                    <span class=\"title class_\">Dep</span>.<span class=\"property\">target</span> &amp;&amp; dep.<span class=\"title function_\">addSub</span>(<span class=\"title class_\">Dep</span>.<span class=\"property\">target</span>)</span><br><span class=\"line\">                    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;搜集依赖&#x27;</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> val</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                <span class=\"title function_\">set</span>(<span class=\"params\">newVal</span>) &#123;</span><br><span class=\"line\">                    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;触发以来&#x27;</span>)</span><br><span class=\"line\">                    val = newVal</span><br><span class=\"line\">                    dep.<span class=\"title function_\">notify</span>()</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关于这个前面有文章详细介绍过，不赘述。总之一句话：<strong>在get中搜集依赖，在set中触发依赖。</strong></p>\n<h4 id=\"更新视图\"><a href=\"#更新视图\" class=\"headerlink\" title=\"更新视图\"></a>更新视图</h4><p>我们捕捉到了值变化的时刻，然后就需要更新视图。很简单，无非就是模板编译那一套再拿来套一套。在模板编译代码中加几行，以compileText为例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">compileText</span>(<span class=\"params\">node</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> con = node.<span class=\"property\">textContent</span></span><br><span class=\"line\">    <span class=\"comment\">// const con = &#x27;&#123;&#123;msg&#125;&#125;---&#123;&#123;info&#125;&#125;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> reg = <span class=\"regexp\">/\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/g</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(reg.<span class=\"title function_\">test</span>(con)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> newVal = con.<span class=\"title function_\">replace</span>(reg, <span class=\"function\">(<span class=\"params\">...arg</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// arg[1]就是data中的变量名，此处为msg、info</span></span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Watcher</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">vm</span>, arg[<span class=\"number\">1</span>], <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">const</span> xx = con.<span class=\"title function_\">replace</span>(reg, <span class=\"function\">(<span class=\"params\">...arg</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">vm</span>.<span class=\"property\">$data</span>[arg[<span class=\"number\">1</span>]]</span><br><span class=\"line\">                 &#125;)</span><br><span class=\"line\">                node.<span class=\"property\">textContent</span> = xx</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">vm</span>.<span class=\"property\">$data</span>[arg[<span class=\"number\">1</span>]]</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        node.<span class=\"property\">textContent</span> = newVal</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在用正则匹配出模板中我们写的变量名时，new一个watcher。这个watcher的作用，就是当监听到变量改变时，执行update更新回调，代码如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Watcher</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">vm, key, cb</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">vm</span> = vm</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">cb</span> = cb</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">oldVaL</span> = <span class=\"variable language_\">this</span>.<span class=\"title function_\">getOldVal</span>(key, vm)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">getOldVal</span>(<span class=\"params\">key, vm</span>) &#123;</span><br><span class=\"line\">        <span class=\"title class_\">Dep</span>.<span class=\"property\">target</span> = <span class=\"variable language_\">this</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> oldVal = compileUtil.<span class=\"title function_\">getValue</span>(key, vm)</span><br><span class=\"line\">        <span class=\"title class_\">Dep</span>.<span class=\"property\">target</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldVal</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">update</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"title function_\">cb</span>()</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>我们看到，watcher的私有变量三个，分别是vm、回调函数cb和旧值oldVaL 。getOldVal函数的执行，会触发目标对象属性的get函数，等同于订阅的动作。Dep.target赋值为this，这里的this，就是当前的watcher实例。注意obsever方法中的一行关键代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Dep</span>.<span class=\"property\">target</span> &amp;&amp; dep.<span class=\"title function_\">addSub</span>(<span class=\"title class_\">Dep</span>.<span class=\"property\">target</span>)</span><br></pre></td></tr></table></figure>\n<p><strong>Dep.target暂存了wather实例对象，意思就是，订阅动作的触发，会把这个watcher实例塞入订阅者数组中。然后当我们改变变量值的时候，notify所有订阅者，所有的的订阅者会调用update也就是回调函数，更新页面内容。其中的dep也是一个类，如下所示：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dep</span>&#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">subList</span> = []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">addSub</span>(<span class=\"params\">watcher</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(watcher)</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">subList</span>.<span class=\"title function_\">push</span>(watcher)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">notify</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;当前的总wacther&gt;&gt;&gt;&#x27;</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">subList</span>)</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">subList</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">sub</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            sub.<span class=\"title function_\">update</span>()</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现我们改变变量值，更新视图的需求。本文毕。</p>\n"},{"title":"Vue.js系列：对象的变化侦测","date":"2023-08-07T14:39:40.000Z","_content":"对于对象属性的变化侦测，是vue响应式的核心。其本质需要实现的功能：**当改变对象某属性值的时候，我们需要捕捉到这个变化。**那么vue是怎么做到的？**defineProperty**\n\n前端目前三大框架三分天下，实现响应式的方式却各有不同。angular、react属于”pull（拉）“，而vue则属于”push（推）“。两者的区别在于，拉的方式是被动的，推的方式则是主动的。当我们改变了某个对象的某个值之后,对于前者而言，框架能够知道某些状态发生了变化但是不知道具体谁发生了变化，所以此时会暴力的对比找出变化的状态，而对于后者而言，当属性值改变后，会把这个改变了的状态主动告诉框架。然后框架去通知这个状态的所有依赖。这就是为什么vue的响应式被称之为“**细粒度**”的响应式。\n\n具体实现：\n```javascript\nconst definePropertyReactive = (obj, key, val) => {\n  Object.defineProperty(obj, key, {\n    get() {\n      console.log('val>>', val)\n      return val\n    },\n    set(newVal) {\n      if (newVal === val) {\n        return\n      }\n      val = newVal\n      console.log('name值被改变')\n    }\n  })\n\n}\nconst obj = {\n  name: 'hhvcg'\n}\nconst val = obj.name\ndefinePropertyReactive(obj, 'name', val)\nobj.name = 'asdasd'\n// obj.name = 'asdasdasd'\n```\n我们给defineProperty的外层包了一层definePropertyReactive，用来存储val。对于任何一个对象，都可以用defineProperty来定义get和set。当我们读取某个对象的某个属性值时会触发get。改变该值的时候就会触发set。因此，为了实现响应式，需要做到“**在get中搜集依赖，在set中通知依赖**”。\n\n上面所说的依赖有点抽象，实质就是使用了该值的地方，比如某个组件，某个watch监听。这些依赖，我们可以简单地用一个数组来存储，于是有了下面的版本：\n```javascript\nconst definePropertyReactive = (obj, key, val) => {\n  let dep = []\n  Object.defineProperty(obj, key, {\n    get() {\n      console.log('val>>', val)\n      dep.push('张三')\n      return val\n    },\n    set(newVal) {\n      if (newVal === val) {\n        return\n      }\n      val = newVal\n      dep.forEach((suber) => {\n        suber.notify()\n      })\n      console.log('name值被改变')\n    }\n  })\n}\n```\n当然，vue2的实现，并不是简单的如上面所示的用个数组去存储所有的依赖，然后遍历通知(notify)。实际上在这中间加了一层watcher中转站。**就是由watcher搜集变化，然后挨个通知所有的依赖**。\n\n我想稍微懂点设计模式的同学已经看出来，这里的实现，实际上就是一个典型的发布订阅模式。\n好了，我们目前为止，只是实现了对象的某个属性的响应式，下面要做的很显然，就是将对象的所有属性变成响应式的。方法很清晰：遍历执行上述操作。如下代码所示：\n```javascript\nclass Observer {\n  constructor(obj) {\n    this.obj = obj\n    if (!Array.isArray(obj)) {\n      this.walk(obj)\n    }\n  }\n  walk(obj) {\n    const keys = Object.keys(obj)\n    keys.forEach((key) => {\n      definePropertyReactive(obj, key, obj[key])\n    })\n  }\n  \n}\n\nconst definePropertyReactive = (obj, key, val) => {\n  if (typeof obj[key] === 'object') {\n    new Observer(obj[key])\n  }\n  let dep = []\n  Object.defineProperty(obj, key, {\n    get() {\n      console.log('val>>', val)\n      dep.push('张三')\n      return val\n    },\n    set(newVal) {\n      if (newVal === val) {\n        return\n      }\n      val = newVal\n      dep.forEach((suber) => {\n        suber.notify()\n      })\n      console.log('name值被改变')\n    }\n  })\n\n}\n\nconst obj = {\n  name: 'hhvcg'\n}\nconst val = obj.name\ndefinePropertyReactive(obj, 'name', val)\nobj.name = 'asdasd'\n// obj.name = 'asdasdasd'\n```\n注意两点，我们在Observer中需要加一个非数组的判断。同时在definePropertyReactive中判断属性值是否也为对象，是则递归walk处理。\n\n**vue2的问题：**\n我们都知道vue3版本与2版本很大的一个变动就是响应式。vue3用proxy取代了defineProperty。为什么？\n**其一**: 就是你需要提前确定好key。这导致了删除和新增属性的操作，无法监听到。官方的解决方案$set和$delete\n**其二**：如果监听的某个对象很深，如下面所示，为了监听就需要递归的处理，这会带来性能的问题。\n```javascript\nconst obj = {\n  a: {\n    b: {\n      c: {\n        d: {\n          ...\n        }\n      }\n    }\n  }\n}\n```\n**文毕**\n\n","source":"_posts/Vue.js系列：对象的变化侦测.md","raw":"---\ntitle: Vue.js系列：对象的变化侦测\ncategory: 大前端剑宗专栏\ndate: 2023-08-07 22:39:40\ntags:\n---\n对于对象属性的变化侦测，是vue响应式的核心。其本质需要实现的功能：**当改变对象某属性值的时候，我们需要捕捉到这个变化。**那么vue是怎么做到的？**defineProperty**\n\n前端目前三大框架三分天下，实现响应式的方式却各有不同。angular、react属于”pull（拉）“，而vue则属于”push（推）“。两者的区别在于，拉的方式是被动的，推的方式则是主动的。当我们改变了某个对象的某个值之后,对于前者而言，框架能够知道某些状态发生了变化但是不知道具体谁发生了变化，所以此时会暴力的对比找出变化的状态，而对于后者而言，当属性值改变后，会把这个改变了的状态主动告诉框架。然后框架去通知这个状态的所有依赖。这就是为什么vue的响应式被称之为“**细粒度**”的响应式。\n\n具体实现：\n```javascript\nconst definePropertyReactive = (obj, key, val) => {\n  Object.defineProperty(obj, key, {\n    get() {\n      console.log('val>>', val)\n      return val\n    },\n    set(newVal) {\n      if (newVal === val) {\n        return\n      }\n      val = newVal\n      console.log('name值被改变')\n    }\n  })\n\n}\nconst obj = {\n  name: 'hhvcg'\n}\nconst val = obj.name\ndefinePropertyReactive(obj, 'name', val)\nobj.name = 'asdasd'\n// obj.name = 'asdasdasd'\n```\n我们给defineProperty的外层包了一层definePropertyReactive，用来存储val。对于任何一个对象，都可以用defineProperty来定义get和set。当我们读取某个对象的某个属性值时会触发get。改变该值的时候就会触发set。因此，为了实现响应式，需要做到“**在get中搜集依赖，在set中通知依赖**”。\n\n上面所说的依赖有点抽象，实质就是使用了该值的地方，比如某个组件，某个watch监听。这些依赖，我们可以简单地用一个数组来存储，于是有了下面的版本：\n```javascript\nconst definePropertyReactive = (obj, key, val) => {\n  let dep = []\n  Object.defineProperty(obj, key, {\n    get() {\n      console.log('val>>', val)\n      dep.push('张三')\n      return val\n    },\n    set(newVal) {\n      if (newVal === val) {\n        return\n      }\n      val = newVal\n      dep.forEach((suber) => {\n        suber.notify()\n      })\n      console.log('name值被改变')\n    }\n  })\n}\n```\n当然，vue2的实现，并不是简单的如上面所示的用个数组去存储所有的依赖，然后遍历通知(notify)。实际上在这中间加了一层watcher中转站。**就是由watcher搜集变化，然后挨个通知所有的依赖**。\n\n我想稍微懂点设计模式的同学已经看出来，这里的实现，实际上就是一个典型的发布订阅模式。\n好了，我们目前为止，只是实现了对象的某个属性的响应式，下面要做的很显然，就是将对象的所有属性变成响应式的。方法很清晰：遍历执行上述操作。如下代码所示：\n```javascript\nclass Observer {\n  constructor(obj) {\n    this.obj = obj\n    if (!Array.isArray(obj)) {\n      this.walk(obj)\n    }\n  }\n  walk(obj) {\n    const keys = Object.keys(obj)\n    keys.forEach((key) => {\n      definePropertyReactive(obj, key, obj[key])\n    })\n  }\n  \n}\n\nconst definePropertyReactive = (obj, key, val) => {\n  if (typeof obj[key] === 'object') {\n    new Observer(obj[key])\n  }\n  let dep = []\n  Object.defineProperty(obj, key, {\n    get() {\n      console.log('val>>', val)\n      dep.push('张三')\n      return val\n    },\n    set(newVal) {\n      if (newVal === val) {\n        return\n      }\n      val = newVal\n      dep.forEach((suber) => {\n        suber.notify()\n      })\n      console.log('name值被改变')\n    }\n  })\n\n}\n\nconst obj = {\n  name: 'hhvcg'\n}\nconst val = obj.name\ndefinePropertyReactive(obj, 'name', val)\nobj.name = 'asdasd'\n// obj.name = 'asdasdasd'\n```\n注意两点，我们在Observer中需要加一个非数组的判断。同时在definePropertyReactive中判断属性值是否也为对象，是则递归walk处理。\n\n**vue2的问题：**\n我们都知道vue3版本与2版本很大的一个变动就是响应式。vue3用proxy取代了defineProperty。为什么？\n**其一**: 就是你需要提前确定好key。这导致了删除和新增属性的操作，无法监听到。官方的解决方案$set和$delete\n**其二**：如果监听的某个对象很深，如下面所示，为了监听就需要递归的处理，这会带来性能的问题。\n```javascript\nconst obj = {\n  a: {\n    b: {\n      c: {\n        d: {\n          ...\n        }\n      }\n    }\n  }\n}\n```\n**文毕**\n\n","slug":"Vue.js系列：对象的变化侦测","published":1,"updated":"2023-08-21T01:52:54.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxvs000hf8v71kttadul","content":"<p>对于对象属性的变化侦测，是vue响应式的核心。其本质需要实现的功能：<strong>当改变对象某属性值的时候，我们需要捕捉到这个变化。</strong>那么vue是怎么做到的？<strong>defineProperty</strong></p>\n<p>前端目前三大框架三分天下，实现响应式的方式却各有不同。angular、react属于”pull（拉）“，而vue则属于”push（推）“。两者的区别在于，拉的方式是被动的，推的方式则是主动的。当我们改变了某个对象的某个值之后,对于前者而言，框架能够知道某些状态发生了变化但是不知道具体谁发生了变化，所以此时会暴力的对比找出变化的状态，而对于后者而言，当属性值改变后，会把这个改变了的状态主动告诉框架。然后框架去通知这个状态的所有依赖。这就是为什么vue的响应式被称之为“<strong>细粒度</strong>”的响应式。</p>\n<p>具体实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">definePropertyReactive</span> = (<span class=\"params\">obj, key, val</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(obj, key, &#123;</span><br><span class=\"line\">    <span class=\"title function_\">get</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;val&gt;&gt;&#x27;</span>, val)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> val</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title function_\">set</span>(<span class=\"params\">newVal</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newVal === val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      val = newVal</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;name值被改变&#x27;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;hhvcg&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> val = obj.<span class=\"property\">name</span></span><br><span class=\"line\"><span class=\"title function_\">definePropertyReactive</span>(obj, <span class=\"string\">&#x27;name&#x27;</span>, val)</span><br><span class=\"line\">obj.<span class=\"property\">name</span> = <span class=\"string\">&#x27;asdasd&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// obj.name = &#x27;asdasdasd&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>我们给defineProperty的外层包了一层definePropertyReactive，用来存储val。对于任何一个对象，都可以用defineProperty来定义get和set。当我们读取某个对象的某个属性值时会触发get。改变该值的时候就会触发set。因此，为了实现响应式，需要做到“<strong>在get中搜集依赖，在set中通知依赖</strong>”。</p>\n<p>上面所说的依赖有点抽象，实质就是使用了该值的地方，比如某个组件，某个watch监听。这些依赖，我们可以简单地用一个数组来存储，于是有了下面的版本：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">definePropertyReactive</span> = (<span class=\"params\">obj, key, val</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> dep = []</span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(obj, key, &#123;</span><br><span class=\"line\">    <span class=\"title function_\">get</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;val&gt;&gt;&#x27;</span>, val)</span><br><span class=\"line\">      dep.<span class=\"title function_\">push</span>(<span class=\"string\">&#x27;张三&#x27;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> val</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title function_\">set</span>(<span class=\"params\">newVal</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newVal === val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      val = newVal</span><br><span class=\"line\">      dep.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">suber</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        suber.<span class=\"title function_\">notify</span>()</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;name值被改变&#x27;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然，vue2的实现，并不是简单的如上面所示的用个数组去存储所有的依赖，然后遍历通知(notify)。实际上在这中间加了一层watcher中转站。<strong>就是由watcher搜集变化，然后挨个通知所有的依赖</strong>。</p>\n<p>我想稍微懂点设计模式的同学已经看出来，这里的实现，实际上就是一个典型的发布订阅模式。<br>好了，我们目前为止，只是实现了对象的某个属性的响应式，下面要做的很显然，就是将对象的所有属性变成响应式的。方法很清晰：遍历执行上述操作。如下代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Observer</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">obj</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">obj</span> = obj</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>(obj)) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">walk</span>(obj)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">walk</span>(<span class=\"params\">obj</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> keys = <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(obj)</span><br><span class=\"line\">    keys.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">definePropertyReactive</span>(obj, key, obj[key])</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">definePropertyReactive</span> = (<span class=\"params\">obj, key, val</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> obj[key] === <span class=\"string\">&#x27;object&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Observer</span>(obj[key])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> dep = []</span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(obj, key, &#123;</span><br><span class=\"line\">    <span class=\"title function_\">get</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;val&gt;&gt;&#x27;</span>, val)</span><br><span class=\"line\">      dep.<span class=\"title function_\">push</span>(<span class=\"string\">&#x27;张三&#x27;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> val</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title function_\">set</span>(<span class=\"params\">newVal</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newVal === val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      val = newVal</span><br><span class=\"line\">      dep.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">suber</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        suber.<span class=\"title function_\">notify</span>()</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;name值被改变&#x27;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;hhvcg&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> val = obj.<span class=\"property\">name</span></span><br><span class=\"line\"><span class=\"title function_\">definePropertyReactive</span>(obj, <span class=\"string\">&#x27;name&#x27;</span>, val)</span><br><span class=\"line\">obj.<span class=\"property\">name</span> = <span class=\"string\">&#x27;asdasd&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// obj.name = &#x27;asdasdasd&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>注意两点，我们在Observer中需要加一个非数组的判断。同时在definePropertyReactive中判断属性值是否也为对象，是则递归walk处理。</p>\n<p><strong>vue2的问题：</strong><br>我们都知道vue3版本与2版本很大的一个变动就是响应式。vue3用proxy取代了defineProperty。为什么？<br><strong>其一</strong>: 就是你需要提前确定好key。这导致了删除和新增属性的操作，无法监听到。官方的解决方案$set和$delete<br><strong>其二</strong>：如果监听的某个对象很深，如下面所示，为了监听就需要递归的处理，这会带来性能的问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">c</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">d</span>: &#123;</span><br><span class=\"line\">          ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>文毕</strong></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>对于对象属性的变化侦测，是vue响应式的核心。其本质需要实现的功能：<strong>当改变对象某属性值的时候，我们需要捕捉到这个变化。</strong>那么vue是怎么做到的？<strong>defineProperty</strong></p>\n<p>前端目前三大框架三分天下，实现响应式的方式却各有不同。angular、react属于”pull（拉）“，而vue则属于”push（推）“。两者的区别在于，拉的方式是被动的，推的方式则是主动的。当我们改变了某个对象的某个值之后,对于前者而言，框架能够知道某些状态发生了变化但是不知道具体谁发生了变化，所以此时会暴力的对比找出变化的状态，而对于后者而言，当属性值改变后，会把这个改变了的状态主动告诉框架。然后框架去通知这个状态的所有依赖。这就是为什么vue的响应式被称之为“<strong>细粒度</strong>”的响应式。</p>\n<p>具体实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">definePropertyReactive</span> = (<span class=\"params\">obj, key, val</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(obj, key, &#123;</span><br><span class=\"line\">    <span class=\"title function_\">get</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;val&gt;&gt;&#x27;</span>, val)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> val</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title function_\">set</span>(<span class=\"params\">newVal</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newVal === val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      val = newVal</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;name值被改变&#x27;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;hhvcg&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> val = obj.<span class=\"property\">name</span></span><br><span class=\"line\"><span class=\"title function_\">definePropertyReactive</span>(obj, <span class=\"string\">&#x27;name&#x27;</span>, val)</span><br><span class=\"line\">obj.<span class=\"property\">name</span> = <span class=\"string\">&#x27;asdasd&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// obj.name = &#x27;asdasdasd&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>我们给defineProperty的外层包了一层definePropertyReactive，用来存储val。对于任何一个对象，都可以用defineProperty来定义get和set。当我们读取某个对象的某个属性值时会触发get。改变该值的时候就会触发set。因此，为了实现响应式，需要做到“<strong>在get中搜集依赖，在set中通知依赖</strong>”。</p>\n<p>上面所说的依赖有点抽象，实质就是使用了该值的地方，比如某个组件，某个watch监听。这些依赖，我们可以简单地用一个数组来存储，于是有了下面的版本：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">definePropertyReactive</span> = (<span class=\"params\">obj, key, val</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> dep = []</span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(obj, key, &#123;</span><br><span class=\"line\">    <span class=\"title function_\">get</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;val&gt;&gt;&#x27;</span>, val)</span><br><span class=\"line\">      dep.<span class=\"title function_\">push</span>(<span class=\"string\">&#x27;张三&#x27;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> val</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title function_\">set</span>(<span class=\"params\">newVal</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newVal === val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      val = newVal</span><br><span class=\"line\">      dep.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">suber</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        suber.<span class=\"title function_\">notify</span>()</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;name值被改变&#x27;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然，vue2的实现，并不是简单的如上面所示的用个数组去存储所有的依赖，然后遍历通知(notify)。实际上在这中间加了一层watcher中转站。<strong>就是由watcher搜集变化，然后挨个通知所有的依赖</strong>。</p>\n<p>我想稍微懂点设计模式的同学已经看出来，这里的实现，实际上就是一个典型的发布订阅模式。<br>好了，我们目前为止，只是实现了对象的某个属性的响应式，下面要做的很显然，就是将对象的所有属性变成响应式的。方法很清晰：遍历执行上述操作。如下代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Observer</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">obj</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">obj</span> = obj</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>(obj)) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">walk</span>(obj)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">walk</span>(<span class=\"params\">obj</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> keys = <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(obj)</span><br><span class=\"line\">    keys.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">definePropertyReactive</span>(obj, key, obj[key])</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">definePropertyReactive</span> = (<span class=\"params\">obj, key, val</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> obj[key] === <span class=\"string\">&#x27;object&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Observer</span>(obj[key])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> dep = []</span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(obj, key, &#123;</span><br><span class=\"line\">    <span class=\"title function_\">get</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;val&gt;&gt;&#x27;</span>, val)</span><br><span class=\"line\">      dep.<span class=\"title function_\">push</span>(<span class=\"string\">&#x27;张三&#x27;</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> val</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title function_\">set</span>(<span class=\"params\">newVal</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newVal === val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      val = newVal</span><br><span class=\"line\">      dep.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">suber</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        suber.<span class=\"title function_\">notify</span>()</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;name值被改变&#x27;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;hhvcg&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> val = obj.<span class=\"property\">name</span></span><br><span class=\"line\"><span class=\"title function_\">definePropertyReactive</span>(obj, <span class=\"string\">&#x27;name&#x27;</span>, val)</span><br><span class=\"line\">obj.<span class=\"property\">name</span> = <span class=\"string\">&#x27;asdasd&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// obj.name = &#x27;asdasdasd&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>注意两点，我们在Observer中需要加一个非数组的判断。同时在definePropertyReactive中判断属性值是否也为对象，是则递归walk处理。</p>\n<p><strong>vue2的问题：</strong><br>我们都知道vue3版本与2版本很大的一个变动就是响应式。vue3用proxy取代了defineProperty。为什么？<br><strong>其一</strong>: 就是你需要提前确定好key。这导致了删除和新增属性的操作，无法监听到。官方的解决方案$set和$delete<br><strong>其二</strong>：如果监听的某个对象很深，如下面所示，为了监听就需要递归的处理，这会带来性能的问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">b</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">c</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">d</span>: &#123;</span><br><span class=\"line\">          ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>文毕</strong></p>\n"},{"title":"Vue.js系列：序章","date":"2023-08-07T14:30:17.000Z","_content":"毕业到现在快两年了，职业生涯中的项目基本都是基于vue2开发的。一直以来，注重的都是业务功能的实现，却很少关注其底层的逻辑特性。从本文开始，我会通过手头的资料，对vue2以及vue3，做一些备忘录，重点记录下其实现的基本逻辑，以及自己对其的思考。同时，因为我们也都知道，vue2.0版本，将于本年年底，也就是2023年的12月份停止维护，也算是个人对其的一个致敬吧。\n\nvue这种框架出现的结果，就是将以前jquery那样的**命令式操作dom**的方式--->**声明式的操作dom**，翻译成人话就是：**数据驱动视图，数据变，视图自动的变。同时视图由于用户的操作变化，也会更新数据。**至于怎么生成节点插入节点等dom操作，不再关心，也无需关心。\n\n举例说明：\n```javascript\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <title>Document</title>\n</head>\n<body>\n    <button id=\"add\">+</button>\n    <button id=\"sub\">-</button>\n    <span id=\"count\">0</span>\n</body>\n<script>\n    let count = 0\n    document.getElementById('add').addEventListener('click', () => {\n        count++\n        document.getElementById('count').innerText = count\n    })\n    document.getElementById('sub').addEventListener('click', () => {\n        count--\n        document.getElementById('count').innerText = count\n    })\n</script>\n</html>\n```\n上述代码用最原始的操作dom方式，实现一个简单功能，加减数字，页面如下：\n<img src=\"/img/vue1.png\" alt=\"加一减一\" width=\"500\" height=\"300\">\n加则加一，减则减一。思路很清晰：获取按钮节点绑定事件，根据不同事件，改变目标文本内容。\n\n**vue的方式：**\n```javascript\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <title>Document</title>\n</head>\n<body>\n    <div id=\"app\">\n        <button id=\"add\" @click=\"() => {count++}\">+</button>\n        <button id=\"sub\" @click=\"() => {count--}\">-</button>\n        <span id=\"count\">{{ count }}</span>\n    </div>\n</body>\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\n\n  const { createApp } = Vue\n  \n  createApp({\n    data() {\n      return {\n        count: 0\n      }\n    }\n  }).mount('#app')\n</script>\n</html>\n```\n**无需手动获取dom，数据变化，视图自动更新。**代码体验的提升，立竿见影。\n**历史小知识：**\n\n2015年10月26日，vue1.0版本发布，代码“**新世纪福音战士（Evangelion）**”\n\n2016年10月1日，vue2.0版本发布，代号“**攻壳机动队（The Ghost in the Shell）**“。奠定了框架本身的三大能力：视图层渲染、组件机制、路由机制（router）和状态管理（vuex）。该版本支持JSX、TS以及流式服务端渲染。\n\n2020年9月18日发布vue3版本,代号“**one piece(海贼王)**”","source":"_posts/Vue.js系列：序章.md","raw":"---\ntitle: Vue.js系列：序章\ncategory: 大前端剑宗专栏\ndate: 2023-08-07 22:30:17\ntags:\n---\n毕业到现在快两年了，职业生涯中的项目基本都是基于vue2开发的。一直以来，注重的都是业务功能的实现，却很少关注其底层的逻辑特性。从本文开始，我会通过手头的资料，对vue2以及vue3，做一些备忘录，重点记录下其实现的基本逻辑，以及自己对其的思考。同时，因为我们也都知道，vue2.0版本，将于本年年底，也就是2023年的12月份停止维护，也算是个人对其的一个致敬吧。\n\nvue这种框架出现的结果，就是将以前jquery那样的**命令式操作dom**的方式--->**声明式的操作dom**，翻译成人话就是：**数据驱动视图，数据变，视图自动的变。同时视图由于用户的操作变化，也会更新数据。**至于怎么生成节点插入节点等dom操作，不再关心，也无需关心。\n\n举例说明：\n```javascript\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <title>Document</title>\n</head>\n<body>\n    <button id=\"add\">+</button>\n    <button id=\"sub\">-</button>\n    <span id=\"count\">0</span>\n</body>\n<script>\n    let count = 0\n    document.getElementById('add').addEventListener('click', () => {\n        count++\n        document.getElementById('count').innerText = count\n    })\n    document.getElementById('sub').addEventListener('click', () => {\n        count--\n        document.getElementById('count').innerText = count\n    })\n</script>\n</html>\n```\n上述代码用最原始的操作dom方式，实现一个简单功能，加减数字，页面如下：\n<img src=\"/img/vue1.png\" alt=\"加一减一\" width=\"500\" height=\"300\">\n加则加一，减则减一。思路很清晰：获取按钮节点绑定事件，根据不同事件，改变目标文本内容。\n\n**vue的方式：**\n```javascript\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <title>Document</title>\n</head>\n<body>\n    <div id=\"app\">\n        <button id=\"add\" @click=\"() => {count++}\">+</button>\n        <button id=\"sub\" @click=\"() => {count--}\">-</button>\n        <span id=\"count\">{{ count }}</span>\n    </div>\n</body>\n<script src=\"https://unpkg.com/vue@3/dist/vue.global.js\"></script>\n<script>\n\n  const { createApp } = Vue\n  \n  createApp({\n    data() {\n      return {\n        count: 0\n      }\n    }\n  }).mount('#app')\n</script>\n</html>\n```\n**无需手动获取dom，数据变化，视图自动更新。**代码体验的提升，立竿见影。\n**历史小知识：**\n\n2015年10月26日，vue1.0版本发布，代码“**新世纪福音战士（Evangelion）**”\n\n2016年10月1日，vue2.0版本发布，代号“**攻壳机动队（The Ghost in the Shell）**“。奠定了框架本身的三大能力：视图层渲染、组件机制、路由机制（router）和状态管理（vuex）。该版本支持JSX、TS以及流式服务端渲染。\n\n2020年9月18日发布vue3版本,代号“**one piece(海贼王)**”","slug":"Vue.js系列：序章","published":1,"updated":"2023-08-21T01:52:54.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxvt000kf8v727pq7ums","content":"<p>毕业到现在快两年了，职业生涯中的项目基本都是基于vue2开发的。一直以来，注重的都是业务功能的实现，却很少关注其底层的逻辑特性。从本文开始，我会通过手头的资料，对vue2以及vue3，做一些备忘录，重点记录下其实现的基本逻辑，以及自己对其的思考。同时，因为我们也都知道，vue2.0版本，将于本年年底，也就是2023年的12月份停止维护，也算是个人对其的一个致敬吧。</p>\n<p>vue这种框架出现的结果，就是将以前jquery那样的<strong>命令式操作dom</strong>的方式—&gt;<strong>声明式的操作dom</strong>，翻译成人话就是：<strong>数据驱动视图，数据变，视图自动的变。同时视图由于用户的操作变化，也会更新数据。</strong>至于怎么生成节点插入节点等dom操作，不再关心，也无需关心。</p>\n<p>举例说明：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!<span class=\"variable constant_\">DOCTYPE</span> html&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;add&quot;</span>&gt;</span>+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;sub&quot;</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;count&quot;</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"keyword\">let</span> count = <span class=\"number\">0</span></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;add&#x27;</span>).<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">        count++</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">        <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;count&#x27;</span>).<span class=\"property\">innerText</span> = count</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    &#125;)</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;sub&#x27;</span>).<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">        count--</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">        <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;count&#x27;</span>).<span class=\"property\">innerText</span> = count</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    &#125;)</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>上述代码用最原始的操作dom方式，实现一个简单功能，加减数字，页面如下：<br><img src=\"/img/vue1.png\" alt=\"加一减一\" width=\"500\" height=\"300\"><br>加则加一，减则减一。思路很清晰：获取按钮节点绑定事件，根据不同事件，改变目标文本内容。</p>\n<p><strong>vue的方式：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!<span class=\"variable constant_\">DOCTYPE</span> html&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;add&quot;</span> @<span class=\"attr\">click</span>=<span class=\"string\">&quot;() =&gt; &#123;count++&#125;&quot;</span>&gt;</span>+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;sub&quot;</span> @<span class=\"attr\">click</span>=<span class=\"string\">&quot;() =&gt; &#123;count--&#125;&quot;</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;count&quot;</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"keyword\">const</span> &#123; createApp &#125; = <span class=\"title class_\">Vue</span></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  </span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"title function_\">createApp</span>(&#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"title function_\">data</span>(<span class=\"params\"></span>) &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      <span class=\"keyword\">return</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">        <span class=\"attr\">count</span>: <span class=\"number\">0</span></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      &#125;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    &#125;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  &#125;).<span class=\"title function_\">mount</span>(<span class=\"string\">&#x27;#app&#x27;</span>)</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p><strong>无需手动获取dom，数据变化，视图自动更新。</strong>代码体验的提升，立竿见影。<br><strong>历史小知识：</strong></p>\n<p>2015年10月26日，vue1.0版本发布，代码“<strong>新世纪福音战士（Evangelion）</strong>”</p>\n<p>2016年10月1日，vue2.0版本发布，代号“<strong>攻壳机动队（The Ghost in the Shell）</strong>“。奠定了框架本身的三大能力：视图层渲染、组件机制、路由机制（router）和状态管理（vuex）。该版本支持JSX、TS以及流式服务端渲染。</p>\n<p>2020年9月18日发布vue3版本,代号“**one piece(海贼王)**”</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>毕业到现在快两年了，职业生涯中的项目基本都是基于vue2开发的。一直以来，注重的都是业务功能的实现，却很少关注其底层的逻辑特性。从本文开始，我会通过手头的资料，对vue2以及vue3，做一些备忘录，重点记录下其实现的基本逻辑，以及自己对其的思考。同时，因为我们也都知道，vue2.0版本，将于本年年底，也就是2023年的12月份停止维护，也算是个人对其的一个致敬吧。</p>\n<p>vue这种框架出现的结果，就是将以前jquery那样的<strong>命令式操作dom</strong>的方式—&gt;<strong>声明式的操作dom</strong>，翻译成人话就是：<strong>数据驱动视图，数据变，视图自动的变。同时视图由于用户的操作变化，也会更新数据。</strong>至于怎么生成节点插入节点等dom操作，不再关心，也无需关心。</p>\n<p>举例说明：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!<span class=\"variable constant_\">DOCTYPE</span> html&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;add&quot;</span>&gt;</span>+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;sub&quot;</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;count&quot;</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"keyword\">let</span> count = <span class=\"number\">0</span></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;add&#x27;</span>).<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">        count++</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">        <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;count&#x27;</span>).<span class=\"property\">innerText</span> = count</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    &#125;)</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;sub&#x27;</span>).<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">        count--</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">        <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;count&#x27;</span>).<span class=\"property\">innerText</span> = count</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    &#125;)</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>上述代码用最原始的操作dom方式，实现一个简单功能，加减数字，页面如下：<br><img src=\"/img/vue1.png\" alt=\"加一减一\" width=\"500\" height=\"300\"><br>加则加一，减则减一。思路很清晰：获取按钮节点绑定事件，根据不同事件，改变目标文本内容。</p>\n<p><strong>vue的方式：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!<span class=\"variable constant_\">DOCTYPE</span> html&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;add&quot;</span> @<span class=\"attr\">click</span>=<span class=\"string\">&quot;() =&gt; &#123;count++&#125;&quot;</span>&gt;</span>+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;sub&quot;</span> @<span class=\"attr\">click</span>=<span class=\"string\">&quot;() =&gt; &#123;count--&#125;&quot;</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;count&quot;</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"keyword\">const</span> &#123; createApp &#125; = <span class=\"title class_\">Vue</span></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  </span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  <span class=\"title function_\">createApp</span>(&#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    <span class=\"title function_\">data</span>(<span class=\"params\"></span>) &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      <span class=\"keyword\">return</span> &#123;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">        <span class=\"attr\">count</span>: <span class=\"number\">0</span></span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">      &#125;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">    &#125;</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\">  &#125;).<span class=\"title function_\">mount</span>(<span class=\"string\">&#x27;#app&#x27;</span>)</span></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"language-xml\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p><strong>无需手动获取dom，数据变化，视图自动更新。</strong>代码体验的提升，立竿见影。<br><strong>历史小知识：</strong></p>\n<p>2015年10月26日，vue1.0版本发布，代码“<strong>新世纪福音战士（Evangelion）</strong>”</p>\n<p>2016年10月1日，vue2.0版本发布，代号“<strong>攻壳机动队（The Ghost in the Shell）</strong>“。奠定了框架本身的三大能力：视图层渲染、组件机制、路由机制（router）和状态管理（vuex）。该版本支持JSX、TS以及流式服务端渲染。</p>\n<p>2020年9月18日发布vue3版本,代号“**one piece(海贼王)**”</p>\n"},{"title":"Vue.js系列：数组变化的侦测","date":"2023-08-10T15:53:01.000Z","_content":"**本文详细介绍vue2，对于数组变化的侦测**\nvue2中针对数组的响应式，跟对象的响应式还是有些区别的，总的原则还是那句话：**getter中搜集依赖，setter中触发依赖。**，但是数组可以调用push等这些能够添加删除数据的api，变更数据。再介绍对象的属性监听时说过，这种操作无法捕捉到，所以vue单独用$set和$delete处理。那么针对数组，vue2又是如何处理的呢？\n\nvue2针对数组，做了一层拦截器。即：当通过那些api变更数据时，实际触发的是我们自己写的函数，然后再走原生方法，这样，每次变更，走我们自己的方法时，就可以执行触发依赖的操作。\n示例代码如下：\n```javascript\nconst data = [1,2,3,4]\nfor (let key in data) {\n  let val = data[key]\n  Object.defineProperty(data, key, {\n      enumerable: true,\n      get() {\n          console.log('搜集以来')\n          return val\n      },\n      set(newVal) {\n          console.log('触发以来')\n          val = newVal\n      }\n  })\n}\nconst oldProto = Array.prototype\nconst newProto = Object.create(Array.prototype)\n\n;['push', 'pop'].forEach(method => {\n  newProto[method] = function(...args) {\n    console.log('gengxing')\n    oldProto[method].apply(this, args)\n  } \n});\ndata.__proto__ = newProto\n\ndata.pop()\n```\n可以清楚地看到：\n**第一步：** 还是通过defineProperty响应化数组已经存在的值。\n**第二步：** 以Array的原型对象创建了一个新的原型对象。然后遍历所有支持的方法，将其改成我们自己能够控制的function。\n在该function中，除了通过apply复用原生方法，还可以做一些我们想做的事情：比如**通知依赖**\n**最后：** 当然最重要的，就是将data数组数据的原型改成我们自己的新的原型，就是我们开篇说的拦截器。\n","source":"_posts/Vue.js系列：数组变化的侦测.md","raw":"---\ntitle: Vue.js系列：数组变化的侦测\ndate: 2023-08-10 23:53:01\ncategory: 大前端剑宗专栏\ntags:\n---\n**本文详细介绍vue2，对于数组变化的侦测**\nvue2中针对数组的响应式，跟对象的响应式还是有些区别的，总的原则还是那句话：**getter中搜集依赖，setter中触发依赖。**，但是数组可以调用push等这些能够添加删除数据的api，变更数据。再介绍对象的属性监听时说过，这种操作无法捕捉到，所以vue单独用$set和$delete处理。那么针对数组，vue2又是如何处理的呢？\n\nvue2针对数组，做了一层拦截器。即：当通过那些api变更数据时，实际触发的是我们自己写的函数，然后再走原生方法，这样，每次变更，走我们自己的方法时，就可以执行触发依赖的操作。\n示例代码如下：\n```javascript\nconst data = [1,2,3,4]\nfor (let key in data) {\n  let val = data[key]\n  Object.defineProperty(data, key, {\n      enumerable: true,\n      get() {\n          console.log('搜集以来')\n          return val\n      },\n      set(newVal) {\n          console.log('触发以来')\n          val = newVal\n      }\n  })\n}\nconst oldProto = Array.prototype\nconst newProto = Object.create(Array.prototype)\n\n;['push', 'pop'].forEach(method => {\n  newProto[method] = function(...args) {\n    console.log('gengxing')\n    oldProto[method].apply(this, args)\n  } \n});\ndata.__proto__ = newProto\n\ndata.pop()\n```\n可以清楚地看到：\n**第一步：** 还是通过defineProperty响应化数组已经存在的值。\n**第二步：** 以Array的原型对象创建了一个新的原型对象。然后遍历所有支持的方法，将其改成我们自己能够控制的function。\n在该function中，除了通过apply复用原生方法，还可以做一些我们想做的事情：比如**通知依赖**\n**最后：** 当然最重要的，就是将data数组数据的原型改成我们自己的新的原型，就是我们开篇说的拦截器。\n","slug":"Vue.js系列：数组变化的侦测","published":1,"updated":"2023-08-21T01:52:54.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxvu000lf8v7a29sh17q","content":"<p><strong>本文详细介绍vue2，对于数组变化的侦测</strong><br>vue2中针对数组的响应式，跟对象的响应式还是有些区别的，总的原则还是那句话：<strong>getter中搜集依赖，setter中触发依赖。</strong>，但是数组可以调用push等这些能够添加删除数据的api，变更数据。再介绍对象的属性监听时说过，这种操作无法捕捉到，所以vue单独用$set和$delete处理。那么针对数组，vue2又是如何处理的呢？</p>\n<p>vue2针对数组，做了一层拦截器。即：当通过那些api变更数据时，实际触发的是我们自己写的函数，然后再走原生方法，这样，每次变更，走我们自己的方法时，就可以执行触发依赖的操作。<br>示例代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> data = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> data) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> val = data[key]</span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(data, key, &#123;</span><br><span class=\"line\">      <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"title function_\">get</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">          <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;搜集以来&#x27;</span>)</span><br><span class=\"line\">          <span class=\"keyword\">return</span> val</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"title function_\">set</span>(<span class=\"params\">newVal</span>) &#123;</span><br><span class=\"line\">          <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;触发以来&#x27;</span>)</span><br><span class=\"line\">          val = newVal</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> oldProto = <span class=\"title class_\">Array</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span></span><br><span class=\"line\"><span class=\"keyword\">const</span> newProto = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(<span class=\"title class_\">Array</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>)</span><br><span class=\"line\"></span><br><span class=\"line\">;[<span class=\"string\">&#x27;push&#x27;</span>, <span class=\"string\">&#x27;pop&#x27;</span>].<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">method</span> =&gt;</span> &#123;</span><br><span class=\"line\">  newProto[method] = <span class=\"keyword\">function</span>(<span class=\"params\">...args</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;gengxing&#x27;</span>)</span><br><span class=\"line\">    oldProto[method].<span class=\"title function_\">apply</span>(<span class=\"variable language_\">this</span>, args)</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">data.<span class=\"property\">__proto__</span> = newProto</span><br><span class=\"line\"></span><br><span class=\"line\">data.<span class=\"title function_\">pop</span>()</span><br></pre></td></tr></table></figure>\n<p>可以清楚地看到：<br><strong>第一步：</strong> 还是通过defineProperty响应化数组已经存在的值。<br><strong>第二步：</strong> 以Array的原型对象创建了一个新的原型对象。然后遍历所有支持的方法，将其改成我们自己能够控制的function。<br>在该function中，除了通过apply复用原生方法，还可以做一些我们想做的事情：比如<strong>通知依赖</strong><br><strong>最后：</strong> 当然最重要的，就是将data数组数据的原型改成我们自己的新的原型，就是我们开篇说的拦截器。</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p><strong>本文详细介绍vue2，对于数组变化的侦测</strong><br>vue2中针对数组的响应式，跟对象的响应式还是有些区别的，总的原则还是那句话：<strong>getter中搜集依赖，setter中触发依赖。</strong>，但是数组可以调用push等这些能够添加删除数据的api，变更数据。再介绍对象的属性监听时说过，这种操作无法捕捉到，所以vue单独用$set和$delete处理。那么针对数组，vue2又是如何处理的呢？</p>\n<p>vue2针对数组，做了一层拦截器。即：当通过那些api变更数据时，实际触发的是我们自己写的函数，然后再走原生方法，这样，每次变更，走我们自己的方法时，就可以执行触发依赖的操作。<br>示例代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> data = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> data) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> val = data[key]</span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(data, key, &#123;</span><br><span class=\"line\">      <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"title function_\">get</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">          <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;搜集以来&#x27;</span>)</span><br><span class=\"line\">          <span class=\"keyword\">return</span> val</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"title function_\">set</span>(<span class=\"params\">newVal</span>) &#123;</span><br><span class=\"line\">          <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;触发以来&#x27;</span>)</span><br><span class=\"line\">          val = newVal</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> oldProto = <span class=\"title class_\">Array</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span></span><br><span class=\"line\"><span class=\"keyword\">const</span> newProto = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(<span class=\"title class_\">Array</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>)</span><br><span class=\"line\"></span><br><span class=\"line\">;[<span class=\"string\">&#x27;push&#x27;</span>, <span class=\"string\">&#x27;pop&#x27;</span>].<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">method</span> =&gt;</span> &#123;</span><br><span class=\"line\">  newProto[method] = <span class=\"keyword\">function</span>(<span class=\"params\">...args</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;gengxing&#x27;</span>)</span><br><span class=\"line\">    oldProto[method].<span class=\"title function_\">apply</span>(<span class=\"variable language_\">this</span>, args)</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">data.<span class=\"property\">__proto__</span> = newProto</span><br><span class=\"line\"></span><br><span class=\"line\">data.<span class=\"title function_\">pop</span>()</span><br></pre></td></tr></table></figure>\n<p>可以清楚地看到：<br><strong>第一步：</strong> 还是通过defineProperty响应化数组已经存在的值。<br><strong>第二步：</strong> 以Array的原型对象创建了一个新的原型对象。然后遍历所有支持的方法，将其改成我们自己能够控制的function。<br>在该function中，除了通过apply复用原生方法，还可以做一些我们想做的事情：比如<strong>通知依赖</strong><br><strong>最后：</strong> 当然最重要的，就是将data数组数据的原型改成我们自己的新的原型，就是我们开篇说的拦截器。</p>\n"},{"title":"Vue.js系列：虚拟dom","date":"2023-08-07T15:45:28.000Z","_content":"**首先开宗明义，为什么要用虚拟DOM？**\n理论上来讲，任何状态改变后，我们完全可以粗暴的根据当前的状态，生成对应的dom，就像jquery时代那样。但是设想一个场景：有一个ul下面绑着是个li标签。我们可能只是改变了其中的一个li，就是说此时，我们只需要更新那个变化了的li即可，而不需要费劲的旧dom全删了然后再一个个重新创建一遍。\n**虚拟DOM就是为了解决这个问题，本质上做了两件事情：**\n- 1. 提供与真实dom节点对应的虚拟节点vnode（就是一个对象）\n- 2. 每次状态变化后，生成新的vnode，然后通过算法对新旧vnode对比，找出变化了的更新即可。\n重在性能优化，这也是为什么这些框架如此流行。\n\n那么具体，什么是虚拟DOM(Vnode)？\nDOM元素有元素节点（div）、文本节点（text）、注释节点等。vnode实际上就是这些节点的ADT（抽象数据类型）。\n举例解释：\n```javascript\n<p>asdasdasd</p>\nconst vnode = {\n  tag: 'p',\n  data: {...} // 比如class、style等\n  children: [...], // 儿子节点\n  ....\n}\n\n// 注释节点\n{\n  text: '注释节点',\n  isComment: true\n}\n\n\n// 文本节点\n{\n  text: '一段文本'\n}\n...\n...\n```\nvnode就是一个类，这个类拥有比如tag、text、children等属性来描述实例化的vnode。仅此而已。\n至此我们明白了虚拟DOM和真实DOM之间的映射关系，完成了第一步.下面将会介绍重点中的重点: **找出变化的patch过程**。","source":"_posts/Vue.js系列：虚拟dom.md","raw":"---\ntitle: Vue.js系列：虚拟dom\ncategory: 大前端剑宗专栏\ndate: 2023-08-07 23:45:28\ntags:\n---\n**首先开宗明义，为什么要用虚拟DOM？**\n理论上来讲，任何状态改变后，我们完全可以粗暴的根据当前的状态，生成对应的dom，就像jquery时代那样。但是设想一个场景：有一个ul下面绑着是个li标签。我们可能只是改变了其中的一个li，就是说此时，我们只需要更新那个变化了的li即可，而不需要费劲的旧dom全删了然后再一个个重新创建一遍。\n**虚拟DOM就是为了解决这个问题，本质上做了两件事情：**\n- 1. 提供与真实dom节点对应的虚拟节点vnode（就是一个对象）\n- 2. 每次状态变化后，生成新的vnode，然后通过算法对新旧vnode对比，找出变化了的更新即可。\n重在性能优化，这也是为什么这些框架如此流行。\n\n那么具体，什么是虚拟DOM(Vnode)？\nDOM元素有元素节点（div）、文本节点（text）、注释节点等。vnode实际上就是这些节点的ADT（抽象数据类型）。\n举例解释：\n```javascript\n<p>asdasdasd</p>\nconst vnode = {\n  tag: 'p',\n  data: {...} // 比如class、style等\n  children: [...], // 儿子节点\n  ....\n}\n\n// 注释节点\n{\n  text: '注释节点',\n  isComment: true\n}\n\n\n// 文本节点\n{\n  text: '一段文本'\n}\n...\n...\n```\nvnode就是一个类，这个类拥有比如tag、text、children等属性来描述实例化的vnode。仅此而已。\n至此我们明白了虚拟DOM和真实DOM之间的映射关系，完成了第一步.下面将会介绍重点中的重点: **找出变化的patch过程**。","slug":"Vue.js系列：虚拟dom","published":1,"updated":"2023-08-21T01:52:54.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxvu000of8v7ddg2763i","content":"<p><strong>首先开宗明义，为什么要用虚拟DOM？</strong><br>理论上来讲，任何状态改变后，我们完全可以粗暴的根据当前的状态，生成对应的dom，就像jquery时代那样。但是设想一个场景：有一个ul下面绑着是个li标签。我们可能只是改变了其中的一个li，就是说此时，我们只需要更新那个变化了的li即可，而不需要费劲的旧dom全删了然后再一个个重新创建一遍。<br><strong>虚拟DOM就是为了解决这个问题，本质上做了两件事情：</strong></p>\n<ul>\n<li><ol>\n<li>提供与真实dom节点对应的虚拟节点vnode（就是一个对象）</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>每次状态变化后，生成新的vnode，然后通过算法对新旧vnode对比，找出变化了的更新即可。<br>重在性能优化，这也是为什么这些框架如此流行。</li>\n</ol>\n</li>\n</ul>\n<p>那么具体，什么是虚拟DOM(Vnode)？<br>DOM元素有元素节点（div）、文本节点（text）、注释节点等。vnode实际上就是这些节点的ADT（抽象数据类型）。<br>举例解释：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;asdasdasd&lt;/p&gt;</span><br><span class=\"line\"><span class=\"keyword\">const</span> vnode = &#123;</span><br><span class=\"line\">  <span class=\"attr\">tag</span>: <span class=\"string\">&#x27;p&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">data</span>: &#123;...&#125; <span class=\"comment\">// 比如class、style等</span></span><br><span class=\"line\">  <span class=\"attr\">children</span>: [...], <span class=\"comment\">// 儿子节点</span></span><br><span class=\"line\">  ....</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注释节点</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">text</span>: <span class=\"string\">&#x27;注释节点&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">isComment</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 文本节点</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">text</span>: <span class=\"string\">&#x27;一段文本&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>vnode就是一个类，这个类拥有比如tag、text、children等属性来描述实例化的vnode。仅此而已。<br>至此我们明白了虚拟DOM和真实DOM之间的映射关系，完成了第一步.下面将会介绍重点中的重点: <strong>找出变化的patch过程</strong>。</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p><strong>首先开宗明义，为什么要用虚拟DOM？</strong><br>理论上来讲，任何状态改变后，我们完全可以粗暴的根据当前的状态，生成对应的dom，就像jquery时代那样。但是设想一个场景：有一个ul下面绑着是个li标签。我们可能只是改变了其中的一个li，就是说此时，我们只需要更新那个变化了的li即可，而不需要费劲的旧dom全删了然后再一个个重新创建一遍。<br><strong>虚拟DOM就是为了解决这个问题，本质上做了两件事情：</strong></p>\n<ul>\n<li><ol>\n<li>提供与真实dom节点对应的虚拟节点vnode（就是一个对象）</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>每次状态变化后，生成新的vnode，然后通过算法对新旧vnode对比，找出变化了的更新即可。<br>重在性能优化，这也是为什么这些框架如此流行。</li>\n</ol>\n</li>\n</ul>\n<p>那么具体，什么是虚拟DOM(Vnode)？<br>DOM元素有元素节点（div）、文本节点（text）、注释节点等。vnode实际上就是这些节点的ADT（抽象数据类型）。<br>举例解释：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;asdasdasd&lt;/p&gt;</span><br><span class=\"line\"><span class=\"keyword\">const</span> vnode = &#123;</span><br><span class=\"line\">  <span class=\"attr\">tag</span>: <span class=\"string\">&#x27;p&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">data</span>: &#123;...&#125; <span class=\"comment\">// 比如class、style等</span></span><br><span class=\"line\">  <span class=\"attr\">children</span>: [...], <span class=\"comment\">// 儿子节点</span></span><br><span class=\"line\">  ....</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注释节点</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">text</span>: <span class=\"string\">&#x27;注释节点&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">isComment</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 文本节点</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">text</span>: <span class=\"string\">&#x27;一段文本&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>vnode就是一个类，这个类拥有比如tag、text、children等属性来描述实例化的vnode。仅此而已。<br>至此我们明白了虚拟DOM和真实DOM之间的映射关系，完成了第一步.下面将会介绍重点中的重点: <strong>找出变化的patch过程</strong>。</p>\n"},{"title":"Vue.js系列：深入理解生命周期","date":"2023-08-13T07:32:14.000Z","_content":"\n我tm今天才知道，路由跳转时，旧页面的beforeDestroy，居然是在新页面的created之后。。。。\n理由很简单，倘若新页面的created逻辑太多导致页面空白。所以如此操作。。。。。\n","source":"_posts/Vue.js系列：深入理解生命周期.md","raw":"---\ntitle: Vue.js系列：深入理解生命周期\ndate: 2023-08-13 15:32:14\ntags:\ncategory: 大前端剑宗专栏\n\n---\n\n我tm今天才知道，路由跳转时，旧页面的beforeDestroy，居然是在新页面的created之后。。。。\n理由很简单，倘若新页面的created逻辑太多导致页面空白。所以如此操作。。。。。\n","slug":"Vue.js系列：深入理解生命周期","published":1,"updated":"2023-08-21T01:52:54.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxvv000pf8v7fy8cgwn3","content":"<p>我tm今天才知道，路由跳转时，旧页面的beforeDestroy，居然是在新页面的created之后。。。。<br>理由很简单，倘若新页面的created逻辑太多导致页面空白。所以如此操作。。。。。</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>我tm今天才知道，路由跳转时，旧页面的beforeDestroy，居然是在新页面的created之后。。。。<br>理由很简单，倘若新页面的created逻辑太多导致页面空白。所以如此操作。。。。。</p>\n"},{"title":"Webkit系列：第一回","date":"2023-07-27T17:13:25.000Z","_content":"本系列的目标：**尝试深入理解当前浏览器（谷歌）的大体逻辑。内容严重参考《Webkit技术内幕》**\n\n现代浏览器的渲染逻辑，就是下图的流程。\n![layoput](img/layout.webp)\n\n一个经典的面试题：从输入url到最终页面的呈现，这其中都经历了些啥？\n坦白讲这个问题很有深度也很有价值，因为完全可以根据你的描述，看出你对现代浏览器执行机制的整体把握和理解。\n\n总体可分为网页加载过程（DOMContent事件）和渲染过程（onload事件）。\n具体：\n1. 浏览器根据输入的内容做识别，如果输入的是网址，调用DNS解析目标IP，建立连接。如果是关键词，调用搜索引擎去搜索。\n2. 依赖网络模块，三次握手建立连接后获取到各种资源，包括js、html、css等等。\n3. html文件被交给HTML解释器转变成一系列词语，然后构建节点生成DOM树（树形结构的对象），css文件被交给css解释器生成样式树。在这过程中，碰到js代码，终端dom树的构建，权限会给到jscore引擎解释处理，谷歌浏览器中的就是大名鼎鼎的v8。此处涉及到进程切换。执行完js后权限交回给html解释器。当然碰到的js代码也会根据如async或者defer同步异步操作。\n4. css解释器完成工作后，会在dom树上附加解释后的样式信息，生成RenderObject树，然后转变成RenderLayer树。此时已得到绘制页面所需的绘图上下文信息，也就是图中的**layout阶段**。\n5. 最后的就是**Paint**和**Composite**两个阶段生成最终的页面。","source":"_posts/Webkit系列：第一回.md","raw":"---\ntitle: Webkit系列：第一回\ncategory: Webkit系列\ndate: 2023-07-28 01:13:25\ntags:\n---\n本系列的目标：**尝试深入理解当前浏览器（谷歌）的大体逻辑。内容严重参考《Webkit技术内幕》**\n\n现代浏览器的渲染逻辑，就是下图的流程。\n![layoput](img/layout.webp)\n\n一个经典的面试题：从输入url到最终页面的呈现，这其中都经历了些啥？\n坦白讲这个问题很有深度也很有价值，因为完全可以根据你的描述，看出你对现代浏览器执行机制的整体把握和理解。\n\n总体可分为网页加载过程（DOMContent事件）和渲染过程（onload事件）。\n具体：\n1. 浏览器根据输入的内容做识别，如果输入的是网址，调用DNS解析目标IP，建立连接。如果是关键词，调用搜索引擎去搜索。\n2. 依赖网络模块，三次握手建立连接后获取到各种资源，包括js、html、css等等。\n3. html文件被交给HTML解释器转变成一系列词语，然后构建节点生成DOM树（树形结构的对象），css文件被交给css解释器生成样式树。在这过程中，碰到js代码，终端dom树的构建，权限会给到jscore引擎解释处理，谷歌浏览器中的就是大名鼎鼎的v8。此处涉及到进程切换。执行完js后权限交回给html解释器。当然碰到的js代码也会根据如async或者defer同步异步操作。\n4. css解释器完成工作后，会在dom树上附加解释后的样式信息，生成RenderObject树，然后转变成RenderLayer树。此时已得到绘制页面所需的绘图上下文信息，也就是图中的**layout阶段**。\n5. 最后的就是**Paint**和**Composite**两个阶段生成最终的页面。","slug":"Webkit系列：第一回","published":1,"updated":"2023-08-21T01:52:54.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxvv000sf8v7fyo7ev3f","content":"<p>本系列的目标：<strong>尝试深入理解当前浏览器（谷歌）的大体逻辑。内容严重参考《Webkit技术内幕》</strong></p>\n<p>现代浏览器的渲染逻辑，就是下图的流程。<br><img src=\"/img/layout.webp\" alt=\"layoput\"></p>\n<p>一个经典的面试题：从输入url到最终页面的呈现，这其中都经历了些啥？<br>坦白讲这个问题很有深度也很有价值，因为完全可以根据你的描述，看出你对现代浏览器执行机制的整体把握和理解。</p>\n<p>总体可分为网页加载过程（DOMContent事件）和渲染过程（onload事件）。<br>具体：</p>\n<ol>\n<li>浏览器根据输入的内容做识别，如果输入的是网址，调用DNS解析目标IP，建立连接。如果是关键词，调用搜索引擎去搜索。</li>\n<li>依赖网络模块，三次握手建立连接后获取到各种资源，包括js、html、css等等。</li>\n<li>html文件被交给HTML解释器转变成一系列词语，然后构建节点生成DOM树（树形结构的对象），css文件被交给css解释器生成样式树。在这过程中，碰到js代码，终端dom树的构建，权限会给到jscore引擎解释处理，谷歌浏览器中的就是大名鼎鼎的v8。此处涉及到进程切换。执行完js后权限交回给html解释器。当然碰到的js代码也会根据如async或者defer同步异步操作。</li>\n<li>css解释器完成工作后，会在dom树上附加解释后的样式信息，生成RenderObject树，然后转变成RenderLayer树。此时已得到绘制页面所需的绘图上下文信息，也就是图中的<strong>layout阶段</strong>。</li>\n<li>最后的就是<strong>Paint</strong>和<strong>Composite</strong>两个阶段生成最终的页面。</li>\n</ol>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>本系列的目标：<strong>尝试深入理解当前浏览器（谷歌）的大体逻辑。内容严重参考《Webkit技术内幕》</strong></p>\n<p>现代浏览器的渲染逻辑，就是下图的流程。<br><img src=\"/img/layout.webp\" alt=\"layoput\"></p>\n<p>一个经典的面试题：从输入url到最终页面的呈现，这其中都经历了些啥？<br>坦白讲这个问题很有深度也很有价值，因为完全可以根据你的描述，看出你对现代浏览器执行机制的整体把握和理解。</p>\n<p>总体可分为网页加载过程（DOMContent事件）和渲染过程（onload事件）。<br>具体：</p>\n<ol>\n<li>浏览器根据输入的内容做识别，如果输入的是网址，调用DNS解析目标IP，建立连接。如果是关键词，调用搜索引擎去搜索。</li>\n<li>依赖网络模块，三次握手建立连接后获取到各种资源，包括js、html、css等等。</li>\n<li>html文件被交给HTML解释器转变成一系列词语，然后构建节点生成DOM树（树形结构的对象），css文件被交给css解释器生成样式树。在这过程中，碰到js代码，终端dom树的构建，权限会给到jscore引擎解释处理，谷歌浏览器中的就是大名鼎鼎的v8。此处涉及到进程切换。执行完js后权限交回给html解释器。当然碰到的js代码也会根据如async或者defer同步异步操作。</li>\n<li>css解释器完成工作后，会在dom树上附加解释后的样式信息，生成RenderObject树，然后转变成RenderLayer树。此时已得到绘制页面所需的绘图上下文信息，也就是图中的<strong>layout阶段</strong>。</li>\n<li>最后的就是<strong>Paint</strong>和<strong>Composite</strong>两个阶段生成最终的页面。</li>\n</ol>\n"},{"title":"Webpack系列：第一回","date":"2023-07-24T13:34:31.000Z","_content":"本文开始， 我们尝试深入理解一下前端神器webpack。最终的目标：**能够理解前端模块化，理解webpack打包的核心思路，理解webpack中的“关键人物”。解锁这三点，最终彻底掌握从而灵活运用**。\n### Webpack干啥的\n打包用的，简单说就是将项目的各种零散的文件揉成一个完整的js。比如我们的项目一共用到了a.js,b.js,c.js共三个文件，打包后就成了一个bundle.js。那问题来了，为什么要打包？**我就喜欢零散的，咋了？**\n#### 理由有二。\n- **其一**： 零散文件使用，个文件之间的依赖关系顺序，需要人为的梳理清。比如在a文件里用到了b文件的某个属性，那么，b文件就应该先于a文件加载，否则error。可想而知此等操作，项目的复杂度一上来，开发人员直接崩溃。\n- **其二**： 零散文件意味着请求的数目无限放大。那么遵循不发请求或者少发请求的终极性能准则，此方法依旧鸡肋。\n\n因此，我们的神器webpack应运而生。当然啦，除了他还有很多其他的如gulp等的工具，非独此一款。\n\n#### 那么webpack具体的能力都包括了啥？\n\n- **合并文件**。在项目中，我们可能会到处import各种依赖，这些以来又分布在各个文件中。webpack做的事情，说白了就是把所有的依赖代码，合并到一个js文件中。\n- **翻译-loader**。首先大前提，浏览器只认识js代码，而一些老版本的比如ie，他连es6的js都不认识，此时，我们就需要对自己写的ts代码或者es6代码做转换翻译处理，以使得浏览器能看得懂。例如处理样式文件的style-loader,处理es6之后的js代码的babel-loader等\n- **做点其他小动作-plugin**。例如打包过程的进度条等。\n- 最后指明一点：loader和plugin都是可插拔的，意味着不是强制使用，根据需求灵活搭配。\n\n\n\n","source":"_posts/Webpack系列：第一回.md","raw":"---\ntitle: Webpack系列：第一回\ncategory: Webpack\ndate: 2023-07-24 21:34:31\ntags:\n---\n本文开始， 我们尝试深入理解一下前端神器webpack。最终的目标：**能够理解前端模块化，理解webpack打包的核心思路，理解webpack中的“关键人物”。解锁这三点，最终彻底掌握从而灵活运用**。\n### Webpack干啥的\n打包用的，简单说就是将项目的各种零散的文件揉成一个完整的js。比如我们的项目一共用到了a.js,b.js,c.js共三个文件，打包后就成了一个bundle.js。那问题来了，为什么要打包？**我就喜欢零散的，咋了？**\n#### 理由有二。\n- **其一**： 零散文件使用，个文件之间的依赖关系顺序，需要人为的梳理清。比如在a文件里用到了b文件的某个属性，那么，b文件就应该先于a文件加载，否则error。可想而知此等操作，项目的复杂度一上来，开发人员直接崩溃。\n- **其二**： 零散文件意味着请求的数目无限放大。那么遵循不发请求或者少发请求的终极性能准则，此方法依旧鸡肋。\n\n因此，我们的神器webpack应运而生。当然啦，除了他还有很多其他的如gulp等的工具，非独此一款。\n\n#### 那么webpack具体的能力都包括了啥？\n\n- **合并文件**。在项目中，我们可能会到处import各种依赖，这些以来又分布在各个文件中。webpack做的事情，说白了就是把所有的依赖代码，合并到一个js文件中。\n- **翻译-loader**。首先大前提，浏览器只认识js代码，而一些老版本的比如ie，他连es6的js都不认识，此时，我们就需要对自己写的ts代码或者es6代码做转换翻译处理，以使得浏览器能看得懂。例如处理样式文件的style-loader,处理es6之后的js代码的babel-loader等\n- **做点其他小动作-plugin**。例如打包过程的进度条等。\n- 最后指明一点：loader和plugin都是可插拔的，意味着不是强制使用，根据需求灵活搭配。\n\n\n\n","slug":"Webpack系列：第一回","published":1,"updated":"2023-08-21T01:52:54.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxvw000tf8v7cdsu6h4j","content":"<p>本文开始， 我们尝试深入理解一下前端神器webpack。最终的目标：<strong>能够理解前端模块化，理解webpack打包的核心思路，理解webpack中的“关键人物”。解锁这三点，最终彻底掌握从而灵活运用</strong>。</p>\n<h3 id=\"Webpack干啥的\"><a href=\"#Webpack干啥的\" class=\"headerlink\" title=\"Webpack干啥的\"></a>Webpack干啥的</h3><p>打包用的，简单说就是将项目的各种零散的文件揉成一个完整的js。比如我们的项目一共用到了a.js,b.js,c.js共三个文件，打包后就成了一个bundle.js。那问题来了，为什么要打包？<strong>我就喜欢零散的，咋了？</strong></p>\n<h4 id=\"理由有二。\"><a href=\"#理由有二。\" class=\"headerlink\" title=\"理由有二。\"></a>理由有二。</h4><ul>\n<li><strong>其一</strong>： 零散文件使用，个文件之间的依赖关系顺序，需要人为的梳理清。比如在a文件里用到了b文件的某个属性，那么，b文件就应该先于a文件加载，否则error。可想而知此等操作，项目的复杂度一上来，开发人员直接崩溃。</li>\n<li><strong>其二</strong>： 零散文件意味着请求的数目无限放大。那么遵循不发请求或者少发请求的终极性能准则，此方法依旧鸡肋。</li>\n</ul>\n<p>因此，我们的神器webpack应运而生。当然啦，除了他还有很多其他的如gulp等的工具，非独此一款。</p>\n<h4 id=\"那么webpack具体的能力都包括了啥？\"><a href=\"#那么webpack具体的能力都包括了啥？\" class=\"headerlink\" title=\"那么webpack具体的能力都包括了啥？\"></a>那么webpack具体的能力都包括了啥？</h4><ul>\n<li><strong>合并文件</strong>。在项目中，我们可能会到处import各种依赖，这些以来又分布在各个文件中。webpack做的事情，说白了就是把所有的依赖代码，合并到一个js文件中。</li>\n<li><strong>翻译-loader</strong>。首先大前提，浏览器只认识js代码，而一些老版本的比如ie，他连es6的js都不认识，此时，我们就需要对自己写的ts代码或者es6代码做转换翻译处理，以使得浏览器能看得懂。例如处理样式文件的style-loader,处理es6之后的js代码的babel-loader等</li>\n<li><strong>做点其他小动作-plugin</strong>。例如打包过程的进度条等。</li>\n<li>最后指明一点：loader和plugin都是可插拔的，意味着不是强制使用，根据需求灵活搭配。</li>\n</ul>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>本文开始， 我们尝试深入理解一下前端神器webpack。最终的目标：<strong>能够理解前端模块化，理解webpack打包的核心思路，理解webpack中的“关键人物”。解锁这三点，最终彻底掌握从而灵活运用</strong>。</p>\n<h3 id=\"Webpack干啥的\"><a href=\"#Webpack干啥的\" class=\"headerlink\" title=\"Webpack干啥的\"></a>Webpack干啥的</h3><p>打包用的，简单说就是将项目的各种零散的文件揉成一个完整的js。比如我们的项目一共用到了a.js,b.js,c.js共三个文件，打包后就成了一个bundle.js。那问题来了，为什么要打包？<strong>我就喜欢零散的，咋了？</strong></p>\n<h4 id=\"理由有二。\"><a href=\"#理由有二。\" class=\"headerlink\" title=\"理由有二。\"></a>理由有二。</h4><ul>\n<li><strong>其一</strong>： 零散文件使用，个文件之间的依赖关系顺序，需要人为的梳理清。比如在a文件里用到了b文件的某个属性，那么，b文件就应该先于a文件加载，否则error。可想而知此等操作，项目的复杂度一上来，开发人员直接崩溃。</li>\n<li><strong>其二</strong>： 零散文件意味着请求的数目无限放大。那么遵循不发请求或者少发请求的终极性能准则，此方法依旧鸡肋。</li>\n</ul>\n<p>因此，我们的神器webpack应运而生。当然啦，除了他还有很多其他的如gulp等的工具，非独此一款。</p>\n<h4 id=\"那么webpack具体的能力都包括了啥？\"><a href=\"#那么webpack具体的能力都包括了啥？\" class=\"headerlink\" title=\"那么webpack具体的能力都包括了啥？\"></a>那么webpack具体的能力都包括了啥？</h4><ul>\n<li><strong>合并文件</strong>。在项目中，我们可能会到处import各种依赖，这些以来又分布在各个文件中。webpack做的事情，说白了就是把所有的依赖代码，合并到一个js文件中。</li>\n<li><strong>翻译-loader</strong>。首先大前提，浏览器只认识js代码，而一些老版本的比如ie，他连es6的js都不认识，此时，我们就需要对自己写的ts代码或者es6代码做转换翻译处理，以使得浏览器能看得懂。例如处理样式文件的style-loader,处理es6之后的js代码的babel-loader等</li>\n<li><strong>做点其他小动作-plugin</strong>。例如打包过程的进度条等。</li>\n<li>最后指明一点：loader和plugin都是可插拔的，意味着不是强制使用，根据需求灵活搭配。</li>\n</ul>\n"},{"title":"Webpack系列：第二回","date":"2023-07-24T14:23:35.000Z","_content":"\n### 前端模块化的演进历程\n模块化是webpack的基石，本文就尝试着缕一缕。\n\n####  阶段一：文件划分\n最原始的方法就是文件划分。其具体操作就是第一回中我们举的a、b、c三个js文件的例子。\n\n``` js\n//  文件内部结构：\nvar x = 100\n\nfunction A() {\n    ...\n}\n\nfunction B() {\n    ...\n}\n```\n然后通过script标签引入：\n```js\n    <script src=\"./moduaA.js\"></script>\n    <script src=\"./moduaB.js\"></script>\n    <script src=\"./moduaC.js\"></script>\n```\n该方法的弊端显而易见，所有模块共用全局作用域，命名冲突在所难免。变量全局污染，且模块之间的依赖关系很难控制\n\n#### 阶段二：命名空间\n同样还是三个文件，只是文件内部的所有内容，都是用一个对象包裹，对外使用时则通过这个对象。\n```js\nvar modulA = {\n    x = 100,\n    methodA: function A() {\n        ...\n    },\n    methodB: function B() {\n        ...\n    }\n}\n```\n相比较第一种，极大避免了变量的全局污染，但是，外部依然可以随意改变模块内部的值。\n\n#### 阶段三： IIFE:立即函数表达\n通过闭包，实现模块内部的变量方法的私有化。隐藏该隐藏的，暴露该暴露的。\n```js\nconst obj = (function () {\n    let name = 'hhvcg'\n    let old = 11\n    return {\n        tell: function() {\n            console.log('i am--->:', name)\n        }\n    }\n})()\nobj.tell()\nconsole.log(obj.name)\n\n// 标准早期写法\n(function (window) {\n    let name = 'hhvcg'\n    let old = 11\n    function tell() {\n        console.log('i am--->:', name)\n    }\n    window.modulA = { tell }\n})(window)\n```\n\n##### 上述的三种方案基本被淘汰。目前的实际开发中，前端基本是遵循es6标准，后端如果是nodejs的话，使用的就是commonjs。\n\n#### 阶段四：ES6 Module终极方案\n大家应该都很熟悉了，就不举例了\n\n那么为什么webpack系列文章，要提一提前端模块的发展史呢？原因在于，注意阶段三的IIFE实现的模块机制。大家可以留意一下webpack打包出来的bundle.js代码，**尽管很乱但是，重点在于，webpack的打包js产物，实质就是一个IIFE。**\n","source":"_posts/Webpack系列：第二回.md","raw":"---\ntitle: Webpack系列：第二回\ncategory: Webpack\ndate: 2023-07-24 22:23:35\ntags:\n---\n\n### 前端模块化的演进历程\n模块化是webpack的基石，本文就尝试着缕一缕。\n\n####  阶段一：文件划分\n最原始的方法就是文件划分。其具体操作就是第一回中我们举的a、b、c三个js文件的例子。\n\n``` js\n//  文件内部结构：\nvar x = 100\n\nfunction A() {\n    ...\n}\n\nfunction B() {\n    ...\n}\n```\n然后通过script标签引入：\n```js\n    <script src=\"./moduaA.js\"></script>\n    <script src=\"./moduaB.js\"></script>\n    <script src=\"./moduaC.js\"></script>\n```\n该方法的弊端显而易见，所有模块共用全局作用域，命名冲突在所难免。变量全局污染，且模块之间的依赖关系很难控制\n\n#### 阶段二：命名空间\n同样还是三个文件，只是文件内部的所有内容，都是用一个对象包裹，对外使用时则通过这个对象。\n```js\nvar modulA = {\n    x = 100,\n    methodA: function A() {\n        ...\n    },\n    methodB: function B() {\n        ...\n    }\n}\n```\n相比较第一种，极大避免了变量的全局污染，但是，外部依然可以随意改变模块内部的值。\n\n#### 阶段三： IIFE:立即函数表达\n通过闭包，实现模块内部的变量方法的私有化。隐藏该隐藏的，暴露该暴露的。\n```js\nconst obj = (function () {\n    let name = 'hhvcg'\n    let old = 11\n    return {\n        tell: function() {\n            console.log('i am--->:', name)\n        }\n    }\n})()\nobj.tell()\nconsole.log(obj.name)\n\n// 标准早期写法\n(function (window) {\n    let name = 'hhvcg'\n    let old = 11\n    function tell() {\n        console.log('i am--->:', name)\n    }\n    window.modulA = { tell }\n})(window)\n```\n\n##### 上述的三种方案基本被淘汰。目前的实际开发中，前端基本是遵循es6标准，后端如果是nodejs的话，使用的就是commonjs。\n\n#### 阶段四：ES6 Module终极方案\n大家应该都很熟悉了，就不举例了\n\n那么为什么webpack系列文章，要提一提前端模块的发展史呢？原因在于，注意阶段三的IIFE实现的模块机制。大家可以留意一下webpack打包出来的bundle.js代码，**尽管很乱但是，重点在于，webpack的打包js产物，实质就是一个IIFE。**\n","slug":"Webpack系列：第二回","published":1,"updated":"2023-08-21T01:52:54.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxvw000wf8v7h7ir7pmf","content":"<h3 id=\"前端模块化的演进历程\"><a href=\"#前端模块化的演进历程\" class=\"headerlink\" title=\"前端模块化的演进历程\"></a>前端模块化的演进历程</h3><p>模块化是webpack的基石，本文就尝试着缕一缕。</p>\n<h4 id=\"阶段一：文件划分\"><a href=\"#阶段一：文件划分\" class=\"headerlink\" title=\"阶段一：文件划分\"></a>阶段一：文件划分</h4><p>最原始的方法就是文件划分。其具体操作就是第一回中我们举的a、b、c三个js文件的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  文件内部结构：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">A</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">B</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后通过script标签引入：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">&quot;./moduaA.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;./moduaB.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;./moduaC.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>该方法的弊端显而易见，所有模块共用全局作用域，命名冲突在所难免。变量全局污染，且模块之间的依赖关系很难控制</p>\n<h4 id=\"阶段二：命名空间\"><a href=\"#阶段二：命名空间\" class=\"headerlink\" title=\"阶段二：命名空间\"></a>阶段二：命名空间</h4><p>同样还是三个文件，只是文件内部的所有内容，都是用一个对象包裹，对外使用时则通过这个对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> modulA = &#123;</span><br><span class=\"line\">    x = <span class=\"number\">100</span>,</span><br><span class=\"line\">    <span class=\"attr\">methodA</span>: <span class=\"keyword\">function</span> <span class=\"title function_\">A</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">methodB</span>: <span class=\"keyword\">function</span> <span class=\"title function_\">B</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相比较第一种，极大避免了变量的全局污染，但是，外部依然可以随意改变模块内部的值。</p>\n<h4 id=\"阶段三：-IIFE-立即函数表达\"><a href=\"#阶段三：-IIFE-立即函数表达\" class=\"headerlink\" title=\"阶段三： IIFE:立即函数表达\"></a>阶段三： IIFE:立即函数表达</h4><p>通过闭包，实现模块内部的变量方法的私有化。隐藏该隐藏的，暴露该暴露的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = (<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> name = <span class=\"string\">&#x27;hhvcg&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> old = <span class=\"number\">11</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"attr\">tell</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;i am---&gt;:&#x27;</span>, name)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\">obj.<span class=\"title function_\">tell</span>()</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">name</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 标准早期写法</span></span><br><span class=\"line\">(<span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"variable language_\">window</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> name = <span class=\"string\">&#x27;hhvcg&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> old = <span class=\"number\">11</span></span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">tell</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;i am---&gt;:&#x27;</span>, name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"variable language_\">window</span>.<span class=\"property\">modulA</span> = &#123; tell &#125;</span><br><span class=\"line\">&#125;)(<span class=\"variable language_\">window</span>)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"上述的三种方案基本被淘汰。目前的实际开发中，前端基本是遵循es6标准，后端如果是nodejs的话，使用的就是commonjs。\"><a href=\"#上述的三种方案基本被淘汰。目前的实际开发中，前端基本是遵循es6标准，后端如果是nodejs的话，使用的就是commonjs。\" class=\"headerlink\" title=\"上述的三种方案基本被淘汰。目前的实际开发中，前端基本是遵循es6标准，后端如果是nodejs的话，使用的就是commonjs。\"></a>上述的三种方案基本被淘汰。目前的实际开发中，前端基本是遵循es6标准，后端如果是nodejs的话，使用的就是commonjs。</h5><h4 id=\"阶段四：ES6-Module终极方案\"><a href=\"#阶段四：ES6-Module终极方案\" class=\"headerlink\" title=\"阶段四：ES6 Module终极方案\"></a>阶段四：ES6 Module终极方案</h4><p>大家应该都很熟悉了，就不举例了</p>\n<p>那么为什么webpack系列文章，要提一提前端模块的发展史呢？原因在于，注意阶段三的IIFE实现的模块机制。大家可以留意一下webpack打包出来的bundle.js代码，<strong>尽管很乱但是，重点在于，webpack的打包js产物，实质就是一个IIFE。</strong></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"前端模块化的演进历程\"><a href=\"#前端模块化的演进历程\" class=\"headerlink\" title=\"前端模块化的演进历程\"></a>前端模块化的演进历程</h3><p>模块化是webpack的基石，本文就尝试着缕一缕。</p>\n<h4 id=\"阶段一：文件划分\"><a href=\"#阶段一：文件划分\" class=\"headerlink\" title=\"阶段一：文件划分\"></a>阶段一：文件划分</h4><p>最原始的方法就是文件划分。其具体操作就是第一回中我们举的a、b、c三个js文件的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  文件内部结构：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">A</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">B</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后通过script标签引入：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">&quot;./moduaA.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;./moduaB.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;./moduaC.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>该方法的弊端显而易见，所有模块共用全局作用域，命名冲突在所难免。变量全局污染，且模块之间的依赖关系很难控制</p>\n<h4 id=\"阶段二：命名空间\"><a href=\"#阶段二：命名空间\" class=\"headerlink\" title=\"阶段二：命名空间\"></a>阶段二：命名空间</h4><p>同样还是三个文件，只是文件内部的所有内容，都是用一个对象包裹，对外使用时则通过这个对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> modulA = &#123;</span><br><span class=\"line\">    x = <span class=\"number\">100</span>,</span><br><span class=\"line\">    <span class=\"attr\">methodA</span>: <span class=\"keyword\">function</span> <span class=\"title function_\">A</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">methodB</span>: <span class=\"keyword\">function</span> <span class=\"title function_\">B</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相比较第一种，极大避免了变量的全局污染，但是，外部依然可以随意改变模块内部的值。</p>\n<h4 id=\"阶段三：-IIFE-立即函数表达\"><a href=\"#阶段三：-IIFE-立即函数表达\" class=\"headerlink\" title=\"阶段三： IIFE:立即函数表达\"></a>阶段三： IIFE:立即函数表达</h4><p>通过闭包，实现模块内部的变量方法的私有化。隐藏该隐藏的，暴露该暴露的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = (<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> name = <span class=\"string\">&#x27;hhvcg&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> old = <span class=\"number\">11</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"attr\">tell</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;i am---&gt;:&#x27;</span>, name)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\">obj.<span class=\"title function_\">tell</span>()</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">name</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 标准早期写法</span></span><br><span class=\"line\">(<span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"variable language_\">window</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> name = <span class=\"string\">&#x27;hhvcg&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> old = <span class=\"number\">11</span></span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">tell</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;i am---&gt;:&#x27;</span>, name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"variable language_\">window</span>.<span class=\"property\">modulA</span> = &#123; tell &#125;</span><br><span class=\"line\">&#125;)(<span class=\"variable language_\">window</span>)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"上述的三种方案基本被淘汰。目前的实际开发中，前端基本是遵循es6标准，后端如果是nodejs的话，使用的就是commonjs。\"><a href=\"#上述的三种方案基本被淘汰。目前的实际开发中，前端基本是遵循es6标准，后端如果是nodejs的话，使用的就是commonjs。\" class=\"headerlink\" title=\"上述的三种方案基本被淘汰。目前的实际开发中，前端基本是遵循es6标准，后端如果是nodejs的话，使用的就是commonjs。\"></a>上述的三种方案基本被淘汰。目前的实际开发中，前端基本是遵循es6标准，后端如果是nodejs的话，使用的就是commonjs。</h5><h4 id=\"阶段四：ES6-Module终极方案\"><a href=\"#阶段四：ES6-Module终极方案\" class=\"headerlink\" title=\"阶段四：ES6 Module终极方案\"></a>阶段四：ES6 Module终极方案</h4><p>大家应该都很熟悉了，就不举例了</p>\n<p>那么为什么webpack系列文章，要提一提前端模块的发展史呢？原因在于，注意阶段三的IIFE实现的模块机制。大家可以留意一下webpack打包出来的bundle.js代码，<strong>尽管很乱但是，重点在于，webpack的打包js产物，实质就是一个IIFE。</strong></p>\n"},{"title":"Webpack系列：第三回","date":"2023-07-24T14:39:47.000Z","_content":"继前文简单介绍了下前端模块发展史，以此作为铺垫，本文将会简单梳理下webpack的基本打包思路。\n\n### Webpack打包总体流程\n#### 最最精简的webpack打包文件\n```js\n(function(modules) { // webpackBootstrap\n     // The module cache已经加载过的模块\n    var installedModules = {};\n    // The require function模块加载函数， 核心\n    function __webpack_require__(moduleId) {\n        // Check if module is in cache判断模块是否已经加载过，若加载过直接返回加载的模块\n        if(installedModules[moduleId]) {\n             return installedModules[moduleId].exports;\n        }\n         // Create a new module (and put it into the cache)\n         var module = installedModules[moduleId] = {\n             i: moduleId,\n             l: false,\n            exports: {}\n         };\n\n         // Execute the module function执行加载函数\n         modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n         // Flag the module as loaded标记该模块已经加载\n        module.l = true;\n\n        // Return the exports of the module\n         return module.exports;\n     }\n     return __webpack_require__(0) //入口文件\n\n })([\n    // 依赖数组\n/* 0 */\n (function(module, exports) {\n    module.exports = \"Hello World\";\n }\n ...\n ...\n )]);\n```\n#### 1. 从入口文件开始，分析文件的所有依赖\n#### 2. 将每一个依赖模块包装起来，放进一个数组中等待调用\n- 此处的数组，就是IIFE的入参依赖数组\n#### 3. 实现模块加载的方法，并将其放入模块执行的环境中，确保可调用\n#### 4. 将执行入口文件的逻辑放在一个函数表达式中，并立即执行这个函数\n- 需要注意__webpack_require__是一个递归\n\n\n\n\n\n\n#### 补充webpack的生命周期\n\n1. `beforeRun`：Webpack 进入编译前的阶段，此时会初始化 Compiler 对象。\n2. `run`：Webpack 开始编译前的阶段，此时会读取入口文件和依赖，并创建依赖图。\n3. `compilation`：Webpack 进入编译阶段，此时会开始编译入口文件和依赖的模块，并生成输出文件。\n4. `emit`：Webpack 生成输出文件前的阶段，此时可以在插件中处理生成的输出文件。\n5. `done`：Webpack 完成打包后的阶段，此时可以在插件中进行一些清理工作。\n\n\n\n","source":"_posts/Webpack系列：第三回.md","raw":"---\ntitle: Webpack系列：第三回\ndate: 2023-07-24 22:39:47\ntags:\ncategory: Webpack\n---\n继前文简单介绍了下前端模块发展史，以此作为铺垫，本文将会简单梳理下webpack的基本打包思路。\n\n### Webpack打包总体流程\n#### 最最精简的webpack打包文件\n```js\n(function(modules) { // webpackBootstrap\n     // The module cache已经加载过的模块\n    var installedModules = {};\n    // The require function模块加载函数， 核心\n    function __webpack_require__(moduleId) {\n        // Check if module is in cache判断模块是否已经加载过，若加载过直接返回加载的模块\n        if(installedModules[moduleId]) {\n             return installedModules[moduleId].exports;\n        }\n         // Create a new module (and put it into the cache)\n         var module = installedModules[moduleId] = {\n             i: moduleId,\n             l: false,\n            exports: {}\n         };\n\n         // Execute the module function执行加载函数\n         modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n         // Flag the module as loaded标记该模块已经加载\n        module.l = true;\n\n        // Return the exports of the module\n         return module.exports;\n     }\n     return __webpack_require__(0) //入口文件\n\n })([\n    // 依赖数组\n/* 0 */\n (function(module, exports) {\n    module.exports = \"Hello World\";\n }\n ...\n ...\n )]);\n```\n#### 1. 从入口文件开始，分析文件的所有依赖\n#### 2. 将每一个依赖模块包装起来，放进一个数组中等待调用\n- 此处的数组，就是IIFE的入参依赖数组\n#### 3. 实现模块加载的方法，并将其放入模块执行的环境中，确保可调用\n#### 4. 将执行入口文件的逻辑放在一个函数表达式中，并立即执行这个函数\n- 需要注意__webpack_require__是一个递归\n\n\n\n\n\n\n#### 补充webpack的生命周期\n\n1. `beforeRun`：Webpack 进入编译前的阶段，此时会初始化 Compiler 对象。\n2. `run`：Webpack 开始编译前的阶段，此时会读取入口文件和依赖，并创建依赖图。\n3. `compilation`：Webpack 进入编译阶段，此时会开始编译入口文件和依赖的模块，并生成输出文件。\n4. `emit`：Webpack 生成输出文件前的阶段，此时可以在插件中处理生成的输出文件。\n5. `done`：Webpack 完成打包后的阶段，此时可以在插件中进行一些清理工作。\n\n\n\n","slug":"Webpack系列：第三回","published":1,"updated":"2023-08-21T01:52:54.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxvx000yf8v7axhi85xp","content":"<p>继前文简单介绍了下前端模块发展史，以此作为铺垫，本文将会简单梳理下webpack的基本打包思路。</p>\n<h3 id=\"Webpack打包总体流程\"><a href=\"#Webpack打包总体流程\" class=\"headerlink\" title=\"Webpack打包总体流程\"></a>Webpack打包总体流程</h3><h4 id=\"最最精简的webpack打包文件\"><a href=\"#最最精简的webpack打包文件\" class=\"headerlink\" title=\"最最精简的webpack打包文件\"></a>最最精简的webpack打包文件</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">function</span>(<span class=\"params\">modules</span>) &#123; <span class=\"comment\">// webpackBootstrap</span></span><br><span class=\"line\">     <span class=\"comment\">// The module cache已经加载过的模块</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> installedModules = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// The require function模块加载函数， 核心</span></span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">__webpack_require__</span>(<span class=\"params\">moduleId</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Check if module is in cache判断模块是否已经加载过，若加载过直接返回加载的模块</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(installedModules[moduleId]) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">return</span> installedModules[moduleId].<span class=\"property\">exports</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         <span class=\"comment\">// Create a new module (and put it into the cache)</span></span><br><span class=\"line\">         <span class=\"keyword\">var</span> <span class=\"variable language_\">module</span> = installedModules[moduleId] = &#123;</span><br><span class=\"line\">             <span class=\"attr\">i</span>: moduleId,</span><br><span class=\"line\">             <span class=\"attr\">l</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">exports</span>: &#123;&#125;</span><br><span class=\"line\">         &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// Execute the module function执行加载函数</span></span><br><span class=\"line\">         modules[moduleId].<span class=\"title function_\">call</span>(<span class=\"variable language_\">module</span>.<span class=\"property\">exports</span>, <span class=\"variable language_\">module</span>, <span class=\"variable language_\">module</span>.<span class=\"property\">exports</span>, __webpack_require__);</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// Flag the module as loaded标记该模块已经加载</span></span><br><span class=\"line\">        <span class=\"variable language_\">module</span>.<span class=\"property\">l</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Return the exports of the module</span></span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"variable language_\">module</span>.<span class=\"property\">exports</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"title function_\">__webpack_require__</span>(<span class=\"number\">0</span>) <span class=\"comment\">//入口文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;)([</span><br><span class=\"line\">    <span class=\"comment\">// 依赖数组</span></span><br><span class=\"line\"><span class=\"comment\">/* 0 */</span></span><br><span class=\"line\"> (<span class=\"keyword\">function</span>(<span class=\"params\"><span class=\"variable language_\">module</span>, <span class=\"built_in\">exports</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"string\">&quot;Hello World&quot;</span>;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> ...</span><br><span class=\"line\"> ...</span><br><span class=\"line\"> )]);</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-从入口文件开始，分析文件的所有依赖\"><a href=\"#1-从入口文件开始，分析文件的所有依赖\" class=\"headerlink\" title=\"1. 从入口文件开始，分析文件的所有依赖\"></a>1. 从入口文件开始，分析文件的所有依赖</h4><h4 id=\"2-将每一个依赖模块包装起来，放进一个数组中等待调用\"><a href=\"#2-将每一个依赖模块包装起来，放进一个数组中等待调用\" class=\"headerlink\" title=\"2. 将每一个依赖模块包装起来，放进一个数组中等待调用\"></a>2. 将每一个依赖模块包装起来，放进一个数组中等待调用</h4><ul>\n<li>此处的数组，就是IIFE的入参依赖数组</li>\n</ul>\n<h4 id=\"3-实现模块加载的方法，并将其放入模块执行的环境中，确保可调用\"><a href=\"#3-实现模块加载的方法，并将其放入模块执行的环境中，确保可调用\" class=\"headerlink\" title=\"3. 实现模块加载的方法，并将其放入模块执行的环境中，确保可调用\"></a>3. 实现模块加载的方法，并将其放入模块执行的环境中，确保可调用</h4><h4 id=\"4-将执行入口文件的逻辑放在一个函数表达式中，并立即执行这个函数\"><a href=\"#4-将执行入口文件的逻辑放在一个函数表达式中，并立即执行这个函数\" class=\"headerlink\" title=\"4. 将执行入口文件的逻辑放在一个函数表达式中，并立即执行这个函数\"></a>4. 将执行入口文件的逻辑放在一个函数表达式中，并立即执行这个函数</h4><ul>\n<li>需要注意__webpack_require__是一个递归</li>\n</ul>\n<h4 id=\"补充webpack的生命周期\"><a href=\"#补充webpack的生命周期\" class=\"headerlink\" title=\"补充webpack的生命周期\"></a>补充webpack的生命周期</h4><ol>\n<li><code>beforeRun</code>：Webpack 进入编译前的阶段，此时会初始化 Compiler 对象。</li>\n<li><code>run</code>：Webpack 开始编译前的阶段，此时会读取入口文件和依赖，并创建依赖图。</li>\n<li><code>compilation</code>：Webpack 进入编译阶段，此时会开始编译入口文件和依赖的模块，并生成输出文件。</li>\n<li><code>emit</code>：Webpack 生成输出文件前的阶段，此时可以在插件中处理生成的输出文件。</li>\n<li><code>done</code>：Webpack 完成打包后的阶段，此时可以在插件中进行一些清理工作。</li>\n</ol>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>继前文简单介绍了下前端模块发展史，以此作为铺垫，本文将会简单梳理下webpack的基本打包思路。</p>\n<h3 id=\"Webpack打包总体流程\"><a href=\"#Webpack打包总体流程\" class=\"headerlink\" title=\"Webpack打包总体流程\"></a>Webpack打包总体流程</h3><h4 id=\"最最精简的webpack打包文件\"><a href=\"#最最精简的webpack打包文件\" class=\"headerlink\" title=\"最最精简的webpack打包文件\"></a>最最精简的webpack打包文件</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">function</span>(<span class=\"params\">modules</span>) &#123; <span class=\"comment\">// webpackBootstrap</span></span><br><span class=\"line\">     <span class=\"comment\">// The module cache已经加载过的模块</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> installedModules = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// The require function模块加载函数， 核心</span></span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">__webpack_require__</span>(<span class=\"params\">moduleId</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Check if module is in cache判断模块是否已经加载过，若加载过直接返回加载的模块</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(installedModules[moduleId]) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">return</span> installedModules[moduleId].<span class=\"property\">exports</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         <span class=\"comment\">// Create a new module (and put it into the cache)</span></span><br><span class=\"line\">         <span class=\"keyword\">var</span> <span class=\"variable language_\">module</span> = installedModules[moduleId] = &#123;</span><br><span class=\"line\">             <span class=\"attr\">i</span>: moduleId,</span><br><span class=\"line\">             <span class=\"attr\">l</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">exports</span>: &#123;&#125;</span><br><span class=\"line\">         &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// Execute the module function执行加载函数</span></span><br><span class=\"line\">         modules[moduleId].<span class=\"title function_\">call</span>(<span class=\"variable language_\">module</span>.<span class=\"property\">exports</span>, <span class=\"variable language_\">module</span>, <span class=\"variable language_\">module</span>.<span class=\"property\">exports</span>, __webpack_require__);</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// Flag the module as loaded标记该模块已经加载</span></span><br><span class=\"line\">        <span class=\"variable language_\">module</span>.<span class=\"property\">l</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Return the exports of the module</span></span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"variable language_\">module</span>.<span class=\"property\">exports</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"title function_\">__webpack_require__</span>(<span class=\"number\">0</span>) <span class=\"comment\">//入口文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;)([</span><br><span class=\"line\">    <span class=\"comment\">// 依赖数组</span></span><br><span class=\"line\"><span class=\"comment\">/* 0 */</span></span><br><span class=\"line\"> (<span class=\"keyword\">function</span>(<span class=\"params\"><span class=\"variable language_\">module</span>, <span class=\"built_in\">exports</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"string\">&quot;Hello World&quot;</span>;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> ...</span><br><span class=\"line\"> ...</span><br><span class=\"line\"> )]);</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-从入口文件开始，分析文件的所有依赖\"><a href=\"#1-从入口文件开始，分析文件的所有依赖\" class=\"headerlink\" title=\"1. 从入口文件开始，分析文件的所有依赖\"></a>1. 从入口文件开始，分析文件的所有依赖</h4><h4 id=\"2-将每一个依赖模块包装起来，放进一个数组中等待调用\"><a href=\"#2-将每一个依赖模块包装起来，放进一个数组中等待调用\" class=\"headerlink\" title=\"2. 将每一个依赖模块包装起来，放进一个数组中等待调用\"></a>2. 将每一个依赖模块包装起来，放进一个数组中等待调用</h4><ul>\n<li>此处的数组，就是IIFE的入参依赖数组</li>\n</ul>\n<h4 id=\"3-实现模块加载的方法，并将其放入模块执行的环境中，确保可调用\"><a href=\"#3-实现模块加载的方法，并将其放入模块执行的环境中，确保可调用\" class=\"headerlink\" title=\"3. 实现模块加载的方法，并将其放入模块执行的环境中，确保可调用\"></a>3. 实现模块加载的方法，并将其放入模块执行的环境中，确保可调用</h4><h4 id=\"4-将执行入口文件的逻辑放在一个函数表达式中，并立即执行这个函数\"><a href=\"#4-将执行入口文件的逻辑放在一个函数表达式中，并立即执行这个函数\" class=\"headerlink\" title=\"4. 将执行入口文件的逻辑放在一个函数表达式中，并立即执行这个函数\"></a>4. 将执行入口文件的逻辑放在一个函数表达式中，并立即执行这个函数</h4><ul>\n<li>需要注意__webpack_require__是一个递归</li>\n</ul>\n<h4 id=\"补充webpack的生命周期\"><a href=\"#补充webpack的生命周期\" class=\"headerlink\" title=\"补充webpack的生命周期\"></a>补充webpack的生命周期</h4><ol>\n<li><code>beforeRun</code>：Webpack 进入编译前的阶段，此时会初始化 Compiler 对象。</li>\n<li><code>run</code>：Webpack 开始编译前的阶段，此时会读取入口文件和依赖，并创建依赖图。</li>\n<li><code>compilation</code>：Webpack 进入编译阶段，此时会开始编译入口文件和依赖的模块，并生成输出文件。</li>\n<li><code>emit</code>：Webpack 生成输出文件前的阶段，此时可以在插件中处理生成的输出文件。</li>\n<li><code>done</code>：Webpack 完成打包后的阶段，此时可以在插件中进行一些清理工作。</li>\n</ol>\n"},{"title":"cookie、token相关","date":"2023-08-20T14:44:04.000Z","_content":"\ncookie、token都是做鉴权验证的方式，实际上还应该有一个session，面试的时候总会问的一个问题：cookie、session和token的区别。实际上我认为这个问题很傻叉。因为本质上讲这三个东西就是一个东西，这种问题的逻辑，就相当于一只鸡从上下左右观察有什么区别。有鸡毛区别。\n\n鉴权的两种方式：\n### cookie+session\n1. 用户登录，提交用户信息\n2. 后端根据用户提交的数据生成一个sessionID，存储到磁盘，并通过set-cookie返回给前端\n3. 前端收到自动存储到对应域名下的cookie中，之后的每次请求，都会自动带上这sessionID\n\n### token\n1. 用户登录，提交用户信息\n2. 后段通过jwt等库提供的加密方式，生成一串字符串，并通过set-cookie返回给前端\n3. 前端收到自动存储到对应域名下的cookie中，之后的每次请求，都会自动带上这token\n\n过程一致，唯一不同的，就是一个叫sessionID，一个叫token字符串。这种问题，毫无意义。\n\n","source":"_posts/cookie、token相关.md","raw":"---\ntitle: cookie、token相关\ncategory: 大前端气宗专栏\ndate: 2023-08-20 22:44:04\ntags:\n---\n\ncookie、token都是做鉴权验证的方式，实际上还应该有一个session，面试的时候总会问的一个问题：cookie、session和token的区别。实际上我认为这个问题很傻叉。因为本质上讲这三个东西就是一个东西，这种问题的逻辑，就相当于一只鸡从上下左右观察有什么区别。有鸡毛区别。\n\n鉴权的两种方式：\n### cookie+session\n1. 用户登录，提交用户信息\n2. 后端根据用户提交的数据生成一个sessionID，存储到磁盘，并通过set-cookie返回给前端\n3. 前端收到自动存储到对应域名下的cookie中，之后的每次请求，都会自动带上这sessionID\n\n### token\n1. 用户登录，提交用户信息\n2. 后段通过jwt等库提供的加密方式，生成一串字符串，并通过set-cookie返回给前端\n3. 前端收到自动存储到对应域名下的cookie中，之后的每次请求，都会自动带上这token\n\n过程一致，唯一不同的，就是一个叫sessionID，一个叫token字符串。这种问题，毫无意义。\n\n","slug":"cookie、token相关","published":1,"updated":"2023-08-21T01:52:54.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxvy0011f8v7hk0j81v7","content":"<p>cookie、token都是做鉴权验证的方式，实际上还应该有一个session，面试的时候总会问的一个问题：cookie、session和token的区别。实际上我认为这个问题很傻叉。因为本质上讲这三个东西就是一个东西，这种问题的逻辑，就相当于一只鸡从上下左右观察有什么区别。有鸡毛区别。</p>\n<p>鉴权的两种方式：</p>\n<h3 id=\"cookie-session\"><a href=\"#cookie-session\" class=\"headerlink\" title=\"cookie+session\"></a>cookie+session</h3><ol>\n<li>用户登录，提交用户信息</li>\n<li>后端根据用户提交的数据生成一个sessionID，存储到磁盘，并通过set-cookie返回给前端</li>\n<li>前端收到自动存储到对应域名下的cookie中，之后的每次请求，都会自动带上这sessionID</li>\n</ol>\n<h3 id=\"token\"><a href=\"#token\" class=\"headerlink\" title=\"token\"></a>token</h3><ol>\n<li>用户登录，提交用户信息</li>\n<li>后段通过jwt等库提供的加密方式，生成一串字符串，并通过set-cookie返回给前端</li>\n<li>前端收到自动存储到对应域名下的cookie中，之后的每次请求，都会自动带上这token</li>\n</ol>\n<p>过程一致，唯一不同的，就是一个叫sessionID，一个叫token字符串。这种问题，毫无意义。</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>cookie、token都是做鉴权验证的方式，实际上还应该有一个session，面试的时候总会问的一个问题：cookie、session和token的区别。实际上我认为这个问题很傻叉。因为本质上讲这三个东西就是一个东西，这种问题的逻辑，就相当于一只鸡从上下左右观察有什么区别。有鸡毛区别。</p>\n<p>鉴权的两种方式：</p>\n<h3 id=\"cookie-session\"><a href=\"#cookie-session\" class=\"headerlink\" title=\"cookie+session\"></a>cookie+session</h3><ol>\n<li>用户登录，提交用户信息</li>\n<li>后端根据用户提交的数据生成一个sessionID，存储到磁盘，并通过set-cookie返回给前端</li>\n<li>前端收到自动存储到对应域名下的cookie中，之后的每次请求，都会自动带上这sessionID</li>\n</ol>\n<h3 id=\"token\"><a href=\"#token\" class=\"headerlink\" title=\"token\"></a>token</h3><ol>\n<li>用户登录，提交用户信息</li>\n<li>后段通过jwt等库提供的加密方式，生成一串字符串，并通过set-cookie返回给前端</li>\n<li>前端收到自动存储到对应域名下的cookie中，之后的每次请求，都会自动带上这token</li>\n</ol>\n<p>过程一致，唯一不同的，就是一个叫sessionID，一个叫token字符串。这种问题，毫无意义。</p>\n"},{"title":"Webpack系列：第四回","date":"2023-07-24T17:12:55.000Z","_content":"**在第三回中，我们将webpack的核心流程捋了一边，但是感觉理解有些不到位。那么为了解决自己的这个“不到位”的感觉，本文尝试去写一个自己的webpack。**\n\n","source":"_posts/Webpack系列：第四回.md","raw":"---\ntitle: Webpack系列：第四回\ncategory: Webpack\ndate: 2023-07-25 01:12:55\ntags:\n---\n**在第三回中，我们将webpack的核心流程捋了一边，但是感觉理解有些不到位。那么为了解决自己的这个“不到位”的感觉，本文尝试去写一个自己的webpack。**\n\n","slug":"Webpack系列：第四回","published":1,"updated":"2023-08-21T01:52:54.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxvz0013f8v7a12jbwzi","content":"<p><strong>在第三回中，我们将webpack的核心流程捋了一边，但是感觉理解有些不到位。那么为了解决自己的这个“不到位”的感觉，本文尝试去写一个自己的webpack。</strong></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p><strong>在第三回中，我们将webpack的核心流程捋了一边，但是感觉理解有些不到位。那么为了解决自己的这个“不到位”的感觉，本文尝试去写一个自己的webpack。</strong></p>\n"},{"title":"down视频资源时的偶然发现","date":"2023-08-03T02:28:44.000Z","_content":"\n鄙人关于互联网上的资源，向来的主张都是：但凡挂到了网上的资源，都应该免费共享。这也是伯纳斯李那些前辈们的初衷。但是目下很多站点尤其视频站点以版权为由，在制造各种障碍阻挠我们去获取到，自认为很有价值的东西。我觉得吧，版权固然要保护，对于那些利用有版权的东西获利的人必须严厉打击但是，向我们这种纯粹想down下来收藏的人，是不是太过不友好？\n\n关于视频资源的处理，各有千秋。有直接暴露src的，也有通过blob伪加密的，也有片段加载的，总体来讲，手段低劣，都不用自己去写工具，稍微懂点搜索常识的小白，也可以很容易的找到对应的工具达到目的。比如b站的you-get，油管的seg等。\n\n但是，最近碰到个手段风骚的站点。起因出于自己想借重温一遍《Big Bang》联系听力，但是翻了半天几乎没有可用的，即使可用但是字幕糟糕。索性就找了个在线的站点。看着看着老毛病又犯了，这么好的资源down下来岂不美哉？\n\n**当我打开控制台懵逼了。**\n- 快捷键打开控制台：弹框“你知道的太多了”,直接无法打开...\n<img src=\"/img/你知道的太多了.jpg\" alt=\"图片描述\" width=\"500\">\n\n- 页面一直死循环debugger!!!。\n<img src=\"/img/debugger.png\" alt=\"图片描述\" width=\"800\">\n\n手段真骚。仔细看下代码（图片有点模糊）：\n\n```javascript\n<script type=\"text/javascript\">\n    document.onkeydown = function() {\n        var e = window.event || arguments[0];\n        if (e.keyCode == 123) {\n            alert('你知道的太多了！');\n            return false;\n        }\n        if ((e.ctrlKey) && (e.shiftKey) && (e.keyCode == 73)) {\n            alert('你知道的太多了！');\n            return false;\n        }\n        if ((e.ctrlKey) && (e.keyCode == 85)) {\n            alert('你知道的太多了！');\n            return false;\n        }\n        if ((e.ctrlKey) && (e.keyCode == 83)) {\n            alert('你知道的太多了！');\n            return false;\n        }\n    }\n    ;\n    var threshold = 160;\n    window.setInterval(function() {\n        if (window.outerWidth - window.innerWidth > threshold || window.outerHeight - window.innerHeight > threshold) {\n            function disableDebugger() {\n                debugger ;\n            }\n            $(document).ready(function() {\n                disableDebugger();\n            });\n        }\n    }, 1e3);\n</script>\n```\n\n**针对第一点：**\n设置按键监听函数，纯按键操作连控制台都打不开，还给了个温馨的提示“你知道的太多了！”。真是谢谢他全家。这种方式很low，我大不了就不用快捷键打开，直接右击检查，完美破防。\n\n**针对第二点：**\n除了video标签直接暴露视频地址的方式，针对其他情况，我们一般的操作时勾选media资源刷新页面查看数据传输的方式，再根据具体方式具体处理。那么这骚操作骚就骚在那个dubugger。\n页面设置了一个定时器，一直处于运行状态。作用执行disableDebugger函数，就是触发debugger。判断的条件很清晰，当window.innerWidth 与window.outerWidth 的差值大于一定阈值的时候，这边设置的160，就会触发。pc我看了下貌似最小273。因此默认打开控制台就会debugger。\n这一番骚操作，直接导致我们只要打开了控制台，直接进入debugger模式，等同于没打开。\n**所以怎么破呢？**\n很简单：**用第三方抓包工具暴力抓取。这是明摆着比我们去学wireshark啊**","source":"_posts/down视频资源时的偶然发现.md","raw":"---\ntitle: down视频资源时的偶然发现\ncategory: 网络杂谈\ndate: 2023-08-03 10:28:44\ntags:\n---\n\n鄙人关于互联网上的资源，向来的主张都是：但凡挂到了网上的资源，都应该免费共享。这也是伯纳斯李那些前辈们的初衷。但是目下很多站点尤其视频站点以版权为由，在制造各种障碍阻挠我们去获取到，自认为很有价值的东西。我觉得吧，版权固然要保护，对于那些利用有版权的东西获利的人必须严厉打击但是，向我们这种纯粹想down下来收藏的人，是不是太过不友好？\n\n关于视频资源的处理，各有千秋。有直接暴露src的，也有通过blob伪加密的，也有片段加载的，总体来讲，手段低劣，都不用自己去写工具，稍微懂点搜索常识的小白，也可以很容易的找到对应的工具达到目的。比如b站的you-get，油管的seg等。\n\n但是，最近碰到个手段风骚的站点。起因出于自己想借重温一遍《Big Bang》联系听力，但是翻了半天几乎没有可用的，即使可用但是字幕糟糕。索性就找了个在线的站点。看着看着老毛病又犯了，这么好的资源down下来岂不美哉？\n\n**当我打开控制台懵逼了。**\n- 快捷键打开控制台：弹框“你知道的太多了”,直接无法打开...\n<img src=\"/img/你知道的太多了.jpg\" alt=\"图片描述\" width=\"500\">\n\n- 页面一直死循环debugger!!!。\n<img src=\"/img/debugger.png\" alt=\"图片描述\" width=\"800\">\n\n手段真骚。仔细看下代码（图片有点模糊）：\n\n```javascript\n<script type=\"text/javascript\">\n    document.onkeydown = function() {\n        var e = window.event || arguments[0];\n        if (e.keyCode == 123) {\n            alert('你知道的太多了！');\n            return false;\n        }\n        if ((e.ctrlKey) && (e.shiftKey) && (e.keyCode == 73)) {\n            alert('你知道的太多了！');\n            return false;\n        }\n        if ((e.ctrlKey) && (e.keyCode == 85)) {\n            alert('你知道的太多了！');\n            return false;\n        }\n        if ((e.ctrlKey) && (e.keyCode == 83)) {\n            alert('你知道的太多了！');\n            return false;\n        }\n    }\n    ;\n    var threshold = 160;\n    window.setInterval(function() {\n        if (window.outerWidth - window.innerWidth > threshold || window.outerHeight - window.innerHeight > threshold) {\n            function disableDebugger() {\n                debugger ;\n            }\n            $(document).ready(function() {\n                disableDebugger();\n            });\n        }\n    }, 1e3);\n</script>\n```\n\n**针对第一点：**\n设置按键监听函数，纯按键操作连控制台都打不开，还给了个温馨的提示“你知道的太多了！”。真是谢谢他全家。这种方式很low，我大不了就不用快捷键打开，直接右击检查，完美破防。\n\n**针对第二点：**\n除了video标签直接暴露视频地址的方式，针对其他情况，我们一般的操作时勾选media资源刷新页面查看数据传输的方式，再根据具体方式具体处理。那么这骚操作骚就骚在那个dubugger。\n页面设置了一个定时器，一直处于运行状态。作用执行disableDebugger函数，就是触发debugger。判断的条件很清晰，当window.innerWidth 与window.outerWidth 的差值大于一定阈值的时候，这边设置的160，就会触发。pc我看了下貌似最小273。因此默认打开控制台就会debugger。\n这一番骚操作，直接导致我们只要打开了控制台，直接进入debugger模式，等同于没打开。\n**所以怎么破呢？**\n很简单：**用第三方抓包工具暴力抓取。这是明摆着比我们去学wireshark啊**","slug":"down视频资源时的偶然发现","published":1,"updated":"2023-08-21T01:52:54.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxvz0016f8v73bjycxhd","content":"<p>鄙人关于互联网上的资源，向来的主张都是：但凡挂到了网上的资源，都应该免费共享。这也是伯纳斯李那些前辈们的初衷。但是目下很多站点尤其视频站点以版权为由，在制造各种障碍阻挠我们去获取到，自认为很有价值的东西。我觉得吧，版权固然要保护，对于那些利用有版权的东西获利的人必须严厉打击但是，向我们这种纯粹想down下来收藏的人，是不是太过不友好？</p>\n<p>关于视频资源的处理，各有千秋。有直接暴露src的，也有通过blob伪加密的，也有片段加载的，总体来讲，手段低劣，都不用自己去写工具，稍微懂点搜索常识的小白，也可以很容易的找到对应的工具达到目的。比如b站的you-get，油管的seg等。</p>\n<p>但是，最近碰到个手段风骚的站点。起因出于自己想借重温一遍《Big Bang》联系听力，但是翻了半天几乎没有可用的，即使可用但是字幕糟糕。索性就找了个在线的站点。看着看着老毛病又犯了，这么好的资源down下来岂不美哉？</p>\n<p><strong>当我打开控制台懵逼了。</strong></p>\n<ul>\n<li><p>快捷键打开控制台：弹框“你知道的太多了”,直接无法打开…</p>\n<img src=\"/img/你知道的太多了.jpg\" alt=\"图片描述\" width=\"500\">\n</li>\n<li><p>页面一直死循环debugger!!!。</p>\n<img src=\"/img/debugger.png\" alt=\"图片描述\" width=\"800\"></li>\n</ul>\n<p>手段真骚。仔细看下代码（图片有点模糊）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">&quot;text/javascript&quot;</span>&gt;</span><br><span class=\"line\">    <span class=\"variable language_\">document</span>.<span class=\"property\">onkeydown</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> e = <span class=\"variable language_\">window</span>.<span class=\"property\">event</span> || <span class=\"variable language_\">arguments</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.<span class=\"property\">keyCode</span> == <span class=\"number\">123</span>) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;你知道的太多了！&#x27;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e.<span class=\"property\">ctrlKey</span>) &amp;&amp; (e.<span class=\"property\">shiftKey</span>) &amp;&amp; (e.<span class=\"property\">keyCode</span> == <span class=\"number\">73</span>)) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;你知道的太多了！&#x27;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e.<span class=\"property\">ctrlKey</span>) &amp;&amp; (e.<span class=\"property\">keyCode</span> == <span class=\"number\">85</span>)) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;你知道的太多了！&#x27;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e.<span class=\"property\">ctrlKey</span>) &amp;&amp; (e.<span class=\"property\">keyCode</span> == <span class=\"number\">83</span>)) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;你知道的太多了！&#x27;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> threshold = <span class=\"number\">160</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">window</span>.<span class=\"built_in\">setInterval</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">window</span>.<span class=\"property\">outerWidth</span> - <span class=\"variable language_\">window</span>.<span class=\"property\">innerWidth</span> &gt; threshold || <span class=\"variable language_\">window</span>.<span class=\"property\">outerHeight</span> - <span class=\"variable language_\">window</span>.<span class=\"property\">innerHeight</span> &gt; threshold) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">function</span> <span class=\"title function_\">disableDebugger</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">debugger</span> ;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            $(<span class=\"variable language_\">document</span>).<span class=\"title function_\">ready</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">                <span class=\"title function_\">disableDebugger</span>();</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"number\">1e3</span>);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>针对第一点：</strong><br>设置按键监听函数，纯按键操作连控制台都打不开，还给了个温馨的提示“你知道的太多了！”。真是谢谢他全家。这种方式很low，我大不了就不用快捷键打开，直接右击检查，完美破防。</p>\n<p><strong>针对第二点：</strong><br>除了video标签直接暴露视频地址的方式，针对其他情况，我们一般的操作时勾选media资源刷新页面查看数据传输的方式，再根据具体方式具体处理。那么这骚操作骚就骚在那个dubugger。<br>页面设置了一个定时器，一直处于运行状态。作用执行disableDebugger函数，就是触发debugger。判断的条件很清晰，当window.innerWidth 与window.outerWidth 的差值大于一定阈值的时候，这边设置的160，就会触发。pc我看了下貌似最小273。因此默认打开控制台就会debugger。<br>这一番骚操作，直接导致我们只要打开了控制台，直接进入debugger模式，等同于没打开。<br><strong>所以怎么破呢？</strong><br>很简单：<strong>用第三方抓包工具暴力抓取。这是明摆着比我们去学wireshark啊</strong></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>鄙人关于互联网上的资源，向来的主张都是：但凡挂到了网上的资源，都应该免费共享。这也是伯纳斯李那些前辈们的初衷。但是目下很多站点尤其视频站点以版权为由，在制造各种障碍阻挠我们去获取到，自认为很有价值的东西。我觉得吧，版权固然要保护，对于那些利用有版权的东西获利的人必须严厉打击但是，向我们这种纯粹想down下来收藏的人，是不是太过不友好？</p>\n<p>关于视频资源的处理，各有千秋。有直接暴露src的，也有通过blob伪加密的，也有片段加载的，总体来讲，手段低劣，都不用自己去写工具，稍微懂点搜索常识的小白，也可以很容易的找到对应的工具达到目的。比如b站的you-get，油管的seg等。</p>\n<p>但是，最近碰到个手段风骚的站点。起因出于自己想借重温一遍《Big Bang》联系听力，但是翻了半天几乎没有可用的，即使可用但是字幕糟糕。索性就找了个在线的站点。看着看着老毛病又犯了，这么好的资源down下来岂不美哉？</p>\n<p><strong>当我打开控制台懵逼了。</strong></p>\n<ul>\n<li><p>快捷键打开控制台：弹框“你知道的太多了”,直接无法打开…</p>\n<img src=\"/img/你知道的太多了.jpg\" alt=\"图片描述\" width=\"500\">\n</li>\n<li><p>页面一直死循环debugger!!!。</p>\n<img src=\"/img/debugger.png\" alt=\"图片描述\" width=\"800\"></li>\n</ul>\n<p>手段真骚。仔细看下代码（图片有点模糊）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">&quot;text/javascript&quot;</span>&gt;</span><br><span class=\"line\">    <span class=\"variable language_\">document</span>.<span class=\"property\">onkeydown</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> e = <span class=\"variable language_\">window</span>.<span class=\"property\">event</span> || <span class=\"variable language_\">arguments</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.<span class=\"property\">keyCode</span> == <span class=\"number\">123</span>) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;你知道的太多了！&#x27;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e.<span class=\"property\">ctrlKey</span>) &amp;&amp; (e.<span class=\"property\">shiftKey</span>) &amp;&amp; (e.<span class=\"property\">keyCode</span> == <span class=\"number\">73</span>)) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;你知道的太多了！&#x27;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e.<span class=\"property\">ctrlKey</span>) &amp;&amp; (e.<span class=\"property\">keyCode</span> == <span class=\"number\">85</span>)) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;你知道的太多了！&#x27;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e.<span class=\"property\">ctrlKey</span>) &amp;&amp; (e.<span class=\"property\">keyCode</span> == <span class=\"number\">83</span>)) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;你知道的太多了！&#x27;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> threshold = <span class=\"number\">160</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">window</span>.<span class=\"built_in\">setInterval</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"variable language_\">window</span>.<span class=\"property\">outerWidth</span> - <span class=\"variable language_\">window</span>.<span class=\"property\">innerWidth</span> &gt; threshold || <span class=\"variable language_\">window</span>.<span class=\"property\">outerHeight</span> - <span class=\"variable language_\">window</span>.<span class=\"property\">innerHeight</span> &gt; threshold) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">function</span> <span class=\"title function_\">disableDebugger</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">debugger</span> ;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            $(<span class=\"variable language_\">document</span>).<span class=\"title function_\">ready</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">                <span class=\"title function_\">disableDebugger</span>();</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"number\">1e3</span>);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>针对第一点：</strong><br>设置按键监听函数，纯按键操作连控制台都打不开，还给了个温馨的提示“你知道的太多了！”。真是谢谢他全家。这种方式很low，我大不了就不用快捷键打开，直接右击检查，完美破防。</p>\n<p><strong>针对第二点：</strong><br>除了video标签直接暴露视频地址的方式，针对其他情况，我们一般的操作时勾选media资源刷新页面查看数据传输的方式，再根据具体方式具体处理。那么这骚操作骚就骚在那个dubugger。<br>页面设置了一个定时器，一直处于运行状态。作用执行disableDebugger函数，就是触发debugger。判断的条件很清晰，当window.innerWidth 与window.outerWidth 的差值大于一定阈值的时候，这边设置的160，就会触发。pc我看了下貌似最小273。因此默认打开控制台就会debugger。<br>这一番骚操作，直接导致我们只要打开了控制台，直接进入debugger模式，等同于没打开。<br><strong>所以怎么破呢？</strong><br>很简单：<strong>用第三方抓包工具暴力抓取。这是明摆着比我们去学wireshark啊</strong></p>\n"},{"title":"js的上古规则:原型链那些事儿","date":"2023-08-03T07:39:41.000Z","_content":"**本文目标：捋清原型链那一套**\n在《JS类型详论》的那篇文章中，我们有提到过自有属性和原型属性的概念。二者的区别，就是原型链存在的意义。\n```javascript\nconst obj = {\n  name: 'dddd'\n}\nconsole.log(obj.hasOwnProperty('constructor'))\nconsole.log('constructor' in obj)\n```\n在上面的代码中，我们创建了一个对象obj，含有一个name属性。随后用两种方式打印constructor，很显然我们呢并没有看到constructor属性，但是，通过in的方式，打印出了true。为什么？我们呢说过in能够扫描的属性不单单是对象上显式写出来的属性（自有属性），还包括了对象原型链上的（原型属性）。而此处的constructor，就存在与obj的原型对象中，所以打印出了true。\n**具体查找流程**：发现自有属性没有，然后沿着obj的__proto__属性找到其原型对象，发了目标输出。倘若依旧没有，那就继续沿着原型对象的原型对象找。直到尽头。这，就是原型链。\n\n### __proto__和prototype\n首先我们呢需要搞清楚，这俩兄弟的关系。简单明了的说：**前者是实例对象的属性，指向其原型对象。而后者是构造函数的属性，指向构造函数的原型对象。**\n\n### new的时候，到底发生了啥？\n此时，再思考一个面试必问的千年烂题，“当我们执行new的时候，到底发生了啥？”。关键就是两步：首先基于构造函数的原型对象，创建一个空对象，{}，此时该空对象的__proto___指向原型对象。然后调用call或apply执行构造函数的属性初始化，最后返回。详情见见代码：\n```javascript\n    const Parent = function(name, age) {\n      this.name = name\n      this.age = age\n    }\n\n    const myNew = function(...args) {\n// 此处可以直接通过隐形arguments获取参数\n      const target = args[0]\n      const child = Object.create(target.prototype)\n      let res = target.call(child, ...args.slice(1))\n      return typeof res === 'object'? res: child\n    }\n\n    const child = new Parent('alice', 12)\n    const child2 = myNew(Parent, 'alice', 12)\n    console.log('child:', child)\n    console.log('child2:', child2)\n```\n\n### 关于this指向问题\n**简言之：谁调用它，就指向谁**\n- 对象的方法调用： 指向对象\n```javascript\nconst obj = {\n  name: 'hhvcg',\n  getName: function() {\n    return this.name\n  }\n}\nconsole.log(obj.getName())\n```\n\n- 普通函数调用: 只想全局window\n```javascript\n window.name = 'hhvcg'\nconst f = function() {\n  return this.name\n}\nconsole.log(f())\n```\n\n- 构造函数调用：指向构造函数的实例对象\n```javascript\nconst f = function(name) {\n  this.name = name\n}\n\nconst child = new f('hhvcg')\nconsole.log(child.name)\n```\n\n### 闭包的那些个事儿\n**以最经典的防抖和节流功能为例。**\n1. 防抖： 不停的触发事件，我们这里具体指不停点击按钮，事件只执行一次。\n```javascript\n// html\n    <a-button @click=\"debounce\">click</a-button>\n// js\n    const f = function () {\n      let timer = null as any\n      return function () {\n        clearTimeout(timer)\n        timer = setTimeout(() => {\n          log('click')\n        }, 2000)\n      }\n    }\n    const debounce = f()\n```\n不管我们点击多少次，清除之前点击设置的定时器，再次声明一个，只有当点击结束，才会执行最后的定时器。\n\n2. 节流：一个事件，鼠标不停点击，该事件会以固定时间执行。\n```javascript\n    // js\n    const f = function () {\n      let flag = true\n      return function () {\n        if (!flag) {\n          return null\n        }\n        flag = false\n        setTimeout(() => {\n          log('click')\n          flag = true\n        }, 2000)\n      }\n    }\n    const throttle = f()\n\n// html\n    <a-button @click=\"throttle\">click</a-button>\n```\n\n我们把f函数的执行给到throttle，此时的throttle就是一个闭包函数。具体点讲，相当于在全局作用域上首先声明了一个flag，同时还有一个返回的函数。每当我们点击按钮时，都会执行返回的那个函数。\n\n**文章末尾祭出终极原理图，仅供参考**\n<img src=\"/img/js原型链.webp\" alt=\"js原型链\" width=\"500\">\n\n","source":"_posts/js的上古规则-原型链那些事儿.md","raw":"---\ntitle: js的上古规则:原型链那些事儿\ncategory: 大前端气宗专栏\ndate: 2023-08-03 15:39:41\ntags:\n---\n**本文目标：捋清原型链那一套**\n在《JS类型详论》的那篇文章中，我们有提到过自有属性和原型属性的概念。二者的区别，就是原型链存在的意义。\n```javascript\nconst obj = {\n  name: 'dddd'\n}\nconsole.log(obj.hasOwnProperty('constructor'))\nconsole.log('constructor' in obj)\n```\n在上面的代码中，我们创建了一个对象obj，含有一个name属性。随后用两种方式打印constructor，很显然我们呢并没有看到constructor属性，但是，通过in的方式，打印出了true。为什么？我们呢说过in能够扫描的属性不单单是对象上显式写出来的属性（自有属性），还包括了对象原型链上的（原型属性）。而此处的constructor，就存在与obj的原型对象中，所以打印出了true。\n**具体查找流程**：发现自有属性没有，然后沿着obj的__proto__属性找到其原型对象，发了目标输出。倘若依旧没有，那就继续沿着原型对象的原型对象找。直到尽头。这，就是原型链。\n\n### __proto__和prototype\n首先我们呢需要搞清楚，这俩兄弟的关系。简单明了的说：**前者是实例对象的属性，指向其原型对象。而后者是构造函数的属性，指向构造函数的原型对象。**\n\n### new的时候，到底发生了啥？\n此时，再思考一个面试必问的千年烂题，“当我们执行new的时候，到底发生了啥？”。关键就是两步：首先基于构造函数的原型对象，创建一个空对象，{}，此时该空对象的__proto___指向原型对象。然后调用call或apply执行构造函数的属性初始化，最后返回。详情见见代码：\n```javascript\n    const Parent = function(name, age) {\n      this.name = name\n      this.age = age\n    }\n\n    const myNew = function(...args) {\n// 此处可以直接通过隐形arguments获取参数\n      const target = args[0]\n      const child = Object.create(target.prototype)\n      let res = target.call(child, ...args.slice(1))\n      return typeof res === 'object'? res: child\n    }\n\n    const child = new Parent('alice', 12)\n    const child2 = myNew(Parent, 'alice', 12)\n    console.log('child:', child)\n    console.log('child2:', child2)\n```\n\n### 关于this指向问题\n**简言之：谁调用它，就指向谁**\n- 对象的方法调用： 指向对象\n```javascript\nconst obj = {\n  name: 'hhvcg',\n  getName: function() {\n    return this.name\n  }\n}\nconsole.log(obj.getName())\n```\n\n- 普通函数调用: 只想全局window\n```javascript\n window.name = 'hhvcg'\nconst f = function() {\n  return this.name\n}\nconsole.log(f())\n```\n\n- 构造函数调用：指向构造函数的实例对象\n```javascript\nconst f = function(name) {\n  this.name = name\n}\n\nconst child = new f('hhvcg')\nconsole.log(child.name)\n```\n\n### 闭包的那些个事儿\n**以最经典的防抖和节流功能为例。**\n1. 防抖： 不停的触发事件，我们这里具体指不停点击按钮，事件只执行一次。\n```javascript\n// html\n    <a-button @click=\"debounce\">click</a-button>\n// js\n    const f = function () {\n      let timer = null as any\n      return function () {\n        clearTimeout(timer)\n        timer = setTimeout(() => {\n          log('click')\n        }, 2000)\n      }\n    }\n    const debounce = f()\n```\n不管我们点击多少次，清除之前点击设置的定时器，再次声明一个，只有当点击结束，才会执行最后的定时器。\n\n2. 节流：一个事件，鼠标不停点击，该事件会以固定时间执行。\n```javascript\n    // js\n    const f = function () {\n      let flag = true\n      return function () {\n        if (!flag) {\n          return null\n        }\n        flag = false\n        setTimeout(() => {\n          log('click')\n          flag = true\n        }, 2000)\n      }\n    }\n    const throttle = f()\n\n// html\n    <a-button @click=\"throttle\">click</a-button>\n```\n\n我们把f函数的执行给到throttle，此时的throttle就是一个闭包函数。具体点讲，相当于在全局作用域上首先声明了一个flag，同时还有一个返回的函数。每当我们点击按钮时，都会执行返回的那个函数。\n\n**文章末尾祭出终极原理图，仅供参考**\n<img src=\"/img/js原型链.webp\" alt=\"js原型链\" width=\"500\">\n\n","slug":"js的上古规则-原型链那些事儿","published":1,"updated":"2023-08-21T02:35:38.646Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxw00017f8v7c2pih7oi","content":"<p><strong>本文目标：捋清原型链那一套</strong><br>在《JS类型详论》的那篇文章中，我们有提到过自有属性和原型属性的概念。二者的区别，就是原型链存在的意义。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;dddd&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"title function_\">hasOwnProperty</span>(<span class=\"string\">&#x27;constructor&#x27;</span>))</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;constructor&#x27;</span> <span class=\"keyword\">in</span> obj)</span><br></pre></td></tr></table></figure>\n<p>在上面的代码中，我们创建了一个对象obj，含有一个name属性。随后用两种方式打印constructor，很显然我们呢并没有看到constructor属性，但是，通过in的方式，打印出了true。为什么？我们呢说过in能够扫描的属性不单单是对象上显式写出来的属性（自有属性），还包括了对象原型链上的（原型属性）。而此处的constructor，就存在与obj的原型对象中，所以打印出了true。<br><strong>具体查找流程</strong>：发现自有属性没有，然后沿着obj的__proto__属性找到其原型对象，发了目标输出。倘若依旧没有，那就继续沿着原型对象的原型对象找。直到尽头。这，就是原型链。</p>\n<h3 id=\"proto-和prototype\"><a href=\"#proto-和prototype\" class=\"headerlink\" title=\"__proto__和prototype\"></a>__proto__和prototype</h3><p>首先我们呢需要搞清楚，这俩兄弟的关系。简单明了的说：<strong>前者是实例对象的属性，指向其原型对象。而后者是构造函数的属性，指向构造函数的原型对象。</strong></p>\n<h3 id=\"new的时候，到底发生了啥？\"><a href=\"#new的时候，到底发生了啥？\" class=\"headerlink\" title=\"new的时候，到底发生了啥？\"></a>new的时候，到底发生了啥？</h3><p>此时，再思考一个面试必问的千年烂题，“当我们执行new的时候，到底发生了啥？”。关键就是两步：首先基于构造函数的原型对象，创建一个空对象，{}，此时该空对象的__proto___指向原型对象。然后调用call或apply执行构造函数的属性初始化，最后返回。详情见见代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title class_\">Parent</span> = <span class=\"keyword\">function</span>(<span class=\"params\">name, age</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> myNew = <span class=\"keyword\">function</span>(<span class=\"params\">...args</span>) &#123;</span><br><span class=\"line\"><span class=\"comment\">// 此处可以直接通过隐形arguments获取参数</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> target = args[<span class=\"number\">0</span>]</span><br><span class=\"line\">      <span class=\"keyword\">const</span> child = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(target.<span class=\"property\"><span class=\"keyword\">prototype</span></span>)</span><br><span class=\"line\">      <span class=\"keyword\">let</span> res = target.<span class=\"title function_\">call</span>(child, ...args.<span class=\"title function_\">slice</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> res === <span class=\"string\">&#x27;object&#x27;</span>? <span class=\"attr\">res</span>: child</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> child = <span class=\"keyword\">new</span> <span class=\"title class_\">Parent</span>(<span class=\"string\">&#x27;alice&#x27;</span>, <span class=\"number\">12</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> child2 = <span class=\"title function_\">myNew</span>(<span class=\"title class_\">Parent</span>, <span class=\"string\">&#x27;alice&#x27;</span>, <span class=\"number\">12</span>)</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;child:&#x27;</span>, child)</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;child2:&#x27;</span>, child2)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关于this指向问题\"><a href=\"#关于this指向问题\" class=\"headerlink\" title=\"关于this指向问题\"></a>关于this指向问题</h3><p><strong>简言之：谁调用它，就指向谁</strong></p>\n<ul>\n<li><p>对象的方法调用： 指向对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;hhvcg&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">getName</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">name</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"title function_\">getName</span>())</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>普通函数调用: 只想全局window</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"variable language_\">window</span>.<span class=\"property\">name</span> = <span class=\"string\">&#x27;hhvcg&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">name</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">f</span>())</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>构造函数调用：指向构造函数的实例对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"keyword\">function</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> child = <span class=\"keyword\">new</span> <span class=\"title function_\">f</span>(<span class=\"string\">&#x27;hhvcg&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(child.<span class=\"property\">name</span>)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"闭包的那些个事儿\"><a href=\"#闭包的那些个事儿\" class=\"headerlink\" title=\"闭包的那些个事儿\"></a>闭包的那些个事儿</h3><p><strong>以最经典的防抖和节流功能为例。</strong></p>\n<ol>\n<li><p>防抖： 不停的触发事件，我们这里具体指不停点击按钮，事件只执行一次。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// html</span></span><br><span class=\"line\">    &lt;a-button @click=<span class=\"string\">&quot;debounce&quot;</span>&gt;click&lt;/a-button&gt;</span><br><span class=\"line\"><span class=\"comment\">// js</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> f = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> timer = <span class=\"literal\">null</span> <span class=\"keyword\">as</span> any</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">clearTimeout</span>(timer)</span><br><span class=\"line\">        timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"title function_\">log</span>(<span class=\"string\">&#x27;click&#x27;</span>)</span><br><span class=\"line\">        &#125;, <span class=\"number\">2000</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> debounce = <span class=\"title function_\">f</span>()</span><br></pre></td></tr></table></figure>\n<p>不管我们点击多少次，清除之前点击设置的定时器，再次声明一个，只有当点击结束，才会执行最后的定时器。</p>\n</li>\n<li><p>节流：一个事件，鼠标不停点击，该事件会以固定时间执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">// js</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> f = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> flag = <span class=\"literal\">true</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!flag) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        flag = <span class=\"literal\">false</span></span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"title function_\">log</span>(<span class=\"string\">&#x27;click&#x27;</span>)</span><br><span class=\"line\">          flag = <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;, <span class=\"number\">2000</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> throttle = <span class=\"title function_\">f</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// html</span></span><br><span class=\"line\">    &lt;a-button @click=<span class=\"string\">&quot;throttle&quot;</span>&gt;click&lt;/a-button&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>我们把f函数的执行给到throttle，此时的throttle就是一个闭包函数。具体点讲，相当于在全局作用域上首先声明了一个flag，同时还有一个返回的函数。每当我们点击按钮时，都会执行返回的那个函数。</p>\n<p><strong>文章末尾祭出终极原理图，仅供参考</strong><br><img src=\"/img/js原型链.webp\" alt=\"js原型链\" width=\"500\"></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p><strong>本文目标：捋清原型链那一套</strong><br>在《JS类型详论》的那篇文章中，我们有提到过自有属性和原型属性的概念。二者的区别，就是原型链存在的意义。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;dddd&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"title function_\">hasOwnProperty</span>(<span class=\"string\">&#x27;constructor&#x27;</span>))</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;constructor&#x27;</span> <span class=\"keyword\">in</span> obj)</span><br></pre></td></tr></table></figure>\n<p>在上面的代码中，我们创建了一个对象obj，含有一个name属性。随后用两种方式打印constructor，很显然我们呢并没有看到constructor属性，但是，通过in的方式，打印出了true。为什么？我们呢说过in能够扫描的属性不单单是对象上显式写出来的属性（自有属性），还包括了对象原型链上的（原型属性）。而此处的constructor，就存在与obj的原型对象中，所以打印出了true。<br><strong>具体查找流程</strong>：发现自有属性没有，然后沿着obj的__proto__属性找到其原型对象，发了目标输出。倘若依旧没有，那就继续沿着原型对象的原型对象找。直到尽头。这，就是原型链。</p>\n<h3 id=\"proto-和prototype\"><a href=\"#proto-和prototype\" class=\"headerlink\" title=\"__proto__和prototype\"></a>__proto__和prototype</h3><p>首先我们呢需要搞清楚，这俩兄弟的关系。简单明了的说：<strong>前者是实例对象的属性，指向其原型对象。而后者是构造函数的属性，指向构造函数的原型对象。</strong></p>\n<h3 id=\"new的时候，到底发生了啥？\"><a href=\"#new的时候，到底发生了啥？\" class=\"headerlink\" title=\"new的时候，到底发生了啥？\"></a>new的时候，到底发生了啥？</h3><p>此时，再思考一个面试必问的千年烂题，“当我们执行new的时候，到底发生了啥？”。关键就是两步：首先基于构造函数的原型对象，创建一个空对象，{}，此时该空对象的__proto___指向原型对象。然后调用call或apply执行构造函数的属性初始化，最后返回。详情见见代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title class_\">Parent</span> = <span class=\"keyword\">function</span>(<span class=\"params\">name, age</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> myNew = <span class=\"keyword\">function</span>(<span class=\"params\">...args</span>) &#123;</span><br><span class=\"line\"><span class=\"comment\">// 此处可以直接通过隐形arguments获取参数</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> target = args[<span class=\"number\">0</span>]</span><br><span class=\"line\">      <span class=\"keyword\">const</span> child = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(target.<span class=\"property\"><span class=\"keyword\">prototype</span></span>)</span><br><span class=\"line\">      <span class=\"keyword\">let</span> res = target.<span class=\"title function_\">call</span>(child, ...args.<span class=\"title function_\">slice</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> res === <span class=\"string\">&#x27;object&#x27;</span>? <span class=\"attr\">res</span>: child</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> child = <span class=\"keyword\">new</span> <span class=\"title class_\">Parent</span>(<span class=\"string\">&#x27;alice&#x27;</span>, <span class=\"number\">12</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> child2 = <span class=\"title function_\">myNew</span>(<span class=\"title class_\">Parent</span>, <span class=\"string\">&#x27;alice&#x27;</span>, <span class=\"number\">12</span>)</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;child:&#x27;</span>, child)</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;child2:&#x27;</span>, child2)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关于this指向问题\"><a href=\"#关于this指向问题\" class=\"headerlink\" title=\"关于this指向问题\"></a>关于this指向问题</h3><p><strong>简言之：谁调用它，就指向谁</strong></p>\n<ul>\n<li><p>对象的方法调用： 指向对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;hhvcg&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">getName</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">name</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"title function_\">getName</span>())</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>普通函数调用: 只想全局window</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"variable language_\">window</span>.<span class=\"property\">name</span> = <span class=\"string\">&#x27;hhvcg&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">name</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">f</span>())</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>构造函数调用：指向构造函数的实例对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"keyword\">function</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> child = <span class=\"keyword\">new</span> <span class=\"title function_\">f</span>(<span class=\"string\">&#x27;hhvcg&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(child.<span class=\"property\">name</span>)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"闭包的那些个事儿\"><a href=\"#闭包的那些个事儿\" class=\"headerlink\" title=\"闭包的那些个事儿\"></a>闭包的那些个事儿</h3><p><strong>以最经典的防抖和节流功能为例。</strong></p>\n<ol>\n<li><p>防抖： 不停的触发事件，我们这里具体指不停点击按钮，事件只执行一次。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// html</span></span><br><span class=\"line\">    &lt;a-button @click=<span class=\"string\">&quot;debounce&quot;</span>&gt;click&lt;/a-button&gt;</span><br><span class=\"line\"><span class=\"comment\">// js</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> f = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> timer = <span class=\"literal\">null</span> <span class=\"keyword\">as</span> any</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">clearTimeout</span>(timer)</span><br><span class=\"line\">        timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"title function_\">log</span>(<span class=\"string\">&#x27;click&#x27;</span>)</span><br><span class=\"line\">        &#125;, <span class=\"number\">2000</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> debounce = <span class=\"title function_\">f</span>()</span><br></pre></td></tr></table></figure>\n<p>不管我们点击多少次，清除之前点击设置的定时器，再次声明一个，只有当点击结束，才会执行最后的定时器。</p>\n</li>\n<li><p>节流：一个事件，鼠标不停点击，该事件会以固定时间执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">// js</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> f = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> flag = <span class=\"literal\">true</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!flag) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        flag = <span class=\"literal\">false</span></span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"title function_\">log</span>(<span class=\"string\">&#x27;click&#x27;</span>)</span><br><span class=\"line\">          flag = <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;, <span class=\"number\">2000</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> throttle = <span class=\"title function_\">f</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// html</span></span><br><span class=\"line\">    &lt;a-button @click=<span class=\"string\">&quot;throttle&quot;</span>&gt;click&lt;/a-button&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>我们把f函数的执行给到throttle，此时的throttle就是一个闭包函数。具体点讲，相当于在全局作用域上首先声明了一个flag，同时还有一个返回的函数。每当我们点击按钮时，都会执行返回的那个函数。</p>\n<p><strong>文章末尾祭出终极原理图，仅供参考</strong><br><img src=\"/img/js原型链.webp\" alt=\"js原型链\" width=\"500\"></p>\n"},{"title":"js的转折分界: ES6","date":"2023-08-07T09:03:48.000Z","_content":"\n不管有没有系统的去学习ES6相关的概念，但我相信，在日常开发中，都或多或少的使用到了相关方法。笔者一直很纳闷，事实上ES6从发布至今也蛮长时间了，但是面试的时候总会有面试官问这么个问题：ES6有什么新的特性。。。。事实上这是因为该版本,对于js这门语言而言,具有里程碑的意义.**那么本文尝试着将最重大的改动梳理梳理.**\n\n- 1. 首当其冲的必定是let、const块级作用域声明方式。同var相比两个不同。块级作用域能够屏蔽var的变量提升，将变量的生命周期局限在块中。本质讲，let、const声明在作用域外无法访问的变量。\n```javascript\nconst f = function () {\n    if (false) {\n        let name = '1234'\n        //var name = '1234'\n    }\n    console.log('name:', name)\n}\nf()\n```\n\n- 2. 模板字面量。简单地讲，就是可以在字符串中灵活插入变量。如下面代码所示。变量用${}插入。同时需要注意的是` `中间的空格及换行，也会真实的展示出来。\n```javascript\n  const log = console.log.bind(console)\n  let s = '123456'\n  log(`number is ${s}`)\n  log(`this is\n  test`)\n  // this is\n  // test\n```\n- 3. 箭头函数。这个概念也是面试必问的点。稍微总结一下他与普通函数的区别：(1)： 没有arguments、this、super等。(2)：不能通过new方法创建实例。因为没有consturct，也就不存在原型。\n**箭头函数尤其需要注意的一点，就是函数内部的this指向。其实很简单，有最近一层非箭头函数决定。以我目前看，箭头函数的实质，乃代码装x之大杀器。**\n\n\n- 4. Object.is()。这个方法提供了判断两值是否相等的终极大杀器。我们知道，在js中，判断相等通常会使用“==”和“===”。其中后者较为普遍，因为前者涉及隐含的类型转换，出现bug。但即使是“===”强等于判断，依然有问题。举例，NaN === NaN，实质上是一个东西，但返回的确实false。对于-0与+0，两者在js中是不同的，但返回的却是true。而用Object.is()来判断，完美符合真实情况。写到这里，笔者想说，在几乎所有的开发中，“===”基本能满足需求。而Object.is()这个方法的出现，我认为是js这门语言不断优化进步的体现。\n- 5. promise。这东西实质上就是利用回调函数自己做了封装，看起来舒服点。\n- 6. 关于proxy代理的理解（vue3中响应式数据原理）\n```javascript\nconst proxyUser = new Proxy(user, {\n    get (target, prop) {\n        console.log('get....')\n        return Reflect.get(target, prop)\n    },\n    set (target, prop, val) {\n        console.log('set....')\n        return Reflect.set(target, prop, val)\n    }\n})\n```\n这里需要分清楚两个概念，上面代码中的目标对象user，和代理对象proxyUser，代理对象的改动就是改动目标对象。使用proxy对目标对象的内部数据劫持，并通过reflect操作对象的内部数据。\n","source":"_posts/js的转折分界-ES6.md","raw":"---\ntitle: 'js的转折分界: ES6'\ncategory: 大前端气宗专栏\ndate: 2023-08-07 17:03:48\ntags:\n---\n\n不管有没有系统的去学习ES6相关的概念，但我相信，在日常开发中，都或多或少的使用到了相关方法。笔者一直很纳闷，事实上ES6从发布至今也蛮长时间了，但是面试的时候总会有面试官问这么个问题：ES6有什么新的特性。。。。事实上这是因为该版本,对于js这门语言而言,具有里程碑的意义.**那么本文尝试着将最重大的改动梳理梳理.**\n\n- 1. 首当其冲的必定是let、const块级作用域声明方式。同var相比两个不同。块级作用域能够屏蔽var的变量提升，将变量的生命周期局限在块中。本质讲，let、const声明在作用域外无法访问的变量。\n```javascript\nconst f = function () {\n    if (false) {\n        let name = '1234'\n        //var name = '1234'\n    }\n    console.log('name:', name)\n}\nf()\n```\n\n- 2. 模板字面量。简单地讲，就是可以在字符串中灵活插入变量。如下面代码所示。变量用${}插入。同时需要注意的是` `中间的空格及换行，也会真实的展示出来。\n```javascript\n  const log = console.log.bind(console)\n  let s = '123456'\n  log(`number is ${s}`)\n  log(`this is\n  test`)\n  // this is\n  // test\n```\n- 3. 箭头函数。这个概念也是面试必问的点。稍微总结一下他与普通函数的区别：(1)： 没有arguments、this、super等。(2)：不能通过new方法创建实例。因为没有consturct，也就不存在原型。\n**箭头函数尤其需要注意的一点，就是函数内部的this指向。其实很简单，有最近一层非箭头函数决定。以我目前看，箭头函数的实质，乃代码装x之大杀器。**\n\n\n- 4. Object.is()。这个方法提供了判断两值是否相等的终极大杀器。我们知道，在js中，判断相等通常会使用“==”和“===”。其中后者较为普遍，因为前者涉及隐含的类型转换，出现bug。但即使是“===”强等于判断，依然有问题。举例，NaN === NaN，实质上是一个东西，但返回的确实false。对于-0与+0，两者在js中是不同的，但返回的却是true。而用Object.is()来判断，完美符合真实情况。写到这里，笔者想说，在几乎所有的开发中，“===”基本能满足需求。而Object.is()这个方法的出现，我认为是js这门语言不断优化进步的体现。\n- 5. promise。这东西实质上就是利用回调函数自己做了封装，看起来舒服点。\n- 6. 关于proxy代理的理解（vue3中响应式数据原理）\n```javascript\nconst proxyUser = new Proxy(user, {\n    get (target, prop) {\n        console.log('get....')\n        return Reflect.get(target, prop)\n    },\n    set (target, prop, val) {\n        console.log('set....')\n        return Reflect.set(target, prop, val)\n    }\n})\n```\n这里需要分清楚两个概念，上面代码中的目标对象user，和代理对象proxyUser，代理对象的改动就是改动目标对象。使用proxy对目标对象的内部数据劫持，并通过reflect操作对象的内部数据。\n","slug":"js的转折分界-ES6","published":1,"updated":"2023-08-21T01:52:54.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxw0001af8v787yy17nl","content":"<p>不管有没有系统的去学习ES6相关的概念，但我相信，在日常开发中，都或多或少的使用到了相关方法。笔者一直很纳闷，事实上ES6从发布至今也蛮长时间了，但是面试的时候总会有面试官问这么个问题：ES6有什么新的特性。。。。事实上这是因为该版本,对于js这门语言而言,具有里程碑的意义.<strong>那么本文尝试着将最重大的改动梳理梳理.</strong></p>\n<ul>\n<li><ol>\n<li>首当其冲的必定是let、const块级作用域声明方式。同var相比两个不同。块级作用域能够屏蔽var的变量提升，将变量的生命周期局限在块中。本质讲，let、const声明在作用域外无法访问的变量。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> name = <span class=\"string\">&#x27;1234&#x27;</span></span><br><span class=\"line\">        <span class=\"comment\">//var name = &#x27;1234&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;name:&#x27;</span>, name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">f</span>()</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>模板字面量。简单地讲，就是可以在字符串中灵活插入变量。如下面代码所示。变量用${}插入。同时需要注意的是<code> </code>中间的空格及换行，也会真实的展示出来。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> log = <span class=\"variable language_\">console</span>.<span class=\"property\">log</span>.<span class=\"title function_\">bind</span>(<span class=\"variable language_\">console</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">&#x27;123456&#x27;</span></span><br><span class=\"line\"><span class=\"title function_\">log</span>(<span class=\"string\">`number is <span class=\"subst\">$&#123;s&#125;</span>`</span>)</span><br><span class=\"line\"><span class=\"title function_\">log</span>(<span class=\"string\">`this is</span></span><br><span class=\"line\"><span class=\"string\">test`</span>)</span><br><span class=\"line\"><span class=\"comment\">// this is</span></span><br><span class=\"line\"><span class=\"comment\">// test</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>箭头函数。这个概念也是面试必问的点。稍微总结一下他与普通函数的区别：(1)： 没有arguments、this、super等。(2)：不能通过new方法创建实例。因为没有consturct，也就不存在原型。<br><strong>箭头函数尤其需要注意的一点，就是函数内部的this指向。其实很简单，有最近一层非箭头函数决定。以我目前看，箭头函数的实质，乃代码装x之大杀器。</strong></li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>Object.is()。这个方法提供了判断两值是否相等的终极大杀器。我们知道，在js中，判断相等通常会使用“&#x3D;&#x3D;”和“&#x3D;&#x3D;&#x3D;”。其中后者较为普遍，因为前者涉及隐含的类型转换，出现bug。但即使是“&#x3D;&#x3D;&#x3D;”强等于判断，依然有问题。举例，NaN &#x3D;&#x3D;&#x3D; NaN，实质上是一个东西，但返回的确实false。对于-0与+0，两者在js中是不同的，但返回的却是true。而用Object.is()来判断，完美符合真实情况。写到这里，笔者想说，在几乎所有的开发中，“&#x3D;&#x3D;&#x3D;”基本能满足需求。而Object.is()这个方法的出现，我认为是js这门语言不断优化进步的体现。</li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>promise。这东西实质上就是利用回调函数自己做了封装，看起来舒服点。</li>\n</ol>\n</li>\n<li><ol start=\"6\">\n<li>关于proxy代理的理解（vue3中响应式数据原理）<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> proxyUser = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(user, &#123;</span><br><span class=\"line\">    get (target, prop) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;get....&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(target, prop)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    set (target, prop, val) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;set....&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">set</span>(target, prop, val)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n这里需要分清楚两个概念，上面代码中的目标对象user，和代理对象proxyUser，代理对象的改动就是改动目标对象。使用proxy对目标对象的内部数据劫持，并通过reflect操作对象的内部数据。</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>不管有没有系统的去学习ES6相关的概念，但我相信，在日常开发中，都或多或少的使用到了相关方法。笔者一直很纳闷，事实上ES6从发布至今也蛮长时间了，但是面试的时候总会有面试官问这么个问题：ES6有什么新的特性。。。。事实上这是因为该版本,对于js这门语言而言,具有里程碑的意义.<strong>那么本文尝试着将最重大的改动梳理梳理.</strong></p>\n<ul>\n<li><ol>\n<li>首当其冲的必定是let、const块级作用域声明方式。同var相比两个不同。块级作用域能够屏蔽var的变量提升，将变量的生命周期局限在块中。本质讲，let、const声明在作用域外无法访问的变量。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> name = <span class=\"string\">&#x27;1234&#x27;</span></span><br><span class=\"line\">        <span class=\"comment\">//var name = &#x27;1234&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;name:&#x27;</span>, name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">f</span>()</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>模板字面量。简单地讲，就是可以在字符串中灵活插入变量。如下面代码所示。变量用${}插入。同时需要注意的是<code> </code>中间的空格及换行，也会真实的展示出来。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> log = <span class=\"variable language_\">console</span>.<span class=\"property\">log</span>.<span class=\"title function_\">bind</span>(<span class=\"variable language_\">console</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">&#x27;123456&#x27;</span></span><br><span class=\"line\"><span class=\"title function_\">log</span>(<span class=\"string\">`number is <span class=\"subst\">$&#123;s&#125;</span>`</span>)</span><br><span class=\"line\"><span class=\"title function_\">log</span>(<span class=\"string\">`this is</span></span><br><span class=\"line\"><span class=\"string\">test`</span>)</span><br><span class=\"line\"><span class=\"comment\">// this is</span></span><br><span class=\"line\"><span class=\"comment\">// test</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>箭头函数。这个概念也是面试必问的点。稍微总结一下他与普通函数的区别：(1)： 没有arguments、this、super等。(2)：不能通过new方法创建实例。因为没有consturct，也就不存在原型。<br><strong>箭头函数尤其需要注意的一点，就是函数内部的this指向。其实很简单，有最近一层非箭头函数决定。以我目前看，箭头函数的实质，乃代码装x之大杀器。</strong></li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>Object.is()。这个方法提供了判断两值是否相等的终极大杀器。我们知道，在js中，判断相等通常会使用“&#x3D;&#x3D;”和“&#x3D;&#x3D;&#x3D;”。其中后者较为普遍，因为前者涉及隐含的类型转换，出现bug。但即使是“&#x3D;&#x3D;&#x3D;”强等于判断，依然有问题。举例，NaN &#x3D;&#x3D;&#x3D; NaN，实质上是一个东西，但返回的确实false。对于-0与+0，两者在js中是不同的，但返回的却是true。而用Object.is()来判断，完美符合真实情况。写到这里，笔者想说，在几乎所有的开发中，“&#x3D;&#x3D;&#x3D;”基本能满足需求。而Object.is()这个方法的出现，我认为是js这门语言不断优化进步的体现。</li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>promise。这东西实质上就是利用回调函数自己做了封装，看起来舒服点。</li>\n</ol>\n</li>\n<li><ol start=\"6\">\n<li>关于proxy代理的理解（vue3中响应式数据原理）<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> proxyUser = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(user, &#123;</span><br><span class=\"line\">    get (target, prop) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;get....&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(target, prop)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    set (target, prop, val) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;set....&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">set</span>(target, prop, val)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n这里需要分清楚两个概念，上面代码中的目标对象user，和代理对象proxyUser，代理对象的改动就是改动目标对象。使用proxy对目标对象的内部数据劫持，并通过reflect操作对象的内部数据。</li>\n</ol>\n</li>\n</ul>\n"},{"title":"《万神殿》--上载智能","date":"2023-07-24T08:42:29.000Z","_content":"\n最近闲来无事，追了一部amc美剧《万神殿》。可能是应付俗事过久，导致自己仰望星空得兴趣日益萎靡，但是这部剧，瞬间把我又拉了回去。同时还get到了一个新的名词儿：**UI，上载智能。Upload Intelligence。**\n\n所谓**上载智能**，就是将实体的人脑数据完全电子化，转变为“在云端”的状态，可复制可粘贴，是实现人类永生的基础。这个概念自打计算机诞生之日，便已经出现。相关的书籍、影视作品更是层出不穷。九十年代的《The Shell》攻壳机动队可谓是开山鼻祖，是该领域内的基石，**“脑机接口、义体”**等概念，均出自于此。后面的《黑客帝国》也是借鉴之。这些先驱们当年的天马行空的想象，而今，大有实现的可能。但是，也正如马斯克所言：**人工智能极度的危险**。\n\n《未来简史》的作者提出了一个观念：人类目下，正从经历从智人到神人的转变。何出此言？很简单，当下人类社会中的每一个个体的能力，都是曾经的人类所不能比的。这倒并不是说二十一世纪的人们相比较古人而言，多长了对翅膀或是多了个脑袋。而是说，当今的人类个体，在搭配各种现代设备之后，从古人的角度出发，那就是神的存在。借助飞行器，他们能上天，借助地下挖掘设备，他们能遁地，借助航海设备，他们还能入海。卫星就是千里眼，各种手机终端就是顺风耳。当年孙悟空一个跟头能翻十万八千里，**如今人类最快的飞行器TR-3B反重力飞行器，速度据说能达到惊人的9马赫，即一小时为11016公里**。虽然还有些差距，但是达到猴子那纯属意淫的速度水平，应该也只是时间的问题。\n\n通过在人体内植入芯片，就能够控制家中的所有智能设备。胳膊坏了就换一个胳膊，大腿坏了就换一个大腿，甚至脑袋坏了直接换个头...换到最后，就会发现，这是哲学问题。**你是谁？你在哪？何为生？何为死？**不管是攻壳中的少佐，还是《万神殿》中的主人公他爹，都会面临这个问题。他们到底是啥？他们是活着呢，还是挂了？说他们活着吧，但是原本的物质存在已经消失。你说他们死了吧，却可以轻易借助其他躯壳重返你的身边。这种状态下的他们，某种层面上讲，就是神。\n\n尽管有些人不想承认，但我们依旧不得不去面对未来的一个现实：**人类会突破生死的界限,实现永生**。但是，这可能是人类灭亡开端。从人类的大历史观角度看：**死亡的宿命规则，决定了哪怕不公平的体系中的人们，在生死面前都是平等的。**但倘若有那么一天人们发现，死亡可以避免，宿命并不存在的时候。那会是一番怎样的景象？对此，我很兴奋。","source":"_posts/《万神殿》-上载智能.md","raw":"---\ntitle: 《万神殿》--上载智能\ndate: 2023-07-24 16:42:29\ntags:\ncategories: '杂谈'\n---\n\n最近闲来无事，追了一部amc美剧《万神殿》。可能是应付俗事过久，导致自己仰望星空得兴趣日益萎靡，但是这部剧，瞬间把我又拉了回去。同时还get到了一个新的名词儿：**UI，上载智能。Upload Intelligence。**\n\n所谓**上载智能**，就是将实体的人脑数据完全电子化，转变为“在云端”的状态，可复制可粘贴，是实现人类永生的基础。这个概念自打计算机诞生之日，便已经出现。相关的书籍、影视作品更是层出不穷。九十年代的《The Shell》攻壳机动队可谓是开山鼻祖，是该领域内的基石，**“脑机接口、义体”**等概念，均出自于此。后面的《黑客帝国》也是借鉴之。这些先驱们当年的天马行空的想象，而今，大有实现的可能。但是，也正如马斯克所言：**人工智能极度的危险**。\n\n《未来简史》的作者提出了一个观念：人类目下，正从经历从智人到神人的转变。何出此言？很简单，当下人类社会中的每一个个体的能力，都是曾经的人类所不能比的。这倒并不是说二十一世纪的人们相比较古人而言，多长了对翅膀或是多了个脑袋。而是说，当今的人类个体，在搭配各种现代设备之后，从古人的角度出发，那就是神的存在。借助飞行器，他们能上天，借助地下挖掘设备，他们能遁地，借助航海设备，他们还能入海。卫星就是千里眼，各种手机终端就是顺风耳。当年孙悟空一个跟头能翻十万八千里，**如今人类最快的飞行器TR-3B反重力飞行器，速度据说能达到惊人的9马赫，即一小时为11016公里**。虽然还有些差距，但是达到猴子那纯属意淫的速度水平，应该也只是时间的问题。\n\n通过在人体内植入芯片，就能够控制家中的所有智能设备。胳膊坏了就换一个胳膊，大腿坏了就换一个大腿，甚至脑袋坏了直接换个头...换到最后，就会发现，这是哲学问题。**你是谁？你在哪？何为生？何为死？**不管是攻壳中的少佐，还是《万神殿》中的主人公他爹，都会面临这个问题。他们到底是啥？他们是活着呢，还是挂了？说他们活着吧，但是原本的物质存在已经消失。你说他们死了吧，却可以轻易借助其他躯壳重返你的身边。这种状态下的他们，某种层面上讲，就是神。\n\n尽管有些人不想承认，但我们依旧不得不去面对未来的一个现实：**人类会突破生死的界限,实现永生**。但是，这可能是人类灭亡开端。从人类的大历史观角度看：**死亡的宿命规则，决定了哪怕不公平的体系中的人们，在生死面前都是平等的。**但倘若有那么一天人们发现，死亡可以避免，宿命并不存在的时候。那会是一番怎样的景象？对此，我很兴奋。","slug":"《万神殿》-上载智能","published":1,"updated":"2023-08-21T01:52:54.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxw1001cf8v70u74dnzm","content":"<p>最近闲来无事，追了一部amc美剧《万神殿》。可能是应付俗事过久，导致自己仰望星空得兴趣日益萎靡，但是这部剧，瞬间把我又拉了回去。同时还get到了一个新的名词儿：<strong>UI，上载智能。Upload Intelligence。</strong></p>\n<p>所谓<strong>上载智能</strong>，就是将实体的人脑数据完全电子化，转变为“在云端”的状态，可复制可粘贴，是实现人类永生的基础。这个概念自打计算机诞生之日，便已经出现。相关的书籍、影视作品更是层出不穷。九十年代的《The Shell》攻壳机动队可谓是开山鼻祖，是该领域内的基石，<strong>“脑机接口、义体”</strong>等概念，均出自于此。后面的《黑客帝国》也是借鉴之。这些先驱们当年的天马行空的想象，而今，大有实现的可能。但是，也正如马斯克所言：<strong>人工智能极度的危险</strong>。</p>\n<p>《未来简史》的作者提出了一个观念：人类目下，正从经历从智人到神人的转变。何出此言？很简单，当下人类社会中的每一个个体的能力，都是曾经的人类所不能比的。这倒并不是说二十一世纪的人们相比较古人而言，多长了对翅膀或是多了个脑袋。而是说，当今的人类个体，在搭配各种现代设备之后，从古人的角度出发，那就是神的存在。借助飞行器，他们能上天，借助地下挖掘设备，他们能遁地，借助航海设备，他们还能入海。卫星就是千里眼，各种手机终端就是顺风耳。当年孙悟空一个跟头能翻十万八千里，<strong>如今人类最快的飞行器TR-3B反重力飞行器，速度据说能达到惊人的9马赫，即一小时为11016公里</strong>。虽然还有些差距，但是达到猴子那纯属意淫的速度水平，应该也只是时间的问题。</p>\n<p>通过在人体内植入芯片，就能够控制家中的所有智能设备。胳膊坏了就换一个胳膊，大腿坏了就换一个大腿，甚至脑袋坏了直接换个头…换到最后，就会发现，这是哲学问题。<strong>你是谁？你在哪？何为生？何为死？</strong>不管是攻壳中的少佐，还是《万神殿》中的主人公他爹，都会面临这个问题。他们到底是啥？他们是活着呢，还是挂了？说他们活着吧，但是原本的物质存在已经消失。你说他们死了吧，却可以轻易借助其他躯壳重返你的身边。这种状态下的他们，某种层面上讲，就是神。</p>\n<p>尽管有些人不想承认，但我们依旧不得不去面对未来的一个现实：<strong>人类会突破生死的界限,实现永生</strong>。但是，这可能是人类灭亡开端。从人类的大历史观角度看：<strong>死亡的宿命规则，决定了哪怕不公平的体系中的人们，在生死面前都是平等的。</strong>但倘若有那么一天人们发现，死亡可以避免，宿命并不存在的时候。那会是一番怎样的景象？对此，我很兴奋。</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>最近闲来无事，追了一部amc美剧《万神殿》。可能是应付俗事过久，导致自己仰望星空得兴趣日益萎靡，但是这部剧，瞬间把我又拉了回去。同时还get到了一个新的名词儿：<strong>UI，上载智能。Upload Intelligence。</strong></p>\n<p>所谓<strong>上载智能</strong>，就是将实体的人脑数据完全电子化，转变为“在云端”的状态，可复制可粘贴，是实现人类永生的基础。这个概念自打计算机诞生之日，便已经出现。相关的书籍、影视作品更是层出不穷。九十年代的《The Shell》攻壳机动队可谓是开山鼻祖，是该领域内的基石，<strong>“脑机接口、义体”</strong>等概念，均出自于此。后面的《黑客帝国》也是借鉴之。这些先驱们当年的天马行空的想象，而今，大有实现的可能。但是，也正如马斯克所言：<strong>人工智能极度的危险</strong>。</p>\n<p>《未来简史》的作者提出了一个观念：人类目下，正从经历从智人到神人的转变。何出此言？很简单，当下人类社会中的每一个个体的能力，都是曾经的人类所不能比的。这倒并不是说二十一世纪的人们相比较古人而言，多长了对翅膀或是多了个脑袋。而是说，当今的人类个体，在搭配各种现代设备之后，从古人的角度出发，那就是神的存在。借助飞行器，他们能上天，借助地下挖掘设备，他们能遁地，借助航海设备，他们还能入海。卫星就是千里眼，各种手机终端就是顺风耳。当年孙悟空一个跟头能翻十万八千里，<strong>如今人类最快的飞行器TR-3B反重力飞行器，速度据说能达到惊人的9马赫，即一小时为11016公里</strong>。虽然还有些差距，但是达到猴子那纯属意淫的速度水平，应该也只是时间的问题。</p>\n<p>通过在人体内植入芯片，就能够控制家中的所有智能设备。胳膊坏了就换一个胳膊，大腿坏了就换一个大腿，甚至脑袋坏了直接换个头…换到最后，就会发现，这是哲学问题。<strong>你是谁？你在哪？何为生？何为死？</strong>不管是攻壳中的少佐，还是《万神殿》中的主人公他爹，都会面临这个问题。他们到底是啥？他们是活着呢，还是挂了？说他们活着吧，但是原本的物质存在已经消失。你说他们死了吧，却可以轻易借助其他躯壳重返你的身边。这种状态下的他们，某种层面上讲，就是神。</p>\n<p>尽管有些人不想承认，但我们依旧不得不去面对未来的一个现实：<strong>人类会突破生死的界限,实现永生</strong>。但是，这可能是人类灭亡开端。从人类的大历史观角度看：<strong>死亡的宿命规则，决定了哪怕不公平的体系中的人们，在生死面前都是平等的。</strong>但倘若有那么一天人们发现，死亡可以避免，宿命并不存在的时候。那会是一番怎样的景象？对此，我很兴奋。</p>\n"},{"title":"做好预备动作","date":"2023-07-24T08:16:52.000Z","_content":"<!-- <img src=\"/img/rrick.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\"> -->\n\n**新时代农名工**，官方定义的从事软件开发工作的人(呵呵)，目下主要分成了前端和后端。两者分工明确，但偶有全栈大佬，前后通吃，应对各种疑难杂症，不在话下（累成狗）。\n\n抛开后端的java全家桶技术栈不谈，单单一个前端，就有学不完的知识点。三大框架angular、vue、react不说精通底层实现，怎么用是不是得学一学？状态管理vuex、redux了解一下？什么，你说你精通vue2了，vue3新鲜出炉，对了还有号称更加轻量的vite要不也了解一下？react的JSX经常用吧？都几年工作经验了，性能优化做过吧，来具体讲讲？“小x啊，这页面卡成狗你处理一下？”“轮询太low了，改成websockt？”为了减少前端主线程计算压力worker怎么用的？为了得到最优的性能体验，浏览器是怎么渲染的？他底层逻辑是怎样的？http的发展历程能说出个大概吧？直到出http3了吧，来简单讲讲？node应该有了解吧，express、koa介绍一下？.......\n\n内容超级多，且，上述说的各个点，随着时间的推移，还在不断地更新变化着。这些都可称之为技术，不知道有多少人跟当初的我一样，放出豪言要碾碎上述的一切，成为“全能的专家”？（模仿当年爱迪生--誓言要看完图书馆里头的所有的书--->毫无可能性的事情）\n\n最近，也就是毕业刚满一年的这个时间节点，我突然明白一件事情，知识，是学不完的。就像浩如烟海的书本一般，你能看完这世上所有的书吗？不可能，同时也没必要。技术也是如此。技术的本质，就是一系列规则。小孩子不知道1+1等于几。进入学校后，打开数学课本的第一页，白纸黑字写的清清楚楚，”1+1=2“，他就知道了。别人问的时候，他回答1+1=2，说明他掌握了这项技能。技术的学习，不过如此。\n\n**计算机技术的广度和深度，犹如书海般的浩瀚，你是绝对学不完的，因为毕竟这是多少代人不断努力的结果。这是事实。**\n\n**师傅说，每个人的生命，极大值撑死不过三万六千天。**大部分人，终其一生，可能都是被他人推着走完的。**埋头赶路固然很重要，但偶尔仰望仰望星空，可能会有不一样的感受。**\n\n我觉得吧，放开手脚去大干一场的前提条件，是需要先搞搞清楚，你最珍视的、最在乎的东西，是什么。其他的，都可以不去care。这是底线准则。生活应该是多姿多彩的，闲暇时遛遛狗、捣鼓捣鼓机器等个人爱好，而不仅仅只是为了那些虚无缥缈的东西。这是应该有的生活态度。**珍惜现在已经拥有的，追寻明天你想要得到的。**\n\n在当今这个时代，尤其是在笔者目前所处的这片土地上，我见识了太多的悲剧、喜剧。有些人的人生剧本，可以用一部当年的美剧的剧名来形容-----**The Walking Dead**。我始终坚信，**今天流的泪，都是tm当年脑子进的水**。人各有命。对于技术，我只想脚踏实地，对于生活，我只想简简单单，尽可能的做个，明白人。\n\n**It's our duty.文毕**。","source":"_posts/做好预备动作.md","raw":"---\ntitle: 做好预备动作\ndate: 2023-07-24 16:16:52\ntags:\ncategories: '杂谈'\n---\n<!-- <img src=\"/img/rrick.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\"> -->\n\n**新时代农名工**，官方定义的从事软件开发工作的人(呵呵)，目下主要分成了前端和后端。两者分工明确，但偶有全栈大佬，前后通吃，应对各种疑难杂症，不在话下（累成狗）。\n\n抛开后端的java全家桶技术栈不谈，单单一个前端，就有学不完的知识点。三大框架angular、vue、react不说精通底层实现，怎么用是不是得学一学？状态管理vuex、redux了解一下？什么，你说你精通vue2了，vue3新鲜出炉，对了还有号称更加轻量的vite要不也了解一下？react的JSX经常用吧？都几年工作经验了，性能优化做过吧，来具体讲讲？“小x啊，这页面卡成狗你处理一下？”“轮询太low了，改成websockt？”为了减少前端主线程计算压力worker怎么用的？为了得到最优的性能体验，浏览器是怎么渲染的？他底层逻辑是怎样的？http的发展历程能说出个大概吧？直到出http3了吧，来简单讲讲？node应该有了解吧，express、koa介绍一下？.......\n\n内容超级多，且，上述说的各个点，随着时间的推移，还在不断地更新变化着。这些都可称之为技术，不知道有多少人跟当初的我一样，放出豪言要碾碎上述的一切，成为“全能的专家”？（模仿当年爱迪生--誓言要看完图书馆里头的所有的书--->毫无可能性的事情）\n\n最近，也就是毕业刚满一年的这个时间节点，我突然明白一件事情，知识，是学不完的。就像浩如烟海的书本一般，你能看完这世上所有的书吗？不可能，同时也没必要。技术也是如此。技术的本质，就是一系列规则。小孩子不知道1+1等于几。进入学校后，打开数学课本的第一页，白纸黑字写的清清楚楚，”1+1=2“，他就知道了。别人问的时候，他回答1+1=2，说明他掌握了这项技能。技术的学习，不过如此。\n\n**计算机技术的广度和深度，犹如书海般的浩瀚，你是绝对学不完的，因为毕竟这是多少代人不断努力的结果。这是事实。**\n\n**师傅说，每个人的生命，极大值撑死不过三万六千天。**大部分人，终其一生，可能都是被他人推着走完的。**埋头赶路固然很重要，但偶尔仰望仰望星空，可能会有不一样的感受。**\n\n我觉得吧，放开手脚去大干一场的前提条件，是需要先搞搞清楚，你最珍视的、最在乎的东西，是什么。其他的，都可以不去care。这是底线准则。生活应该是多姿多彩的，闲暇时遛遛狗、捣鼓捣鼓机器等个人爱好，而不仅仅只是为了那些虚无缥缈的东西。这是应该有的生活态度。**珍惜现在已经拥有的，追寻明天你想要得到的。**\n\n在当今这个时代，尤其是在笔者目前所处的这片土地上，我见识了太多的悲剧、喜剧。有些人的人生剧本，可以用一部当年的美剧的剧名来形容-----**The Walking Dead**。我始终坚信，**今天流的泪，都是tm当年脑子进的水**。人各有命。对于技术，我只想脚踏实地，对于生活，我只想简简单单，尽可能的做个，明白人。\n\n**It's our duty.文毕**。","slug":"做好预备动作","published":1,"updated":"2023-08-21T01:52:54.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxw1001ff8v70bczdu00","content":"<!-- <img src=\"/img/rrick.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\"> -->\n\n<p><strong>新时代农名工</strong>，官方定义的从事软件开发工作的人(呵呵)，目下主要分成了前端和后端。两者分工明确，但偶有全栈大佬，前后通吃，应对各种疑难杂症，不在话下（累成狗）。</p>\n<p>抛开后端的java全家桶技术栈不谈，单单一个前端，就有学不完的知识点。三大框架angular、vue、react不说精通底层实现，怎么用是不是得学一学？状态管理vuex、redux了解一下？什么，你说你精通vue2了，vue3新鲜出炉，对了还有号称更加轻量的vite要不也了解一下？react的JSX经常用吧？都几年工作经验了，性能优化做过吧，来具体讲讲？“小x啊，这页面卡成狗你处理一下？”“轮询太low了，改成websockt？”为了减少前端主线程计算压力worker怎么用的？为了得到最优的性能体验，浏览器是怎么渲染的？他底层逻辑是怎样的？http的发展历程能说出个大概吧？直到出http3了吧，来简单讲讲？node应该有了解吧，express、koa介绍一下？…….</p>\n<p>内容超级多，且，上述说的各个点，随着时间的推移，还在不断地更新变化着。这些都可称之为技术，不知道有多少人跟当初的我一样，放出豪言要碾碎上述的一切，成为“全能的专家”？（模仿当年爱迪生–誓言要看完图书馆里头的所有的书—&gt;毫无可能性的事情）</p>\n<p>最近，也就是毕业刚满一年的这个时间节点，我突然明白一件事情，知识，是学不完的。就像浩如烟海的书本一般，你能看完这世上所有的书吗？不可能，同时也没必要。技术也是如此。技术的本质，就是一系列规则。小孩子不知道1+1等于几。进入学校后，打开数学课本的第一页，白纸黑字写的清清楚楚，”1+1&#x3D;2“，他就知道了。别人问的时候，他回答1+1&#x3D;2，说明他掌握了这项技能。技术的学习，不过如此。</p>\n<p><strong>计算机技术的广度和深度，犹如书海般的浩瀚，你是绝对学不完的，因为毕竟这是多少代人不断努力的结果。这是事实。</strong></p>\n<p><strong>师傅说，每个人的生命，极大值撑死不过三万六千天。</strong>大部分人，终其一生，可能都是被他人推着走完的。<strong>埋头赶路固然很重要，但偶尔仰望仰望星空，可能会有不一样的感受。</strong></p>\n<p>我觉得吧，放开手脚去大干一场的前提条件，是需要先搞搞清楚，你最珍视的、最在乎的东西，是什么。其他的，都可以不去care。这是底线准则。生活应该是多姿多彩的，闲暇时遛遛狗、捣鼓捣鼓机器等个人爱好，而不仅仅只是为了那些虚无缥缈的东西。这是应该有的生活态度。<strong>珍惜现在已经拥有的，追寻明天你想要得到的。</strong></p>\n<p>在当今这个时代，尤其是在笔者目前所处的这片土地上，我见识了太多的悲剧、喜剧。有些人的人生剧本，可以用一部当年的美剧的剧名来形容—–<strong>The Walking Dead</strong>。我始终坚信，<strong>今天流的泪，都是tm当年脑子进的水</strong>。人各有命。对于技术，我只想脚踏实地，对于生活，我只想简简单单，尽可能的做个，明白人。</p>\n<p><strong>It’s our duty.文毕</strong>。</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<!-- <img src=\"/img/rrick.jpg\" alt=\"图片描述\" width=\"500\" height=\"300\"> -->\n\n<p><strong>新时代农名工</strong>，官方定义的从事软件开发工作的人(呵呵)，目下主要分成了前端和后端。两者分工明确，但偶有全栈大佬，前后通吃，应对各种疑难杂症，不在话下（累成狗）。</p>\n<p>抛开后端的java全家桶技术栈不谈，单单一个前端，就有学不完的知识点。三大框架angular、vue、react不说精通底层实现，怎么用是不是得学一学？状态管理vuex、redux了解一下？什么，你说你精通vue2了，vue3新鲜出炉，对了还有号称更加轻量的vite要不也了解一下？react的JSX经常用吧？都几年工作经验了，性能优化做过吧，来具体讲讲？“小x啊，这页面卡成狗你处理一下？”“轮询太low了，改成websockt？”为了减少前端主线程计算压力worker怎么用的？为了得到最优的性能体验，浏览器是怎么渲染的？他底层逻辑是怎样的？http的发展历程能说出个大概吧？直到出http3了吧，来简单讲讲？node应该有了解吧，express、koa介绍一下？…….</p>\n<p>内容超级多，且，上述说的各个点，随着时间的推移，还在不断地更新变化着。这些都可称之为技术，不知道有多少人跟当初的我一样，放出豪言要碾碎上述的一切，成为“全能的专家”？（模仿当年爱迪生–誓言要看完图书馆里头的所有的书—&gt;毫无可能性的事情）</p>\n<p>最近，也就是毕业刚满一年的这个时间节点，我突然明白一件事情，知识，是学不完的。就像浩如烟海的书本一般，你能看完这世上所有的书吗？不可能，同时也没必要。技术也是如此。技术的本质，就是一系列规则。小孩子不知道1+1等于几。进入学校后，打开数学课本的第一页，白纸黑字写的清清楚楚，”1+1&#x3D;2“，他就知道了。别人问的时候，他回答1+1&#x3D;2，说明他掌握了这项技能。技术的学习，不过如此。</p>\n<p><strong>计算机技术的广度和深度，犹如书海般的浩瀚，你是绝对学不完的，因为毕竟这是多少代人不断努力的结果。这是事实。</strong></p>\n<p><strong>师傅说，每个人的生命，极大值撑死不过三万六千天。</strong>大部分人，终其一生，可能都是被他人推着走完的。<strong>埋头赶路固然很重要，但偶尔仰望仰望星空，可能会有不一样的感受。</strong></p>\n<p>我觉得吧，放开手脚去大干一场的前提条件，是需要先搞搞清楚，你最珍视的、最在乎的东西，是什么。其他的，都可以不去care。这是底线准则。生活应该是多姿多彩的，闲暇时遛遛狗、捣鼓捣鼓机器等个人爱好，而不仅仅只是为了那些虚无缥缈的东西。这是应该有的生活态度。<strong>珍惜现在已经拥有的，追寻明天你想要得到的。</strong></p>\n<p>在当今这个时代，尤其是在笔者目前所处的这片土地上，我见识了太多的悲剧、喜剧。有些人的人生剧本，可以用一部当年的美剧的剧名来形容—–<strong>The Walking Dead</strong>。我始终坚信，<strong>今天流的泪，都是tm当年脑子进的水</strong>。人各有命。对于技术，我只想脚踏实地，对于生活，我只想简简单单，尽可能的做个，明白人。</p>\n<p><strong>It’s our duty.文毕</strong>。</p>\n"},{"title":"关于所谓的“梯子”的实现逻辑","date":"2023-08-03T02:38:19.000Z","_content":"\n不知道从什么时候开始，\"挂个梯子\"，成了很多大陆网友常挂嘴边的词。对于我而言，不仅仅是常挂嘴边，也曾一度想要实现一个自己的专属“梯子”。但是经过自己的一番研究之后，果断放弃了，因为不具备实现的条件。欲知详情，且听我缓缓道来。\n\n说到梯子，就不得不提一下GFW，即：大名鼎鼎的长城防火墙。类似进击的巨人中，那三层巨大的高墙，将墙内的人们与世界割裂。区别在于，前者是虚拟不可见的，而后者，则是正儿八经的看得见摸得着石头墙。GFW的实现原理，其实很简单，针对特定的站点，进行访问限制。可以简单理解为，大陆的所有的对外访问，都会经由一个统一的出口，如果访问的是受限制的站点，则会失败。\n\n那么“梯子”是如何突破这种限制的呢？本质在于“映射”，专业词汇“代理”。当我们挂上梯子访问外站的时候，机器首先访问的并不是我们输入的地址，而是中间层的机器。类似于“存储转发”的概念。\n<img src=\"/img/ladder.webp\" alt=\"图片描述\" width='500px'>\n\n有网络知识基础的人都晓得，当我们在浏览器的地址栏中输入网址，会通过tcp/ip协议族，跟目标主机建立通信链路，然后发送资源请求，只涉及双方：我的机器--->目标服务器，等同于现代的通话。那么“梯子”做的事情，相当于在双方之间加了一层。就是我的机器发出的请求，目标服务器并没有直接接收到，而是被中间层的服务器接收了，然后由中间层服务器将请求发送给目标服务器，获取到对应的资源之后，再返还给我的机器。\n\n这，就是“梯子”的实现原理。“利用梯子”，代理我们的请求，即：代替我们向目标服务器发送资源请求。\n\n那么此时回到文章开头，为什么我会果断放弃实现自己“梯子”的想法了呢？很显然，就是这个中间层服务器的搭建。是个大坑。\n\n文毕。","source":"_posts/关于所谓的“梯子”的实现逻辑.md","raw":"---\ntitle: 关于所谓的“梯子”的实现逻辑\ncategory: 网络杂谈\ndate: 2023-08-03 10:38:19\ntags:\n---\n\n不知道从什么时候开始，\"挂个梯子\"，成了很多大陆网友常挂嘴边的词。对于我而言，不仅仅是常挂嘴边，也曾一度想要实现一个自己的专属“梯子”。但是经过自己的一番研究之后，果断放弃了，因为不具备实现的条件。欲知详情，且听我缓缓道来。\n\n说到梯子，就不得不提一下GFW，即：大名鼎鼎的长城防火墙。类似进击的巨人中，那三层巨大的高墙，将墙内的人们与世界割裂。区别在于，前者是虚拟不可见的，而后者，则是正儿八经的看得见摸得着石头墙。GFW的实现原理，其实很简单，针对特定的站点，进行访问限制。可以简单理解为，大陆的所有的对外访问，都会经由一个统一的出口，如果访问的是受限制的站点，则会失败。\n\n那么“梯子”是如何突破这种限制的呢？本质在于“映射”，专业词汇“代理”。当我们挂上梯子访问外站的时候，机器首先访问的并不是我们输入的地址，而是中间层的机器。类似于“存储转发”的概念。\n<img src=\"/img/ladder.webp\" alt=\"图片描述\" width='500px'>\n\n有网络知识基础的人都晓得，当我们在浏览器的地址栏中输入网址，会通过tcp/ip协议族，跟目标主机建立通信链路，然后发送资源请求，只涉及双方：我的机器--->目标服务器，等同于现代的通话。那么“梯子”做的事情，相当于在双方之间加了一层。就是我的机器发出的请求，目标服务器并没有直接接收到，而是被中间层的服务器接收了，然后由中间层服务器将请求发送给目标服务器，获取到对应的资源之后，再返还给我的机器。\n\n这，就是“梯子”的实现原理。“利用梯子”，代理我们的请求，即：代替我们向目标服务器发送资源请求。\n\n那么此时回到文章开头，为什么我会果断放弃实现自己“梯子”的想法了呢？很显然，就是这个中间层服务器的搭建。是个大坑。\n\n文毕。","slug":"关于所谓的“梯子”的实现逻辑","published":1,"updated":"2023-08-21T01:52:54.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxw2001hf8v78gu80gnn","content":"<p>不知道从什么时候开始，”挂个梯子”，成了很多大陆网友常挂嘴边的词。对于我而言，不仅仅是常挂嘴边，也曾一度想要实现一个自己的专属“梯子”。但是经过自己的一番研究之后，果断放弃了，因为不具备实现的条件。欲知详情，且听我缓缓道来。</p>\n<p>说到梯子，就不得不提一下GFW，即：大名鼎鼎的长城防火墙。类似进击的巨人中，那三层巨大的高墙，将墙内的人们与世界割裂。区别在于，前者是虚拟不可见的，而后者，则是正儿八经的看得见摸得着石头墙。GFW的实现原理，其实很简单，针对特定的站点，进行访问限制。可以简单理解为，大陆的所有的对外访问，都会经由一个统一的出口，如果访问的是受限制的站点，则会失败。</p>\n<p>那么“梯子”是如何突破这种限制的呢？本质在于“映射”，专业词汇“代理”。当我们挂上梯子访问外站的时候，机器首先访问的并不是我们输入的地址，而是中间层的机器。类似于“存储转发”的概念。<br><img src=\"/img/ladder.webp\" alt=\"图片描述\" width='500px'></p>\n<p>有网络知识基础的人都晓得，当我们在浏览器的地址栏中输入网址，会通过tcp&#x2F;ip协议族，跟目标主机建立通信链路，然后发送资源请求，只涉及双方：我的机器—&gt;目标服务器，等同于现代的通话。那么“梯子”做的事情，相当于在双方之间加了一层。就是我的机器发出的请求，目标服务器并没有直接接收到，而是被中间层的服务器接收了，然后由中间层服务器将请求发送给目标服务器，获取到对应的资源之后，再返还给我的机器。</p>\n<p>这，就是“梯子”的实现原理。“利用梯子”，代理我们的请求，即：代替我们向目标服务器发送资源请求。</p>\n<p>那么此时回到文章开头，为什么我会果断放弃实现自己“梯子”的想法了呢？很显然，就是这个中间层服务器的搭建。是个大坑。</p>\n<p>文毕。</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>不知道从什么时候开始，”挂个梯子”，成了很多大陆网友常挂嘴边的词。对于我而言，不仅仅是常挂嘴边，也曾一度想要实现一个自己的专属“梯子”。但是经过自己的一番研究之后，果断放弃了，因为不具备实现的条件。欲知详情，且听我缓缓道来。</p>\n<p>说到梯子，就不得不提一下GFW，即：大名鼎鼎的长城防火墙。类似进击的巨人中，那三层巨大的高墙，将墙内的人们与世界割裂。区别在于，前者是虚拟不可见的，而后者，则是正儿八经的看得见摸得着石头墙。GFW的实现原理，其实很简单，针对特定的站点，进行访问限制。可以简单理解为，大陆的所有的对外访问，都会经由一个统一的出口，如果访问的是受限制的站点，则会失败。</p>\n<p>那么“梯子”是如何突破这种限制的呢？本质在于“映射”，专业词汇“代理”。当我们挂上梯子访问外站的时候，机器首先访问的并不是我们输入的地址，而是中间层的机器。类似于“存储转发”的概念。<br><img src=\"/img/ladder.webp\" alt=\"图片描述\" width='500px'></p>\n<p>有网络知识基础的人都晓得，当我们在浏览器的地址栏中输入网址，会通过tcp&#x2F;ip协议族，跟目标主机建立通信链路，然后发送资源请求，只涉及双方：我的机器—&gt;目标服务器，等同于现代的通话。那么“梯子”做的事情，相当于在双方之间加了一层。就是我的机器发出的请求，目标服务器并没有直接接收到，而是被中间层的服务器接收了，然后由中间层服务器将请求发送给目标服务器，获取到对应的资源之后，再返还给我的机器。</p>\n<p>这，就是“梯子”的实现原理。“利用梯子”，代理我们的请求，即：代替我们向目标服务器发送资源请求。</p>\n<p>那么此时回到文章开头，为什么我会果断放弃实现自己“梯子”的想法了呢？很显然，就是这个中间层服务器的搭建。是个大坑。</p>\n<p>文毕。</p>\n"},{"title":"性能的考量：第一回","date":"2023-08-03T09:16:31.000Z","_content":"\n**本文旨在梳理目下通用的性能优化方法**\n\n性能优化没有一个统一的指标，但目的是明确的，就是要让站点应用的加载速度够快，如此用户体验才能高（暂且不管页面做的烂不烂）,毕竟从应用开发者的角度看，“时间就是金钱”。三个大的角度：**带宽、延时和渲染耗时**.那么由于现代光纤通信的大规模普及，带宽的影响因素，已经小到可以忽略不计的地步，所以本文不讨论，剩下的就是**延时和渲染**。\n\n- **延迟耗时层面**。\n《计算机网络》的第六版中，对于延迟给出了明确的定义，从c端发出消息到s端收到消息的时间消耗，具体包括：排队延迟 --（缓冲）-> 处理延迟--（路由）->传输延迟--->传播延迟。说白了就是网络层面。针对于这个角度，引用《高性能浏览器网络》的经典名言：\n> 没有请求，就是最快的。\n\n告诉我们，**请求的个数最好没有，或者能少则少**。依据这一原则，我们可以有如下的措施：\n1. 能少则少，所以就极尽能事的合并请求，具体实践：“精灵图”等。\n2. 既然要不发送请求，那就是直接从本地读取。所以要使用缓存策略，具体实践：开启cache-control，缓存资源。\n3. 我们不能让数据传输得更快，但可以让它们传输的距离更短-CDN。同样大小的资源，距离用户越近，耗时理论上越小（网速差距不大）\n4. 首部压缩，后端gzip压缩，减少资源重量，加快传输速度。\n5. 对于一些小的资源比如小图，可以通过base64编码将其变成字符串直接嵌入到页面中，也不用发送请求。\n\n- **渲染层面**\n\n1. script标签defer或者async。由于在解析html时若碰到js代码就会牵扯到进程切换带来的开销且会阻塞html的解析，因此通过这俩属性规避之。\n<img src=\"/img/defer.png\" alt=\"图片描述\" width=\"500\">\n\n2. 减少重排重绘带来的不必要的开销。\n当然从后端的角度考虑，处理请求发出响应的耗时也需要考虑。所以优化方法： **让老板砸钱，换更高端的设备，才是王炸之策**\n毕。\n- **其他方面**\n1. DNS预解析甚至tcp链路预链接。\n假设页面中有几个超链接。用户没有点击的时候我就已经预解析了域名ip甚至链路都连接好了，这样，当用户点的时候，只剩下发送资源请求的耗时。\n2. 长连接。减少建立链路的耗时。这是浏览器层面的优化。\n截止到http1.0版本的协议。请求响应都是遵循请求、响应、断开。周而复始。1.1版本最大的优化就是实现长链接，复用链路。\n3. 坚决屏蔽重定向。\n","source":"_posts/性能的考量：第一回.md","raw":"---\ntitle: 性能的考量：第一回\ncategory: 性能的考量\ndate: 2023-08-03 17:16:31\ntags:\n---\n\n**本文旨在梳理目下通用的性能优化方法**\n\n性能优化没有一个统一的指标，但目的是明确的，就是要让站点应用的加载速度够快，如此用户体验才能高（暂且不管页面做的烂不烂）,毕竟从应用开发者的角度看，“时间就是金钱”。三个大的角度：**带宽、延时和渲染耗时**.那么由于现代光纤通信的大规模普及，带宽的影响因素，已经小到可以忽略不计的地步，所以本文不讨论，剩下的就是**延时和渲染**。\n\n- **延迟耗时层面**。\n《计算机网络》的第六版中，对于延迟给出了明确的定义，从c端发出消息到s端收到消息的时间消耗，具体包括：排队延迟 --（缓冲）-> 处理延迟--（路由）->传输延迟--->传播延迟。说白了就是网络层面。针对于这个角度，引用《高性能浏览器网络》的经典名言：\n> 没有请求，就是最快的。\n\n告诉我们，**请求的个数最好没有，或者能少则少**。依据这一原则，我们可以有如下的措施：\n1. 能少则少，所以就极尽能事的合并请求，具体实践：“精灵图”等。\n2. 既然要不发送请求，那就是直接从本地读取。所以要使用缓存策略，具体实践：开启cache-control，缓存资源。\n3. 我们不能让数据传输得更快，但可以让它们传输的距离更短-CDN。同样大小的资源，距离用户越近，耗时理论上越小（网速差距不大）\n4. 首部压缩，后端gzip压缩，减少资源重量，加快传输速度。\n5. 对于一些小的资源比如小图，可以通过base64编码将其变成字符串直接嵌入到页面中，也不用发送请求。\n\n- **渲染层面**\n\n1. script标签defer或者async。由于在解析html时若碰到js代码就会牵扯到进程切换带来的开销且会阻塞html的解析，因此通过这俩属性规避之。\n<img src=\"/img/defer.png\" alt=\"图片描述\" width=\"500\">\n\n2. 减少重排重绘带来的不必要的开销。\n当然从后端的角度考虑，处理请求发出响应的耗时也需要考虑。所以优化方法： **让老板砸钱，换更高端的设备，才是王炸之策**\n毕。\n- **其他方面**\n1. DNS预解析甚至tcp链路预链接。\n假设页面中有几个超链接。用户没有点击的时候我就已经预解析了域名ip甚至链路都连接好了，这样，当用户点的时候，只剩下发送资源请求的耗时。\n2. 长连接。减少建立链路的耗时。这是浏览器层面的优化。\n截止到http1.0版本的协议。请求响应都是遵循请求、响应、断开。周而复始。1.1版本最大的优化就是实现长链接，复用链路。\n3. 坚决屏蔽重定向。\n","slug":"性能的考量：第一回","published":1,"updated":"2023-08-21T01:52:54.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxw2001kf8v7gerj06th","content":"<p><strong>本文旨在梳理目下通用的性能优化方法</strong></p>\n<p>性能优化没有一个统一的指标，但目的是明确的，就是要让站点应用的加载速度够快，如此用户体验才能高（暂且不管页面做的烂不烂）,毕竟从应用开发者的角度看，“时间就是金钱”。三个大的角度：<strong>带宽、延时和渲染耗时</strong>.那么由于现代光纤通信的大规模普及，带宽的影响因素，已经小到可以忽略不计的地步，所以本文不讨论，剩下的就是<strong>延时和渲染</strong>。</p>\n<ul>\n<li><strong>延迟耗时层面</strong>。<br>《计算机网络》的第六版中，对于延迟给出了明确的定义，从c端发出消息到s端收到消息的时间消耗，具体包括：排队延迟 –（缓冲）-&gt; 处理延迟–（路由）-&gt;传输延迟—&gt;传播延迟。说白了就是网络层面。针对于这个角度，引用《高性能浏览器网络》的经典名言：<blockquote>\n<p>没有请求，就是最快的。</p>\n</blockquote>\n</li>\n</ul>\n<p>告诉我们，<strong>请求的个数最好没有，或者能少则少</strong>。依据这一原则，我们可以有如下的措施：</p>\n<ol>\n<li>能少则少，所以就极尽能事的合并请求，具体实践：“精灵图”等。</li>\n<li>既然要不发送请求，那就是直接从本地读取。所以要使用缓存策略，具体实践：开启cache-control，缓存资源。</li>\n<li>我们不能让数据传输得更快，但可以让它们传输的距离更短-CDN。同样大小的资源，距离用户越近，耗时理论上越小（网速差距不大）</li>\n<li>首部压缩，后端gzip压缩，减少资源重量，加快传输速度。</li>\n<li>对于一些小的资源比如小图，可以通过base64编码将其变成字符串直接嵌入到页面中，也不用发送请求。</li>\n</ol>\n<ul>\n<li><strong>渲染层面</strong></li>\n</ul>\n<ol>\n<li><p>script标签defer或者async。由于在解析html时若碰到js代码就会牵扯到进程切换带来的开销且会阻塞html的解析，因此通过这俩属性规避之。</p>\n<img src=\"/img/defer.png\" alt=\"图片描述\" width=\"500\">\n</li>\n<li><p>减少重排重绘带来的不必要的开销。<br>当然从后端的角度考虑，处理请求发出响应的耗时也需要考虑。所以优化方法： <strong>让老板砸钱，换更高端的设备，才是王炸之策</strong><br>毕。</p>\n</li>\n</ol>\n<ul>\n<li><strong>其他方面</strong></li>\n</ul>\n<ol>\n<li>DNS预解析甚至tcp链路预链接。<br>假设页面中有几个超链接。用户没有点击的时候我就已经预解析了域名ip甚至链路都连接好了，这样，当用户点的时候，只剩下发送资源请求的耗时。</li>\n<li>长连接。减少建立链路的耗时。这是浏览器层面的优化。<br>截止到http1.0版本的协议。请求响应都是遵循请求、响应、断开。周而复始。1.1版本最大的优化就是实现长链接，复用链路。</li>\n<li>坚决屏蔽重定向。</li>\n</ol>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p><strong>本文旨在梳理目下通用的性能优化方法</strong></p>\n<p>性能优化没有一个统一的指标，但目的是明确的，就是要让站点应用的加载速度够快，如此用户体验才能高（暂且不管页面做的烂不烂）,毕竟从应用开发者的角度看，“时间就是金钱”。三个大的角度：<strong>带宽、延时和渲染耗时</strong>.那么由于现代光纤通信的大规模普及，带宽的影响因素，已经小到可以忽略不计的地步，所以本文不讨论，剩下的就是<strong>延时和渲染</strong>。</p>\n<ul>\n<li><strong>延迟耗时层面</strong>。<br>《计算机网络》的第六版中，对于延迟给出了明确的定义，从c端发出消息到s端收到消息的时间消耗，具体包括：排队延迟 –（缓冲）-&gt; 处理延迟–（路由）-&gt;传输延迟—&gt;传播延迟。说白了就是网络层面。针对于这个角度，引用《高性能浏览器网络》的经典名言：<blockquote>\n<p>没有请求，就是最快的。</p>\n</blockquote>\n</li>\n</ul>\n<p>告诉我们，<strong>请求的个数最好没有，或者能少则少</strong>。依据这一原则，我们可以有如下的措施：</p>\n<ol>\n<li>能少则少，所以就极尽能事的合并请求，具体实践：“精灵图”等。</li>\n<li>既然要不发送请求，那就是直接从本地读取。所以要使用缓存策略，具体实践：开启cache-control，缓存资源。</li>\n<li>我们不能让数据传输得更快，但可以让它们传输的距离更短-CDN。同样大小的资源，距离用户越近，耗时理论上越小（网速差距不大）</li>\n<li>首部压缩，后端gzip压缩，减少资源重量，加快传输速度。</li>\n<li>对于一些小的资源比如小图，可以通过base64编码将其变成字符串直接嵌入到页面中，也不用发送请求。</li>\n</ol>\n<ul>\n<li><strong>渲染层面</strong></li>\n</ul>\n<ol>\n<li><p>script标签defer或者async。由于在解析html时若碰到js代码就会牵扯到进程切换带来的开销且会阻塞html的解析，因此通过这俩属性规避之。</p>\n<img src=\"/img/defer.png\" alt=\"图片描述\" width=\"500\">\n</li>\n<li><p>减少重排重绘带来的不必要的开销。<br>当然从后端的角度考虑，处理请求发出响应的耗时也需要考虑。所以优化方法： <strong>让老板砸钱，换更高端的设备，才是王炸之策</strong><br>毕。</p>\n</li>\n</ol>\n<ul>\n<li><strong>其他方面</strong></li>\n</ul>\n<ol>\n<li>DNS预解析甚至tcp链路预链接。<br>假设页面中有几个超链接。用户没有点击的时候我就已经预解析了域名ip甚至链路都连接好了，这样，当用户点的时候，只剩下发送资源请求的耗时。</li>\n<li>长连接。减少建立链路的耗时。这是浏览器层面的优化。<br>截止到http1.0版本的协议。请求响应都是遵循请求、响应、断开。周而复始。1.1版本最大的优化就是实现长链接，复用链路。</li>\n<li>坚决屏蔽重定向。</li>\n</ol>\n"},{"title":"四轴无人机研究：第一回","date":"2023-07-31T02:27:23.000Z","_content":"\n无人机在现今社会的各个角落，都扮演着极其重要的作用。那么对于我们普通人而言，其最大的价值角色，就是航拍。鄙人的第一台机器，就是大疆的mini一代。带着他去了无数的地方，给我留下了很多珍贵的镜头。但是很不幸，两年的时间，已经飞不起来了。本着充分利用资源的原则，我想借其**尸骨**，来稍微深入的研究一下四旋翼无人机的飞行原理，然后尝试能否，**借尸还魂**。\n\n<img src=\"/img/air.png\" alt=\"图片描述\" width=\"500\">\n\n\n#### 四旋翼无人机的大体构成\n- **飞控系统**。一般包括GPS记录经纬度的,气压计记录气压的、IMU惯性测量单元，计算三维空间中飞机姿态的各个参数的，指南针等。。。。\n- **遥控系统**。就是手柄遥控器。遥控器发出信号，飞控的信号接收模块接收信号后，执行相应的指令。\n- **动力系统**。一般包括：电调（电子调速器，将电池提供的直流电转换为能够驱动电机的三相交流电）， 电机（驱动浆叶），桨叶（提供升力），电池。\n- **图传**。搜集飞控返回的图像和其他飞行参数的各项信息。","source":"_posts/四轴无人机研究：第一回.md","raw":"---\ntitle: 四轴无人机研究：第一回\ncategory: 无人机系列\ndate: 2023-07-31 10:27:23\ntags:\n---\n\n无人机在现今社会的各个角落，都扮演着极其重要的作用。那么对于我们普通人而言，其最大的价值角色，就是航拍。鄙人的第一台机器，就是大疆的mini一代。带着他去了无数的地方，给我留下了很多珍贵的镜头。但是很不幸，两年的时间，已经飞不起来了。本着充分利用资源的原则，我想借其**尸骨**，来稍微深入的研究一下四旋翼无人机的飞行原理，然后尝试能否，**借尸还魂**。\n\n<img src=\"/img/air.png\" alt=\"图片描述\" width=\"500\">\n\n\n#### 四旋翼无人机的大体构成\n- **飞控系统**。一般包括GPS记录经纬度的,气压计记录气压的、IMU惯性测量单元，计算三维空间中飞机姿态的各个参数的，指南针等。。。。\n- **遥控系统**。就是手柄遥控器。遥控器发出信号，飞控的信号接收模块接收信号后，执行相应的指令。\n- **动力系统**。一般包括：电调（电子调速器，将电池提供的直流电转换为能够驱动电机的三相交流电）， 电机（驱动浆叶），桨叶（提供升力），电池。\n- **图传**。搜集飞控返回的图像和其他飞行参数的各项信息。","slug":"四轴无人机研究：第一回","published":1,"updated":"2023-08-21T01:52:54.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxw3001mf8v761vm7vs8","content":"<p>无人机在现今社会的各个角落，都扮演着极其重要的作用。那么对于我们普通人而言，其最大的价值角色，就是航拍。鄙人的第一台机器，就是大疆的mini一代。带着他去了无数的地方，给我留下了很多珍贵的镜头。但是很不幸，两年的时间，已经飞不起来了。本着充分利用资源的原则，我想借其<strong>尸骨</strong>，来稍微深入的研究一下四旋翼无人机的飞行原理，然后尝试能否，<strong>借尸还魂</strong>。</p>\n<img src=\"/img/air.png\" alt=\"图片描述\" width=\"500\">\n\n\n<h4 id=\"四旋翼无人机的大体构成\"><a href=\"#四旋翼无人机的大体构成\" class=\"headerlink\" title=\"四旋翼无人机的大体构成\"></a>四旋翼无人机的大体构成</h4><ul>\n<li><strong>飞控系统</strong>。一般包括GPS记录经纬度的,气压计记录气压的、IMU惯性测量单元，计算三维空间中飞机姿态的各个参数的，指南针等。。。。</li>\n<li><strong>遥控系统</strong>。就是手柄遥控器。遥控器发出信号，飞控的信号接收模块接收信号后，执行相应的指令。</li>\n<li><strong>动力系统</strong>。一般包括：电调（电子调速器，将电池提供的直流电转换为能够驱动电机的三相交流电）， 电机（驱动浆叶），桨叶（提供升力），电池。</li>\n<li><strong>图传</strong>。搜集飞控返回的图像和其他飞行参数的各项信息。</li>\n</ul>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>无人机在现今社会的各个角落，都扮演着极其重要的作用。那么对于我们普通人而言，其最大的价值角色，就是航拍。鄙人的第一台机器，就是大疆的mini一代。带着他去了无数的地方，给我留下了很多珍贵的镜头。但是很不幸，两年的时间，已经飞不起来了。本着充分利用资源的原则，我想借其<strong>尸骨</strong>，来稍微深入的研究一下四旋翼无人机的飞行原理，然后尝试能否，<strong>借尸还魂</strong>。</p>\n<img src=\"/img/air.png\" alt=\"图片描述\" width=\"500\">\n\n\n<h4 id=\"四旋翼无人机的大体构成\"><a href=\"#四旋翼无人机的大体构成\" class=\"headerlink\" title=\"四旋翼无人机的大体构成\"></a>四旋翼无人机的大体构成</h4><ul>\n<li><strong>飞控系统</strong>。一般包括GPS记录经纬度的,气压计记录气压的、IMU惯性测量单元，计算三维空间中飞机姿态的各个参数的，指南针等。。。。</li>\n<li><strong>遥控系统</strong>。就是手柄遥控器。遥控器发出信号，飞控的信号接收模块接收信号后，执行相应的指令。</li>\n<li><strong>动力系统</strong>。一般包括：电调（电子调速器，将电池提供的直流电转换为能够驱动电机的三相交流电）， 电机（驱动浆叶），桨叶（提供升力），电池。</li>\n<li><strong>图传</strong>。搜集飞控返回的图像和其他飞行参数的各项信息。</li>\n</ul>\n"},{"title":"性能的考量：第三回","date":"2023-08-03T12:46:07.000Z","_content":"\n**本文主介绍canvas的性能优化策略**\n\n关于性能问题,实际上,针对于类似管理系统这样的项目而言,不需要关注太多,也没那必要.但是对于图形编程类的项目而言,则是至关重要的指标.关乎生死.\n### 先点名canvas的耗时因素\n1. 图形的数量\n2. 图形的大小。\n3. 高质量、大文件的图片（画在画布上）\n\n图形编程类的项目,关注性能问题的原因,在于交互体验。比如我们废了半天劲写了一个web端的cs射击游戏,当我兴奋的准备往前走两步时,发现页面直接给我来了个帧数级别的慢动作,江湖说法叫做\"卡成狗\"，用户体验几乎为0。这种完全不能玩的应用,如同垃圾。\n\n### 我们首先来定义一下, 什么叫做卡?\n\"卡顿\"原理可以解释为,每一帧js主线程执行的事情过多,导致帧内时间没来得及干完,即当前帧耗时超过分配的帧时间。那么什么是\"分配的帧时间?之前说了,60hz举例,一秒钟60帧,那么一帧的时间大约在16.7ms.所以,如果在一帧内的耗时超过了16.7ms,就会出现视觉层面的\"卡\"。目前主流的屏幕基本都是60hz,也就是显示器,以每秒60次的频率闪频,也就是一秒钟会有60帧,但我们人眼无法察觉。\n\n**在实践的项目中，我们遇到了一个这样的警告：**\n<img src=\"/img/p2.webp\" alt=\"图片描述\" width=\"500\">\n白话就是，“大哥，您在一帧时间内做的事情太多了，浏览器处理不过来了”。对项目的影响就是，拖拽和缩放视图导致不会很流畅。所以，为了解决卡的问题，我们该做点啥呢？\n\n1. canvas隔离。\ncanvas画布的更新，是以该节点为基础的，所以将需要重排或者重绘频率较高的图形,用单独的canvas隔离开,这样避免不必要的重绘成本。\n2. 事件的防抖节流处理。绘制的动作，不要频繁触发。\n3. 避免浮点运算\n> 虽然javascript提供了很方便的一些取整方法，像Math.floor，Math.ceil,parseInt，但是，国外友人做过测试，parseInt这个方法做了一些额外的工作（比如检测数据是不是有效\n> 的数值，parseInt 甚至先将参数转换成了字符串!），所以，直接用parseInt的话相对来说比较消耗性能。\n4. 局部渲染\n第一点中我们说过，canvas更新时以canvas节点为基础的，实际上这话说的不够严谨，因为我们可以有方法可以局部操作渲染，来避免这种更新方式，但需要做些额外的设置。具体参考canvas的clipAPI\n","source":"_posts/性能的考量：第三回.md","raw":"---\ntitle: 性能的考量：第三回\ncategory: 性能的考量\ndate: 2023-08-03 20:46:07\ntags:\n---\n\n**本文主介绍canvas的性能优化策略**\n\n关于性能问题,实际上,针对于类似管理系统这样的项目而言,不需要关注太多,也没那必要.但是对于图形编程类的项目而言,则是至关重要的指标.关乎生死.\n### 先点名canvas的耗时因素\n1. 图形的数量\n2. 图形的大小。\n3. 高质量、大文件的图片（画在画布上）\n\n图形编程类的项目,关注性能问题的原因,在于交互体验。比如我们废了半天劲写了一个web端的cs射击游戏,当我兴奋的准备往前走两步时,发现页面直接给我来了个帧数级别的慢动作,江湖说法叫做\"卡成狗\"，用户体验几乎为0。这种完全不能玩的应用,如同垃圾。\n\n### 我们首先来定义一下, 什么叫做卡?\n\"卡顿\"原理可以解释为,每一帧js主线程执行的事情过多,导致帧内时间没来得及干完,即当前帧耗时超过分配的帧时间。那么什么是\"分配的帧时间?之前说了,60hz举例,一秒钟60帧,那么一帧的时间大约在16.7ms.所以,如果在一帧内的耗时超过了16.7ms,就会出现视觉层面的\"卡\"。目前主流的屏幕基本都是60hz,也就是显示器,以每秒60次的频率闪频,也就是一秒钟会有60帧,但我们人眼无法察觉。\n\n**在实践的项目中，我们遇到了一个这样的警告：**\n<img src=\"/img/p2.webp\" alt=\"图片描述\" width=\"500\">\n白话就是，“大哥，您在一帧时间内做的事情太多了，浏览器处理不过来了”。对项目的影响就是，拖拽和缩放视图导致不会很流畅。所以，为了解决卡的问题，我们该做点啥呢？\n\n1. canvas隔离。\ncanvas画布的更新，是以该节点为基础的，所以将需要重排或者重绘频率较高的图形,用单独的canvas隔离开,这样避免不必要的重绘成本。\n2. 事件的防抖节流处理。绘制的动作，不要频繁触发。\n3. 避免浮点运算\n> 虽然javascript提供了很方便的一些取整方法，像Math.floor，Math.ceil,parseInt，但是，国外友人做过测试，parseInt这个方法做了一些额外的工作（比如检测数据是不是有效\n> 的数值，parseInt 甚至先将参数转换成了字符串!），所以，直接用parseInt的话相对来说比较消耗性能。\n4. 局部渲染\n第一点中我们说过，canvas更新时以canvas节点为基础的，实际上这话说的不够严谨，因为我们可以有方法可以局部操作渲染，来避免这种更新方式，但需要做些额外的设置。具体参考canvas的clipAPI\n","slug":"性能的考量：第三回","published":1,"updated":"2023-08-21T01:52:54.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxw3001pf8v72s840mxa","content":"<p><strong>本文主介绍canvas的性能优化策略</strong></p>\n<p>关于性能问题,实际上,针对于类似管理系统这样的项目而言,不需要关注太多,也没那必要.但是对于图形编程类的项目而言,则是至关重要的指标.关乎生死.</p>\n<h3 id=\"先点名canvas的耗时因素\"><a href=\"#先点名canvas的耗时因素\" class=\"headerlink\" title=\"先点名canvas的耗时因素\"></a>先点名canvas的耗时因素</h3><ol>\n<li>图形的数量</li>\n<li>图形的大小。</li>\n<li>高质量、大文件的图片（画在画布上）</li>\n</ol>\n<p>图形编程类的项目,关注性能问题的原因,在于交互体验。比如我们废了半天劲写了一个web端的cs射击游戏,当我兴奋的准备往前走两步时,发现页面直接给我来了个帧数级别的慢动作,江湖说法叫做”卡成狗”，用户体验几乎为0。这种完全不能玩的应用,如同垃圾。</p>\n<h3 id=\"我们首先来定义一下-什么叫做卡\"><a href=\"#我们首先来定义一下-什么叫做卡\" class=\"headerlink\" title=\"我们首先来定义一下, 什么叫做卡?\"></a>我们首先来定义一下, 什么叫做卡?</h3><p>“卡顿”原理可以解释为,每一帧js主线程执行的事情过多,导致帧内时间没来得及干完,即当前帧耗时超过分配的帧时间。那么什么是”分配的帧时间?之前说了,60hz举例,一秒钟60帧,那么一帧的时间大约在16.7ms.所以,如果在一帧内的耗时超过了16.7ms,就会出现视觉层面的”卡”。目前主流的屏幕基本都是60hz,也就是显示器,以每秒60次的频率闪频,也就是一秒钟会有60帧,但我们人眼无法察觉。</p>\n<p><strong>在实践的项目中，我们遇到了一个这样的警告：</strong><br><img src=\"/img/p2.webp\" alt=\"图片描述\" width=\"500\"><br>白话就是，“大哥，您在一帧时间内做的事情太多了，浏览器处理不过来了”。对项目的影响就是，拖拽和缩放视图导致不会很流畅。所以，为了解决卡的问题，我们该做点啥呢？</p>\n<ol>\n<li>canvas隔离。<br>canvas画布的更新，是以该节点为基础的，所以将需要重排或者重绘频率较高的图形,用单独的canvas隔离开,这样避免不必要的重绘成本。</li>\n<li>事件的防抖节流处理。绘制的动作，不要频繁触发。</li>\n<li>避免浮点运算<blockquote>\n<p>虽然javascript提供了很方便的一些取整方法，像Math.floor，Math.ceil,parseInt，但是，国外友人做过测试，parseInt这个方法做了一些额外的工作（比如检测数据是不是有效<br>的数值，parseInt 甚至先将参数转换成了字符串!），所以，直接用parseInt的话相对来说比较消耗性能。</p>\n</blockquote>\n</li>\n<li>局部渲染<br>第一点中我们说过，canvas更新时以canvas节点为基础的，实际上这话说的不够严谨，因为我们可以有方法可以局部操作渲染，来避免这种更新方式，但需要做些额外的设置。具体参考canvas的clipAPI</li>\n</ol>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p><strong>本文主介绍canvas的性能优化策略</strong></p>\n<p>关于性能问题,实际上,针对于类似管理系统这样的项目而言,不需要关注太多,也没那必要.但是对于图形编程类的项目而言,则是至关重要的指标.关乎生死.</p>\n<h3 id=\"先点名canvas的耗时因素\"><a href=\"#先点名canvas的耗时因素\" class=\"headerlink\" title=\"先点名canvas的耗时因素\"></a>先点名canvas的耗时因素</h3><ol>\n<li>图形的数量</li>\n<li>图形的大小。</li>\n<li>高质量、大文件的图片（画在画布上）</li>\n</ol>\n<p>图形编程类的项目,关注性能问题的原因,在于交互体验。比如我们废了半天劲写了一个web端的cs射击游戏,当我兴奋的准备往前走两步时,发现页面直接给我来了个帧数级别的慢动作,江湖说法叫做”卡成狗”，用户体验几乎为0。这种完全不能玩的应用,如同垃圾。</p>\n<h3 id=\"我们首先来定义一下-什么叫做卡\"><a href=\"#我们首先来定义一下-什么叫做卡\" class=\"headerlink\" title=\"我们首先来定义一下, 什么叫做卡?\"></a>我们首先来定义一下, 什么叫做卡?</h3><p>“卡顿”原理可以解释为,每一帧js主线程执行的事情过多,导致帧内时间没来得及干完,即当前帧耗时超过分配的帧时间。那么什么是”分配的帧时间?之前说了,60hz举例,一秒钟60帧,那么一帧的时间大约在16.7ms.所以,如果在一帧内的耗时超过了16.7ms,就会出现视觉层面的”卡”。目前主流的屏幕基本都是60hz,也就是显示器,以每秒60次的频率闪频,也就是一秒钟会有60帧,但我们人眼无法察觉。</p>\n<p><strong>在实践的项目中，我们遇到了一个这样的警告：</strong><br><img src=\"/img/p2.webp\" alt=\"图片描述\" width=\"500\"><br>白话就是，“大哥，您在一帧时间内做的事情太多了，浏览器处理不过来了”。对项目的影响就是，拖拽和缩放视图导致不会很流畅。所以，为了解决卡的问题，我们该做点啥呢？</p>\n<ol>\n<li>canvas隔离。<br>canvas画布的更新，是以该节点为基础的，所以将需要重排或者重绘频率较高的图形,用单独的canvas隔离开,这样避免不必要的重绘成本。</li>\n<li>事件的防抖节流处理。绘制的动作，不要频繁触发。</li>\n<li>避免浮点运算<blockquote>\n<p>虽然javascript提供了很方便的一些取整方法，像Math.floor，Math.ceil,parseInt，但是，国外友人做过测试，parseInt这个方法做了一些额外的工作（比如检测数据是不是有效<br>的数值，parseInt 甚至先将参数转换成了字符串!），所以，直接用parseInt的话相对来说比较消耗性能。</p>\n</blockquote>\n</li>\n<li>局部渲染<br>第一点中我们说过，canvas更新时以canvas节点为基础的，实际上这话说的不够严谨，因为我们可以有方法可以局部操作渲染，来避免这种更新方式，但需要做些额外的设置。具体参考canvas的clipAPI</li>\n</ol>\n"},{"title":"性能的考量：第四回","date":"2023-08-03T13:19:26.000Z","_content":"**本文从代码层面出发，介绍一些小技巧以提升性能**\n\n古语有云，千里之堤，溃于蚁穴，性能的问题如出一辙。尤其是在图形化编程的项目中，日积月累的烂代码，导致最终页面的崩盘。而此时，却束手无策，只能大量重构。因此，在写每一行代码的时候，都应该对性能有所考虑。\n\n#### 1.HTML、JS、CSS三者解耦，各司其职\nhtml是数据，js是行为，css负责外观。三者代表了三个层面，应该各司其职互不干扰.如下代码:\n```javascript\nconst dom = document.getElementById('id')\ndom.style.height = 100 + 'px'\ndom.style.width = 100 + 'px'\n```\ncss才应该负责样式层，所以任何的样式问题都应该通过css文件解决。而上述代码则是js承担了页面显示的任务。造成js和css的耦合。但是这种需求有时候不可避免，我们可以使用替代方案，降低耦合度：\n```javascript\nconst dom = document.getElementById('id')\ndom.className = 'dddd'\n```\n通过设置类名的方式，达到我们目的的同时，还能保持css负责显示的底线。\n\n#### 2.事件处理逻辑和应用程序逻辑分隔开\n```javascript\nconst handleClick = (event) => {\n  if (event.keyCode === 13) {\n    const dom = document.getElementById('dom')\n    // ......\n    // ......\n  }\n}\n```\n上面代码中，当按下某个code为13的案件后，触发了handleClick函数，然后获取dom进行后续的操作。在这个实例中，从获取dom开始的后续操作，就是应用程序的逻辑，需要严格提炼出来。改造如下：\n```javascript\nconst Operation = () => {\n  const dom = document.getElementById('dom')\n  // ......\n  // ......\n}\n\nconst handleClick = (event) => {\n  if (event.keyCode === 13) {\n    Operation()\n  }\n}\n```\n为什么要这么做？理由很简单，降低耦合度。设想一下，倘若现在不止一个事件会触发operation函数所做的事情呢？我是不是在每一个休要触发的地方都加上operation函数中的那托代码？这一点极其的重要，工程实践最佳。**事件处理程序应该专注于处理时间的分发，后续的处理必须严格交给应用程序的逻辑函数。**\n\n#### 3.避免全局查找\n**只要函数中存在引用超过两次的全局对象，就应该把这个变量保存为局部变量。**\n\n#### 4.if-else 较为复杂的时候，使用switch替换。同时将最可能的情况放在前面，最不可能的往后放，以进一步提升性能\n尽量避免一坨一坨的if-else\n\n#### 5.一条可以执行多个操作的语句，比多条语句中每个语句执行一个操作要快\n```javascript\nlet v1 = 100\nlet v2 = [100, 200]\nlet v3 = 'asdasd'\n.....\n.....\nlet v1 = 100,\nv2 = [100, 200],\nv3 = 'asdasd'\n```","source":"_posts/性能的考量：第四回.md","raw":"---\ntitle: 性能的考量：第四回\ncategory: 性能的考量\ndate: 2023-08-03 21:19:26\ntags:\n---\n**本文从代码层面出发，介绍一些小技巧以提升性能**\n\n古语有云，千里之堤，溃于蚁穴，性能的问题如出一辙。尤其是在图形化编程的项目中，日积月累的烂代码，导致最终页面的崩盘。而此时，却束手无策，只能大量重构。因此，在写每一行代码的时候，都应该对性能有所考虑。\n\n#### 1.HTML、JS、CSS三者解耦，各司其职\nhtml是数据，js是行为，css负责外观。三者代表了三个层面，应该各司其职互不干扰.如下代码:\n```javascript\nconst dom = document.getElementById('id')\ndom.style.height = 100 + 'px'\ndom.style.width = 100 + 'px'\n```\ncss才应该负责样式层，所以任何的样式问题都应该通过css文件解决。而上述代码则是js承担了页面显示的任务。造成js和css的耦合。但是这种需求有时候不可避免，我们可以使用替代方案，降低耦合度：\n```javascript\nconst dom = document.getElementById('id')\ndom.className = 'dddd'\n```\n通过设置类名的方式，达到我们目的的同时，还能保持css负责显示的底线。\n\n#### 2.事件处理逻辑和应用程序逻辑分隔开\n```javascript\nconst handleClick = (event) => {\n  if (event.keyCode === 13) {\n    const dom = document.getElementById('dom')\n    // ......\n    // ......\n  }\n}\n```\n上面代码中，当按下某个code为13的案件后，触发了handleClick函数，然后获取dom进行后续的操作。在这个实例中，从获取dom开始的后续操作，就是应用程序的逻辑，需要严格提炼出来。改造如下：\n```javascript\nconst Operation = () => {\n  const dom = document.getElementById('dom')\n  // ......\n  // ......\n}\n\nconst handleClick = (event) => {\n  if (event.keyCode === 13) {\n    Operation()\n  }\n}\n```\n为什么要这么做？理由很简单，降低耦合度。设想一下，倘若现在不止一个事件会触发operation函数所做的事情呢？我是不是在每一个休要触发的地方都加上operation函数中的那托代码？这一点极其的重要，工程实践最佳。**事件处理程序应该专注于处理时间的分发，后续的处理必须严格交给应用程序的逻辑函数。**\n\n#### 3.避免全局查找\n**只要函数中存在引用超过两次的全局对象，就应该把这个变量保存为局部变量。**\n\n#### 4.if-else 较为复杂的时候，使用switch替换。同时将最可能的情况放在前面，最不可能的往后放，以进一步提升性能\n尽量避免一坨一坨的if-else\n\n#### 5.一条可以执行多个操作的语句，比多条语句中每个语句执行一个操作要快\n```javascript\nlet v1 = 100\nlet v2 = [100, 200]\nlet v3 = 'asdasd'\n.....\n.....\nlet v1 = 100,\nv2 = [100, 200],\nv3 = 'asdasd'\n```","slug":"性能的考量：第四回","published":1,"updated":"2023-08-21T01:52:54.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxw4001rf8v79g5n0twl","content":"<p><strong>本文从代码层面出发，介绍一些小技巧以提升性能</strong></p>\n<p>古语有云，千里之堤，溃于蚁穴，性能的问题如出一辙。尤其是在图形化编程的项目中，日积月累的烂代码，导致最终页面的崩盘。而此时，却束手无策，只能大量重构。因此，在写每一行代码的时候，都应该对性能有所考虑。</p>\n<h4 id=\"1-HTML、JS、CSS三者解耦，各司其职\"><a href=\"#1-HTML、JS、CSS三者解耦，各司其职\" class=\"headerlink\" title=\"1.HTML、JS、CSS三者解耦，各司其职\"></a>1.HTML、JS、CSS三者解耦，各司其职</h4><p>html是数据，js是行为，css负责外观。三者代表了三个层面，应该各司其职互不干扰.如下代码:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> dom = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;id&#x27;</span>)</span><br><span class=\"line\">dom.<span class=\"property\">style</span>.<span class=\"property\">height</span> = <span class=\"number\">100</span> + <span class=\"string\">&#x27;px&#x27;</span></span><br><span class=\"line\">dom.<span class=\"property\">style</span>.<span class=\"property\">width</span> = <span class=\"number\">100</span> + <span class=\"string\">&#x27;px&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>css才应该负责样式层，所以任何的样式问题都应该通过css文件解决。而上述代码则是js承担了页面显示的任务。造成js和css的耦合。但是这种需求有时候不可避免，我们可以使用替代方案，降低耦合度：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> dom = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;id&#x27;</span>)</span><br><span class=\"line\">dom.<span class=\"property\">className</span> = <span class=\"string\">&#x27;dddd&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>通过设置类名的方式，达到我们目的的同时，还能保持css负责显示的底线。</p>\n<h4 id=\"2-事件处理逻辑和应用程序逻辑分隔开\"><a href=\"#2-事件处理逻辑和应用程序逻辑分隔开\" class=\"headerlink\" title=\"2.事件处理逻辑和应用程序逻辑分隔开\"></a>2.事件处理逻辑和应用程序逻辑分隔开</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">handleClick</span> = (<span class=\"params\">event</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (event.<span class=\"property\">keyCode</span> === <span class=\"number\">13</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> dom = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;dom&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\">// ......</span></span><br><span class=\"line\">    <span class=\"comment\">// ......</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，当按下某个code为13的案件后，触发了handleClick函数，然后获取dom进行后续的操作。在这个实例中，从获取dom开始的后续操作，就是应用程序的逻辑，需要严格提炼出来。改造如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">Operation</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dom = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;dom&#x27;</span>)</span><br><span class=\"line\">  <span class=\"comment\">// ......</span></span><br><span class=\"line\">  <span class=\"comment\">// ......</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">handleClick</span> = (<span class=\"params\">event</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (event.<span class=\"property\">keyCode</span> === <span class=\"number\">13</span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Operation</span>()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为什么要这么做？理由很简单，降低耦合度。设想一下，倘若现在不止一个事件会触发operation函数所做的事情呢？我是不是在每一个休要触发的地方都加上operation函数中的那托代码？这一点极其的重要，工程实践最佳。<strong>事件处理程序应该专注于处理时间的分发，后续的处理必须严格交给应用程序的逻辑函数。</strong></p>\n<h4 id=\"3-避免全局查找\"><a href=\"#3-避免全局查找\" class=\"headerlink\" title=\"3.避免全局查找\"></a>3.避免全局查找</h4><p><strong>只要函数中存在引用超过两次的全局对象，就应该把这个变量保存为局部变量。</strong></p>\n<h4 id=\"4-if-else-较为复杂的时候，使用switch替换。同时将最可能的情况放在前面，最不可能的往后放，以进一步提升性能\"><a href=\"#4-if-else-较为复杂的时候，使用switch替换。同时将最可能的情况放在前面，最不可能的往后放，以进一步提升性能\" class=\"headerlink\" title=\"4.if-else 较为复杂的时候，使用switch替换。同时将最可能的情况放在前面，最不可能的往后放，以进一步提升性能\"></a>4.if-else 较为复杂的时候，使用switch替换。同时将最可能的情况放在前面，最不可能的往后放，以进一步提升性能</h4><p>尽量避免一坨一坨的if-else</p>\n<h4 id=\"5-一条可以执行多个操作的语句，比多条语句中每个语句执行一个操作要快\"><a href=\"#5-一条可以执行多个操作的语句，比多条语句中每个语句执行一个操作要快\" class=\"headerlink\" title=\"5.一条可以执行多个操作的语句，比多条语句中每个语句执行一个操作要快\"></a>5.一条可以执行多个操作的语句，比多条语句中每个语句执行一个操作要快</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> v1 = <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> v2 = [<span class=\"number\">100</span>, <span class=\"number\">200</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> v3 = <span class=\"string\">&#x27;asdasd&#x27;</span></span><br><span class=\"line\">.....</span><br><span class=\"line\">.....</span><br><span class=\"line\"><span class=\"keyword\">let</span> v1 = <span class=\"number\">100</span>,</span><br><span class=\"line\">v2 = [<span class=\"number\">100</span>, <span class=\"number\">200</span>],</span><br><span class=\"line\">v3 = <span class=\"string\">&#x27;asdasd&#x27;</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"cover":false,"excerpt":"","more":"<p><strong>本文从代码层面出发，介绍一些小技巧以提升性能</strong></p>\n<p>古语有云，千里之堤，溃于蚁穴，性能的问题如出一辙。尤其是在图形化编程的项目中，日积月累的烂代码，导致最终页面的崩盘。而此时，却束手无策，只能大量重构。因此，在写每一行代码的时候，都应该对性能有所考虑。</p>\n<h4 id=\"1-HTML、JS、CSS三者解耦，各司其职\"><a href=\"#1-HTML、JS、CSS三者解耦，各司其职\" class=\"headerlink\" title=\"1.HTML、JS、CSS三者解耦，各司其职\"></a>1.HTML、JS、CSS三者解耦，各司其职</h4><p>html是数据，js是行为，css负责外观。三者代表了三个层面，应该各司其职互不干扰.如下代码:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> dom = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;id&#x27;</span>)</span><br><span class=\"line\">dom.<span class=\"property\">style</span>.<span class=\"property\">height</span> = <span class=\"number\">100</span> + <span class=\"string\">&#x27;px&#x27;</span></span><br><span class=\"line\">dom.<span class=\"property\">style</span>.<span class=\"property\">width</span> = <span class=\"number\">100</span> + <span class=\"string\">&#x27;px&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>css才应该负责样式层，所以任何的样式问题都应该通过css文件解决。而上述代码则是js承担了页面显示的任务。造成js和css的耦合。但是这种需求有时候不可避免，我们可以使用替代方案，降低耦合度：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> dom = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;id&#x27;</span>)</span><br><span class=\"line\">dom.<span class=\"property\">className</span> = <span class=\"string\">&#x27;dddd&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>通过设置类名的方式，达到我们目的的同时，还能保持css负责显示的底线。</p>\n<h4 id=\"2-事件处理逻辑和应用程序逻辑分隔开\"><a href=\"#2-事件处理逻辑和应用程序逻辑分隔开\" class=\"headerlink\" title=\"2.事件处理逻辑和应用程序逻辑分隔开\"></a>2.事件处理逻辑和应用程序逻辑分隔开</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">handleClick</span> = (<span class=\"params\">event</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (event.<span class=\"property\">keyCode</span> === <span class=\"number\">13</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> dom = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;dom&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\">// ......</span></span><br><span class=\"line\">    <span class=\"comment\">// ......</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，当按下某个code为13的案件后，触发了handleClick函数，然后获取dom进行后续的操作。在这个实例中，从获取dom开始的后续操作，就是应用程序的逻辑，需要严格提炼出来。改造如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">Operation</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dom = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;dom&#x27;</span>)</span><br><span class=\"line\">  <span class=\"comment\">// ......</span></span><br><span class=\"line\">  <span class=\"comment\">// ......</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">handleClick</span> = (<span class=\"params\">event</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (event.<span class=\"property\">keyCode</span> === <span class=\"number\">13</span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Operation</span>()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为什么要这么做？理由很简单，降低耦合度。设想一下，倘若现在不止一个事件会触发operation函数所做的事情呢？我是不是在每一个休要触发的地方都加上operation函数中的那托代码？这一点极其的重要，工程实践最佳。<strong>事件处理程序应该专注于处理时间的分发，后续的处理必须严格交给应用程序的逻辑函数。</strong></p>\n<h4 id=\"3-避免全局查找\"><a href=\"#3-避免全局查找\" class=\"headerlink\" title=\"3.避免全局查找\"></a>3.避免全局查找</h4><p><strong>只要函数中存在引用超过两次的全局对象，就应该把这个变量保存为局部变量。</strong></p>\n<h4 id=\"4-if-else-较为复杂的时候，使用switch替换。同时将最可能的情况放在前面，最不可能的往后放，以进一步提升性能\"><a href=\"#4-if-else-较为复杂的时候，使用switch替换。同时将最可能的情况放在前面，最不可能的往后放，以进一步提升性能\" class=\"headerlink\" title=\"4.if-else 较为复杂的时候，使用switch替换。同时将最可能的情况放在前面，最不可能的往后放，以进一步提升性能\"></a>4.if-else 较为复杂的时候，使用switch替换。同时将最可能的情况放在前面，最不可能的往后放，以进一步提升性能</h4><p>尽量避免一坨一坨的if-else</p>\n<h4 id=\"5-一条可以执行多个操作的语句，比多条语句中每个语句执行一个操作要快\"><a href=\"#5-一条可以执行多个操作的语句，比多条语句中每个语句执行一个操作要快\" class=\"headerlink\" title=\"5.一条可以执行多个操作的语句，比多条语句中每个语句执行一个操作要快\"></a>5.一条可以执行多个操作的语句，比多条语句中每个语句执行一个操作要快</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> v1 = <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> v2 = [<span class=\"number\">100</span>, <span class=\"number\">200</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> v3 = <span class=\"string\">&#x27;asdasd&#x27;</span></span><br><span class=\"line\">.....</span><br><span class=\"line\">.....</span><br><span class=\"line\"><span class=\"keyword\">let</span> v1 = <span class=\"number\">100</span>,</span><br><span class=\"line\">v2 = [<span class=\"number\">100</span>, <span class=\"number\">200</span>],</span><br><span class=\"line\">v3 = <span class=\"string\">&#x27;asdasd&#x27;</span></span><br></pre></td></tr></table></figure>"},{"title":"拥塞窗口的策略机制","date":"2023-08-09T15:44:03.000Z","_content":"**本文主要介绍tcp数据包的传输策略：拥塞窗口**\n请大家思考一个问题，为什么说TCP协议是可靠的？是什么东西保证了他的可靠？答案就是“**拥塞窗口机制**”：拥塞窗口机制确保了，在指定窗口大小的情况下，传输的数据包是完整未丢失的，也就是可靠的。\n\n所谓的“拥塞窗口”是指：在接收方确认数据包之前，发送方可以发出的tcp包的个数。假如拥塞窗口大小为1，那么发送方在发出一个数据包之后，就只能等待，直到接收到接收方的确认信息之后，再发送第二个数据包。\n那么大小是如何确定的呢？这就涉及到另一个概念**慢启动**。慢启动的目标，是为了让新链接搞清楚，当前网络的负载状况。默认值可以从1开始，发送方再接收到第一个包的确认后，除了发送第二个包以外，还可以额外再发送一个，也就是一个确认对应俩，指数级别的增加，直到达到阈值。若中间出现丢包情况，自动回缩窗口大小，以适应当前网络状况，匹配出最佳大小。\n","source":"_posts/拥塞窗口的策略机制.md","raw":"---\ntitle: 拥塞窗口的策略机制\ncategory: 网络杂谈\ndate: 2023-08-09 23:44:03\ntags:\n---\n**本文主要介绍tcp数据包的传输策略：拥塞窗口**\n请大家思考一个问题，为什么说TCP协议是可靠的？是什么东西保证了他的可靠？答案就是“**拥塞窗口机制**”：拥塞窗口机制确保了，在指定窗口大小的情况下，传输的数据包是完整未丢失的，也就是可靠的。\n\n所谓的“拥塞窗口”是指：在接收方确认数据包之前，发送方可以发出的tcp包的个数。假如拥塞窗口大小为1，那么发送方在发出一个数据包之后，就只能等待，直到接收到接收方的确认信息之后，再发送第二个数据包。\n那么大小是如何确定的呢？这就涉及到另一个概念**慢启动**。慢启动的目标，是为了让新链接搞清楚，当前网络的负载状况。默认值可以从1开始，发送方再接收到第一个包的确认后，除了发送第二个包以外，还可以额外再发送一个，也就是一个确认对应俩，指数级别的增加，直到达到阈值。若中间出现丢包情况，自动回缩窗口大小，以适应当前网络状况，匹配出最佳大小。\n","slug":"拥塞窗口的策略机制","published":1,"updated":"2023-08-21T01:52:54.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxw5001tf8v7ei1y8x5m","content":"<p><strong>本文主要介绍tcp数据包的传输策略：拥塞窗口</strong><br>请大家思考一个问题，为什么说TCP协议是可靠的？是什么东西保证了他的可靠？答案就是“<strong>拥塞窗口机制</strong>”：拥塞窗口机制确保了，在指定窗口大小的情况下，传输的数据包是完整未丢失的，也就是可靠的。</p>\n<p>所谓的“拥塞窗口”是指：在接收方确认数据包之前，发送方可以发出的tcp包的个数。假如拥塞窗口大小为1，那么发送方在发出一个数据包之后，就只能等待，直到接收到接收方的确认信息之后，再发送第二个数据包。<br>那么大小是如何确定的呢？这就涉及到另一个概念<strong>慢启动</strong>。慢启动的目标，是为了让新链接搞清楚，当前网络的负载状况。默认值可以从1开始，发送方再接收到第一个包的确认后，除了发送第二个包以外，还可以额外再发送一个，也就是一个确认对应俩，指数级别的增加，直到达到阈值。若中间出现丢包情况，自动回缩窗口大小，以适应当前网络状况，匹配出最佳大小。</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p><strong>本文主要介绍tcp数据包的传输策略：拥塞窗口</strong><br>请大家思考一个问题，为什么说TCP协议是可靠的？是什么东西保证了他的可靠？答案就是“<strong>拥塞窗口机制</strong>”：拥塞窗口机制确保了，在指定窗口大小的情况下，传输的数据包是完整未丢失的，也就是可靠的。</p>\n<p>所谓的“拥塞窗口”是指：在接收方确认数据包之前，发送方可以发出的tcp包的个数。假如拥塞窗口大小为1，那么发送方在发出一个数据包之后，就只能等待，直到接收到接收方的确认信息之后，再发送第二个数据包。<br>那么大小是如何确定的呢？这就涉及到另一个概念<strong>慢启动</strong>。慢启动的目标，是为了让新链接搞清楚，当前网络的负载状况。默认值可以从1开始，发送方再接收到第一个包的确认后，除了发送第二个包以外，还可以额外再发送一个，也就是一个确认对应俩，指数级别的增加，直到达到阈值。若中间出现丢包情况，自动回缩窗口大小，以适应当前网络状况，匹配出最佳大小。</p>\n"},{"title":"性能的考量：第二回","date":"2023-08-03T12:36:04.000Z","_content":"**本文主要是介绍一些实用的性能相关的工具**\n\n#### 工具traceroute\n我们都知道请求会通过不止一台路由器去跳转，直到找到最终的目标ip服务器。那么这个工具能够帮助你查看个中的细节。\n<img src=\"/img/tra.jpg\" alt=\"图片描述\" width=\"500\">\n\n#### performance对象\n运行一个前端项目，除了通过开发者工具中的memory组件，查看内存使用情况，实质上浏览器也提供了api。\n- 通过window的performance属性，我们能够看到一些陌生的字段。包含memory、navigation、timing和eventCounts。\n<img src=\"/img/p.jpg\" alt=\"图片描述\" width=\"500\">\n\n- memory字段。很显然，就是我们想看的内存的大小。usedJSHeapSize表示：JS 对象占用的内存数。totalJSHeapSize表示：可使用的内存大小。jsHeapSizeLimit表示：内存大小限制。通常，usedJSHeapSize不能大于totalJSHeapSize，如果大于，有可能出现了内存泄漏。\n<img src=\"/img/p2.webp\" alt=\"图片描述\" width=\"500\">\n","source":"_posts/性能的考量：第二回.md","raw":"---\ntitle: 性能的考量：第二回\ncategory: 性能的考量\ndate: 2023-08-03 20:36:04\ntags:\n---\n**本文主要是介绍一些实用的性能相关的工具**\n\n#### 工具traceroute\n我们都知道请求会通过不止一台路由器去跳转，直到找到最终的目标ip服务器。那么这个工具能够帮助你查看个中的细节。\n<img src=\"/img/tra.jpg\" alt=\"图片描述\" width=\"500\">\n\n#### performance对象\n运行一个前端项目，除了通过开发者工具中的memory组件，查看内存使用情况，实质上浏览器也提供了api。\n- 通过window的performance属性，我们能够看到一些陌生的字段。包含memory、navigation、timing和eventCounts。\n<img src=\"/img/p.jpg\" alt=\"图片描述\" width=\"500\">\n\n- memory字段。很显然，就是我们想看的内存的大小。usedJSHeapSize表示：JS 对象占用的内存数。totalJSHeapSize表示：可使用的内存大小。jsHeapSizeLimit表示：内存大小限制。通常，usedJSHeapSize不能大于totalJSHeapSize，如果大于，有可能出现了内存泄漏。\n<img src=\"/img/p2.webp\" alt=\"图片描述\" width=\"500\">\n","slug":"性能的考量：第二回","published":1,"updated":"2023-08-21T01:52:54.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxw6001wf8v754m4fnun","content":"<p><strong>本文主要是介绍一些实用的性能相关的工具</strong></p>\n<h4 id=\"工具traceroute\"><a href=\"#工具traceroute\" class=\"headerlink\" title=\"工具traceroute\"></a>工具traceroute</h4><p>我们都知道请求会通过不止一台路由器去跳转，直到找到最终的目标ip服务器。那么这个工具能够帮助你查看个中的细节。<br><img src=\"/img/tra.jpg\" alt=\"图片描述\" width=\"500\"></p>\n<h4 id=\"performance对象\"><a href=\"#performance对象\" class=\"headerlink\" title=\"performance对象\"></a>performance对象</h4><p>运行一个前端项目，除了通过开发者工具中的memory组件，查看内存使用情况，实质上浏览器也提供了api。</p>\n<ul>\n<li><p>通过window的performance属性，我们能够看到一些陌生的字段。包含memory、navigation、timing和eventCounts。</p>\n<img src=\"/img/p.jpg\" alt=\"图片描述\" width=\"500\">\n</li>\n<li><p>memory字段。很显然，就是我们想看的内存的大小。usedJSHeapSize表示：JS 对象占用的内存数。totalJSHeapSize表示：可使用的内存大小。jsHeapSizeLimit表示：内存大小限制。通常，usedJSHeapSize不能大于totalJSHeapSize，如果大于，有可能出现了内存泄漏。</p>\n<img src=\"/img/p2.webp\" alt=\"图片描述\" width=\"500\"></li>\n</ul>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p><strong>本文主要是介绍一些实用的性能相关的工具</strong></p>\n<h4 id=\"工具traceroute\"><a href=\"#工具traceroute\" class=\"headerlink\" title=\"工具traceroute\"></a>工具traceroute</h4><p>我们都知道请求会通过不止一台路由器去跳转，直到找到最终的目标ip服务器。那么这个工具能够帮助你查看个中的细节。<br><img src=\"/img/tra.jpg\" alt=\"图片描述\" width=\"500\"></p>\n<h4 id=\"performance对象\"><a href=\"#performance对象\" class=\"headerlink\" title=\"performance对象\"></a>performance对象</h4><p>运行一个前端项目，除了通过开发者工具中的memory组件，查看内存使用情况，实质上浏览器也提供了api。</p>\n<ul>\n<li><p>通过window的performance属性，我们能够看到一些陌生的字段。包含memory、navigation、timing和eventCounts。</p>\n<img src=\"/img/p.jpg\" alt=\"图片描述\" width=\"500\">\n</li>\n<li><p>memory字段。很显然，就是我们想看的内存的大小。usedJSHeapSize表示：JS 对象占用的内存数。totalJSHeapSize表示：可使用的内存大小。jsHeapSizeLimit表示：内存大小限制。通常，usedJSHeapSize不能大于totalJSHeapSize，如果大于，有可能出现了内存泄漏。</p>\n<img src=\"/img/p2.webp\" alt=\"图片描述\" width=\"500\"></li>\n</ul>\n"},{"title":"谷歌插件流程：第一回","date":"2023-08-03T13:55:39.000Z","_content":"相信经常使用chrome的小伙伴们，对其丰富的插件工具不会陌生。比如下载页面视频、音乐等等等。那么这些工具究竟是如何编写的呢？本文将以谷歌官方实例为基础，简单介绍一下chrome插件的开发流程，我们最终的目标，是写一个自己的视频下载器插件。部分内容参考下面地址文章\n> http://runxinzhi.com/wintertone-p-12053751.html\n\n#### 1. 第一步创建一个空的文件夹，后创建manifest.json文件，可以理解为整个插件的名片，代码如下。\n```json\n{\n  \"name\": \"Ta-da\",\n  \"description\": \"download_zhihu_short_video\",\n  \"version\": \"1.0\",\n  \"manifest_version\": 3,\n  \"background\": {\n    \"service_worker\": \"background.js\"\n  },\n  \"permissions\": [\"storage\", \"activeTab\", \"scripting\"],\n  \"action\": {\n    \"default_popup\": \"popup.html\"\n  },\n  \"icons\": {\n    \"128\": \"/images/icon.png\"\n  }\n}  \n```\n- **service_worker**: 确定js文件\n- **default_popup**： 确定点击图标后的html\n- **icons**: 配置图标\n\n#### 2. 创建background.js文件。manifest.json文件中的background字段，是一个包含service_worker属性的对象，可以理解为该插件的环境，官方叫做服务视图。这里我们指定服务视图为background.js文件，代码如下：\n```javascript\nlet color = 'red';\nchrome.runtime.onInstalled.addListener(() => {\n  chrome.storage.sync.set({ color });\n});\n// html文件如下:\n<!DOCTYPE html>\n<html>\n  <head>\n    <link rel=\"stylesheet\" href=\"button.css\">\n  </head>\n  <body>\n    <button id=\"changeColor\"></button>\n    <script src=\"popup.js\"></script>\n  </body>\n</html>\n{/* css */}\nbutton {\n  height: 30px;\n  width: 30px;\n  outline: none;\n  margin: 10px;\n  border: none;\n  border-radius: 2px;\n}\n\nbutton.current {\n  box-shadow: 0 0 0 2px white,\n              0 0 0 4px black;\n}\n\n```\n在html中我们引入了一个css和popupjs文件，同时定义了一个按钮。其中popupjs代码如下：\n```javascript\n\n// Initialize butotn with users's prefered color\nlet changeColor = document.getElementById(\"changeColor\");\nchrome.storage.sync.get(\"color\", ({ color }) => {\n  changeColor.style.backgroundColor = color;\n});\n\n// When the button is clicked, inject setPageBackgroundColor into current page\nchangeColor.addEventListener(\"click\", async () => {\n  let [tab] = await chrome.tabs.query({ active: true, currentWindow: true });\n  chrome.scripting.executeScript({\n    target: { tabId: tab.id },\n    function: setPageBackgroundColor,\n  });\n});\n\n// The body of this function will be execuetd as a content script inside the\n// current page\nfunction setPageBackgroundColor() {\n  chrome.storage.sync.get(\"color\", ({ color }) => {\n    document.body.style.backgroundColor = color\n  });\n}\n```\n该文件我们都做了啥？\n- 先是从chrome.storage中拿到color这个变量，然后改变了按钮的样式。这个很类似ipc，目的在于渲染进程和主进程的通信。此处就可以理解为渲染进程从主进程中拿到了一个叫做color的变量。\n- 监听按钮的点击事件，一旦点击，执行脚本**executeScript**。此处的事件回调就是改了下body的背景色。这一步,实际上就是脚本注入.\n**到目前为止，我们已经可以把当前文件夹作为插件文件夹导入chrome浏览器中。首先在地址栏中输入chrome://extensions/打开扩展程序页面，点击页面顶部第一个选项“加载已解压的扩展程序”导入文件夹，然后就能看到如下所示的插件卡片：**\n<img src=\"/img/chrome1.png\" alt=\"图片描述\" width=\"500\">\n\n点击插件小图标：\n<img src=\"/img/chrome2.png\" alt=\"图片描述\" width=\"500\">\n\n点击按钮：\n<img src=\"/img/chrome3.png\" alt=\"图片描述\" width=\"500\">\n\n\n\n\n","source":"_posts/谷歌插件流程：第一回.md","raw":"---\ntitle: 谷歌插件流程：第一回\ncategory: 大前端剑宗专栏\ndate: 2023-08-03 21:55:39\ntags:\n---\n相信经常使用chrome的小伙伴们，对其丰富的插件工具不会陌生。比如下载页面视频、音乐等等等。那么这些工具究竟是如何编写的呢？本文将以谷歌官方实例为基础，简单介绍一下chrome插件的开发流程，我们最终的目标，是写一个自己的视频下载器插件。部分内容参考下面地址文章\n> http://runxinzhi.com/wintertone-p-12053751.html\n\n#### 1. 第一步创建一个空的文件夹，后创建manifest.json文件，可以理解为整个插件的名片，代码如下。\n```json\n{\n  \"name\": \"Ta-da\",\n  \"description\": \"download_zhihu_short_video\",\n  \"version\": \"1.0\",\n  \"manifest_version\": 3,\n  \"background\": {\n    \"service_worker\": \"background.js\"\n  },\n  \"permissions\": [\"storage\", \"activeTab\", \"scripting\"],\n  \"action\": {\n    \"default_popup\": \"popup.html\"\n  },\n  \"icons\": {\n    \"128\": \"/images/icon.png\"\n  }\n}  \n```\n- **service_worker**: 确定js文件\n- **default_popup**： 确定点击图标后的html\n- **icons**: 配置图标\n\n#### 2. 创建background.js文件。manifest.json文件中的background字段，是一个包含service_worker属性的对象，可以理解为该插件的环境，官方叫做服务视图。这里我们指定服务视图为background.js文件，代码如下：\n```javascript\nlet color = 'red';\nchrome.runtime.onInstalled.addListener(() => {\n  chrome.storage.sync.set({ color });\n});\n// html文件如下:\n<!DOCTYPE html>\n<html>\n  <head>\n    <link rel=\"stylesheet\" href=\"button.css\">\n  </head>\n  <body>\n    <button id=\"changeColor\"></button>\n    <script src=\"popup.js\"></script>\n  </body>\n</html>\n{/* css */}\nbutton {\n  height: 30px;\n  width: 30px;\n  outline: none;\n  margin: 10px;\n  border: none;\n  border-radius: 2px;\n}\n\nbutton.current {\n  box-shadow: 0 0 0 2px white,\n              0 0 0 4px black;\n}\n\n```\n在html中我们引入了一个css和popupjs文件，同时定义了一个按钮。其中popupjs代码如下：\n```javascript\n\n// Initialize butotn with users's prefered color\nlet changeColor = document.getElementById(\"changeColor\");\nchrome.storage.sync.get(\"color\", ({ color }) => {\n  changeColor.style.backgroundColor = color;\n});\n\n// When the button is clicked, inject setPageBackgroundColor into current page\nchangeColor.addEventListener(\"click\", async () => {\n  let [tab] = await chrome.tabs.query({ active: true, currentWindow: true });\n  chrome.scripting.executeScript({\n    target: { tabId: tab.id },\n    function: setPageBackgroundColor,\n  });\n});\n\n// The body of this function will be execuetd as a content script inside the\n// current page\nfunction setPageBackgroundColor() {\n  chrome.storage.sync.get(\"color\", ({ color }) => {\n    document.body.style.backgroundColor = color\n  });\n}\n```\n该文件我们都做了啥？\n- 先是从chrome.storage中拿到color这个变量，然后改变了按钮的样式。这个很类似ipc，目的在于渲染进程和主进程的通信。此处就可以理解为渲染进程从主进程中拿到了一个叫做color的变量。\n- 监听按钮的点击事件，一旦点击，执行脚本**executeScript**。此处的事件回调就是改了下body的背景色。这一步,实际上就是脚本注入.\n**到目前为止，我们已经可以把当前文件夹作为插件文件夹导入chrome浏览器中。首先在地址栏中输入chrome://extensions/打开扩展程序页面，点击页面顶部第一个选项“加载已解压的扩展程序”导入文件夹，然后就能看到如下所示的插件卡片：**\n<img src=\"/img/chrome1.png\" alt=\"图片描述\" width=\"500\">\n\n点击插件小图标：\n<img src=\"/img/chrome2.png\" alt=\"图片描述\" width=\"500\">\n\n点击按钮：\n<img src=\"/img/chrome3.png\" alt=\"图片描述\" width=\"500\">\n\n\n\n\n","slug":"谷歌插件流程：第一回","published":1,"updated":"2023-08-21T01:52:54.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxw6001xf8v7ez7t0gam","content":"<p>相信经常使用chrome的小伙伴们，对其丰富的插件工具不会陌生。比如下载页面视频、音乐等等等。那么这些工具究竟是如何编写的呢？本文将以谷歌官方实例为基础，简单介绍一下chrome插件的开发流程，我们最终的目标，是写一个自己的视频下载器插件。部分内容参考下面地址文章</p>\n<blockquote>\n<p><a href=\"http://runxinzhi.com/wintertone-p-12053751.html\">http://runxinzhi.com/wintertone-p-12053751.html</a></p>\n</blockquote>\n<h4 id=\"1-第一步创建一个空的文件夹，后创建manifest-json文件，可以理解为整个插件的名片，代码如下。\"><a href=\"#1-第一步创建一个空的文件夹，后创建manifest-json文件，可以理解为整个插件的名片，代码如下。\" class=\"headerlink\" title=\"1. 第一步创建一个空的文件夹，后创建manifest.json文件，可以理解为整个插件的名片，代码如下。\"></a>1. 第一步创建一个空的文件夹，后创建manifest.json文件，可以理解为整个插件的名片，代码如下。</h4><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Ta-da&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;description&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;download_zhihu_short_video&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;manifest_version&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">3</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;background&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;service_worker&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;background.js&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;permissions&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;storage&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;activeTab&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;scripting&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;action&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;default_popup&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;popup.html&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;icons&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;128&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/images/icon.png&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span>  </span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>service_worker</strong>: 确定js文件</li>\n<li><strong>default_popup</strong>： 确定点击图标后的html</li>\n<li><strong>icons</strong>: 配置图标</li>\n</ul>\n<h4 id=\"2-创建background-js文件。manifest-json文件中的background字段，是一个包含service-worker属性的对象，可以理解为该插件的环境，官方叫做服务视图。这里我们指定服务视图为background-js文件，代码如下：\"><a href=\"#2-创建background-js文件。manifest-json文件中的background字段，是一个包含service-worker属性的对象，可以理解为该插件的环境，官方叫做服务视图。这里我们指定服务视图为background-js文件，代码如下：\" class=\"headerlink\" title=\"2. 创建background.js文件。manifest.json文件中的background字段，是一个包含service_worker属性的对象，可以理解为该插件的环境，官方叫做服务视图。这里我们指定服务视图为background.js文件，代码如下：\"></a>2. 创建background.js文件。manifest.json文件中的background字段，是一个包含service_worker属性的对象，可以理解为该插件的环境，官方叫做服务视图。这里我们指定服务视图为background.js文件，代码如下：</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> color = <span class=\"string\">&#x27;red&#x27;</span>;</span><br><span class=\"line\">chrome.<span class=\"property\">runtime</span>.<span class=\"property\">onInstalled</span>.<span class=\"title function_\">addListener</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  chrome.<span class=\"property\">storage</span>.<span class=\"property\">sync</span>.<span class=\"title function_\">set</span>(&#123; color &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// html文件如下:</span></span><br><span class=\"line\">&lt;!<span class=\"variable constant_\">DOCTYPE</span> html&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;stylesheet&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;button.css&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;changeColor&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;popup.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">&#123;/* css */&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">button &#123;</span></span><br><span class=\"line\"><span class=\"language-xml\">  height: 30px;</span></span><br><span class=\"line\"><span class=\"language-xml\">  width: 30px;</span></span><br><span class=\"line\"><span class=\"language-xml\">  outline: none;</span></span><br><span class=\"line\"><span class=\"language-xml\">  margin: 10px;</span></span><br><span class=\"line\"><span class=\"language-xml\">  border: none;</span></span><br><span class=\"line\"><span class=\"language-xml\">  border-radius: 2px;</span></span><br><span class=\"line\"><span class=\"language-xml\">&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\"></span></span><br><span class=\"line\"><span class=\"language-xml\">button.current &#123;</span></span><br><span class=\"line\"><span class=\"language-xml\">  box-shadow: 0 0 0 2px white,</span></span><br><span class=\"line\"><span class=\"language-xml\">              0 0 0 4px black;</span></span><br><span class=\"line\"><span class=\"language-xml\">&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\"></span></span><br></pre></td></tr></table></figure>\n<p>在html中我们引入了一个css和popupjs文件，同时定义了一个按钮。其中popupjs代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Initialize butotn with users&#x27;s prefered color</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> changeColor = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;changeColor&quot;</span>);</span><br><span class=\"line\">chrome.<span class=\"property\">storage</span>.<span class=\"property\">sync</span>.<span class=\"title function_\">get</span>(<span class=\"string\">&quot;color&quot;</span>, <span class=\"function\">(<span class=\"params\">&#123; color &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  changeColor.<span class=\"property\">style</span>.<span class=\"property\">backgroundColor</span> = color;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// When the button is clicked, inject setPageBackgroundColor into current page</span></span><br><span class=\"line\">changeColor.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&quot;click&quot;</span>, <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> [tab] = <span class=\"keyword\">await</span> chrome.<span class=\"property\">tabs</span>.<span class=\"title function_\">query</span>(&#123; <span class=\"attr\">active</span>: <span class=\"literal\">true</span>, <span class=\"attr\">currentWindow</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\">  chrome.<span class=\"property\">scripting</span>.<span class=\"title function_\">executeScript</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">target</span>: &#123; <span class=\"attr\">tabId</span>: tab.<span class=\"property\">id</span> &#125;,</span><br><span class=\"line\">    <span class=\"attr\">function</span>: setPageBackgroundColor,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The body of this function will be execuetd as a content script inside the</span></span><br><span class=\"line\"><span class=\"comment\">// current page</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">setPageBackgroundColor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  chrome.<span class=\"property\">storage</span>.<span class=\"property\">sync</span>.<span class=\"title function_\">get</span>(<span class=\"string\">&quot;color&quot;</span>, <span class=\"function\">(<span class=\"params\">&#123; color &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"property\">style</span>.<span class=\"property\">backgroundColor</span> = color</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该文件我们都做了啥？</p>\n<ul>\n<li>先是从chrome.storage中拿到color这个变量，然后改变了按钮的样式。这个很类似ipc，目的在于渲染进程和主进程的通信。此处就可以理解为渲染进程从主进程中拿到了一个叫做color的变量。</li>\n<li>监听按钮的点击事件，一旦点击，执行脚本<strong>executeScript</strong>。此处的事件回调就是改了下body的背景色。这一步,实际上就是脚本注入.<br><strong>到目前为止，我们已经可以把当前文件夹作为插件文件夹导入chrome浏览器中。首先在地址栏中输入chrome:&#x2F;&#x2F;extensions&#x2F;打开扩展程序页面，点击页面顶部第一个选项“加载已解压的扩展程序”导入文件夹，然后就能看到如下所示的插件卡片：</strong><img src=\"/img/chrome1.png\" alt=\"图片描述\" width=\"500\"></li>\n</ul>\n<p>点击插件小图标：<br><img src=\"/img/chrome2.png\" alt=\"图片描述\" width=\"500\"></p>\n<p>点击按钮：<br><img src=\"/img/chrome3.png\" alt=\"图片描述\" width=\"500\"></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>相信经常使用chrome的小伙伴们，对其丰富的插件工具不会陌生。比如下载页面视频、音乐等等等。那么这些工具究竟是如何编写的呢？本文将以谷歌官方实例为基础，简单介绍一下chrome插件的开发流程，我们最终的目标，是写一个自己的视频下载器插件。部分内容参考下面地址文章</p>\n<blockquote>\n<p><a href=\"http://runxinzhi.com/wintertone-p-12053751.html\">http://runxinzhi.com/wintertone-p-12053751.html</a></p>\n</blockquote>\n<h4 id=\"1-第一步创建一个空的文件夹，后创建manifest-json文件，可以理解为整个插件的名片，代码如下。\"><a href=\"#1-第一步创建一个空的文件夹，后创建manifest-json文件，可以理解为整个插件的名片，代码如下。\" class=\"headerlink\" title=\"1. 第一步创建一个空的文件夹，后创建manifest.json文件，可以理解为整个插件的名片，代码如下。\"></a>1. 第一步创建一个空的文件夹，后创建manifest.json文件，可以理解为整个插件的名片，代码如下。</h4><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Ta-da&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;description&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;download_zhihu_short_video&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;manifest_version&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">3</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;background&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;service_worker&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;background.js&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;permissions&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;storage&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;activeTab&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;scripting&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;action&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;default_popup&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;popup.html&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;icons&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;128&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/images/icon.png&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span>  </span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>service_worker</strong>: 确定js文件</li>\n<li><strong>default_popup</strong>： 确定点击图标后的html</li>\n<li><strong>icons</strong>: 配置图标</li>\n</ul>\n<h4 id=\"2-创建background-js文件。manifest-json文件中的background字段，是一个包含service-worker属性的对象，可以理解为该插件的环境，官方叫做服务视图。这里我们指定服务视图为background-js文件，代码如下：\"><a href=\"#2-创建background-js文件。manifest-json文件中的background字段，是一个包含service-worker属性的对象，可以理解为该插件的环境，官方叫做服务视图。这里我们指定服务视图为background-js文件，代码如下：\" class=\"headerlink\" title=\"2. 创建background.js文件。manifest.json文件中的background字段，是一个包含service_worker属性的对象，可以理解为该插件的环境，官方叫做服务视图。这里我们指定服务视图为background.js文件，代码如下：\"></a>2. 创建background.js文件。manifest.json文件中的background字段，是一个包含service_worker属性的对象，可以理解为该插件的环境，官方叫做服务视图。这里我们指定服务视图为background.js文件，代码如下：</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> color = <span class=\"string\">&#x27;red&#x27;</span>;</span><br><span class=\"line\">chrome.<span class=\"property\">runtime</span>.<span class=\"property\">onInstalled</span>.<span class=\"title function_\">addListener</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  chrome.<span class=\"property\">storage</span>.<span class=\"property\">sync</span>.<span class=\"title function_\">set</span>(&#123; color &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// html文件如下:</span></span><br><span class=\"line\">&lt;!<span class=\"variable constant_\">DOCTYPE</span> html&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;stylesheet&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;button.css&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;changeColor&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;popup.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">&#123;/* css */&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">button &#123;</span></span><br><span class=\"line\"><span class=\"language-xml\">  height: 30px;</span></span><br><span class=\"line\"><span class=\"language-xml\">  width: 30px;</span></span><br><span class=\"line\"><span class=\"language-xml\">  outline: none;</span></span><br><span class=\"line\"><span class=\"language-xml\">  margin: 10px;</span></span><br><span class=\"line\"><span class=\"language-xml\">  border: none;</span></span><br><span class=\"line\"><span class=\"language-xml\">  border-radius: 2px;</span></span><br><span class=\"line\"><span class=\"language-xml\">&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\"></span></span><br><span class=\"line\"><span class=\"language-xml\">button.current &#123;</span></span><br><span class=\"line\"><span class=\"language-xml\">  box-shadow: 0 0 0 2px white,</span></span><br><span class=\"line\"><span class=\"language-xml\">              0 0 0 4px black;</span></span><br><span class=\"line\"><span class=\"language-xml\">&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\"></span></span><br></pre></td></tr></table></figure>\n<p>在html中我们引入了一个css和popupjs文件，同时定义了一个按钮。其中popupjs代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Initialize butotn with users&#x27;s prefered color</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> changeColor = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;changeColor&quot;</span>);</span><br><span class=\"line\">chrome.<span class=\"property\">storage</span>.<span class=\"property\">sync</span>.<span class=\"title function_\">get</span>(<span class=\"string\">&quot;color&quot;</span>, <span class=\"function\">(<span class=\"params\">&#123; color &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  changeColor.<span class=\"property\">style</span>.<span class=\"property\">backgroundColor</span> = color;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// When the button is clicked, inject setPageBackgroundColor into current page</span></span><br><span class=\"line\">changeColor.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&quot;click&quot;</span>, <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> [tab] = <span class=\"keyword\">await</span> chrome.<span class=\"property\">tabs</span>.<span class=\"title function_\">query</span>(&#123; <span class=\"attr\">active</span>: <span class=\"literal\">true</span>, <span class=\"attr\">currentWindow</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\">  chrome.<span class=\"property\">scripting</span>.<span class=\"title function_\">executeScript</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">target</span>: &#123; <span class=\"attr\">tabId</span>: tab.<span class=\"property\">id</span> &#125;,</span><br><span class=\"line\">    <span class=\"attr\">function</span>: setPageBackgroundColor,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The body of this function will be execuetd as a content script inside the</span></span><br><span class=\"line\"><span class=\"comment\">// current page</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">setPageBackgroundColor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  chrome.<span class=\"property\">storage</span>.<span class=\"property\">sync</span>.<span class=\"title function_\">get</span>(<span class=\"string\">&quot;color&quot;</span>, <span class=\"function\">(<span class=\"params\">&#123; color &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"property\">style</span>.<span class=\"property\">backgroundColor</span> = color</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该文件我们都做了啥？</p>\n<ul>\n<li>先是从chrome.storage中拿到color这个变量，然后改变了按钮的样式。这个很类似ipc，目的在于渲染进程和主进程的通信。此处就可以理解为渲染进程从主进程中拿到了一个叫做color的变量。</li>\n<li>监听按钮的点击事件，一旦点击，执行脚本<strong>executeScript</strong>。此处的事件回调就是改了下body的背景色。这一步,实际上就是脚本注入.<br><strong>到目前为止，我们已经可以把当前文件夹作为插件文件夹导入chrome浏览器中。首先在地址栏中输入chrome:&#x2F;&#x2F;extensions&#x2F;打开扩展程序页面，点击页面顶部第一个选项“加载已解压的扩展程序”导入文件夹，然后就能看到如下所示的插件卡片：</strong><img src=\"/img/chrome1.png\" alt=\"图片描述\" width=\"500\"></li>\n</ul>\n<p>点击插件小图标：<br><img src=\"/img/chrome2.png\" alt=\"图片描述\" width=\"500\"></p>\n<p>点击按钮：<br><img src=\"/img/chrome3.png\" alt=\"图片描述\" width=\"500\"></p>\n"},{"title":"谷歌插件流程：第二回","date":"2023-08-07T03:25:42.000Z","_content":"\n**在前文中，我们通过一个小例子，简单介绍了谷歌插件的一些规则。那么本文正式尝试着，去实现自己的视频下载器插件的开发。**\n\n目的：能够自动下载知乎上的短视频资源。\n古语云：知己知彼百战不殆。那么我们首先就去看一看知乎站点的小视频资源是如何加载的。\n<img src=\"/img/zhihu.png\" alt=\"图片描述\" width=\"500\">\n\n我们发现，video的src属性绑定的是真实的资源地址，也就是说，我们只需要找到video标签即可。\n思路: 获取video标签,创建a标签下载.所以有了如下代码:\n```javascript\nchangeColor.addEventListener(\"click\", async () => {\n  console.log('click')\n  let [tab] = await chrome.tabs.query({ active: true, currentWindow: true });\n  chrome.scripting.executeScript({\n    target: { tabId: tab.id },\n    function: downloadVideo,\n  })\n})\n\nfunction downloadVideo() {\n  console.log('downloadVideo')\n  let video = document.getElementsByTagName('video')[0]\n  console.log('video>>>', video)\n  const url = video.src\n  const aEl = document.createElement('a')\n  aEl.href = url\n  aEl.download = 'test.mp4'\n}\n```\n**监听点击事件,捕捉到事件,执行注入脚本.获取video标签的src属性,然后就是前端自动下载那一套.**\n这思路,简直一气呵成.然而正所谓理想很丰满,现实却很骨感\n**没反应,不单单没反应,发现注入的脚本连console都无法打印,就是说根本就没法调.试了半天,发现貌似只有改变颜色能起作用,其他啥都没反应....怎么破?**\n<img src=\"/img/无奈.webp\" alt=\"借用的网友的图哈\" width=\"500\">\n\n\n<!-- \nhttps://vdn6.vzuu.com/SD/715c799a-2f9f-11ee-ad28-52d3306dc2a2-v8_f2_t1_DHg5LXTG.mp4?pkey=AAValer8LWz_2H4E7Y3xBMP-XBu1KAUQXykPmkzBL6EgGrKN4BHhowtOVOn8mxbrytsD44tmYUFJhGGTa_qKGxL8&c=avc.8.0&f=mp4&pu=1513c7c2&bu=http-1513c7c2&expiration=1691386257&v=ks6&pf=Web&pt=zhihu -->","source":"_posts/谷歌插件流程：第二回.md","raw":"---\ntitle: 谷歌插件流程：第二回\ncategory: 大前端剑宗专栏\ndate: 2023-08-07 11:25:42\ntags:\n---\n\n**在前文中，我们通过一个小例子，简单介绍了谷歌插件的一些规则。那么本文正式尝试着，去实现自己的视频下载器插件的开发。**\n\n目的：能够自动下载知乎上的短视频资源。\n古语云：知己知彼百战不殆。那么我们首先就去看一看知乎站点的小视频资源是如何加载的。\n<img src=\"/img/zhihu.png\" alt=\"图片描述\" width=\"500\">\n\n我们发现，video的src属性绑定的是真实的资源地址，也就是说，我们只需要找到video标签即可。\n思路: 获取video标签,创建a标签下载.所以有了如下代码:\n```javascript\nchangeColor.addEventListener(\"click\", async () => {\n  console.log('click')\n  let [tab] = await chrome.tabs.query({ active: true, currentWindow: true });\n  chrome.scripting.executeScript({\n    target: { tabId: tab.id },\n    function: downloadVideo,\n  })\n})\n\nfunction downloadVideo() {\n  console.log('downloadVideo')\n  let video = document.getElementsByTagName('video')[0]\n  console.log('video>>>', video)\n  const url = video.src\n  const aEl = document.createElement('a')\n  aEl.href = url\n  aEl.download = 'test.mp4'\n}\n```\n**监听点击事件,捕捉到事件,执行注入脚本.获取video标签的src属性,然后就是前端自动下载那一套.**\n这思路,简直一气呵成.然而正所谓理想很丰满,现实却很骨感\n**没反应,不单单没反应,发现注入的脚本连console都无法打印,就是说根本就没法调.试了半天,发现貌似只有改变颜色能起作用,其他啥都没反应....怎么破?**\n<img src=\"/img/无奈.webp\" alt=\"借用的网友的图哈\" width=\"500\">\n\n\n<!-- \nhttps://vdn6.vzuu.com/SD/715c799a-2f9f-11ee-ad28-52d3306dc2a2-v8_f2_t1_DHg5LXTG.mp4?pkey=AAValer8LWz_2H4E7Y3xBMP-XBu1KAUQXykPmkzBL6EgGrKN4BHhowtOVOn8mxbrytsD44tmYUFJhGGTa_qKGxL8&c=avc.8.0&f=mp4&pu=1513c7c2&bu=http-1513c7c2&expiration=1691386257&v=ks6&pf=Web&pt=zhihu -->","slug":"谷歌插件流程：第二回","published":1,"updated":"2023-08-21T01:52:54.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxw80020f8v77c7tfnd4","content":"<p><strong>在前文中，我们通过一个小例子，简单介绍了谷歌插件的一些规则。那么本文正式尝试着，去实现自己的视频下载器插件的开发。</strong></p>\n<p>目的：能够自动下载知乎上的短视频资源。<br>古语云：知己知彼百战不殆。那么我们首先就去看一看知乎站点的小视频资源是如何加载的。<br><img src=\"/img/zhihu.png\" alt=\"图片描述\" width=\"500\"></p>\n<p>我们发现，video的src属性绑定的是真实的资源地址，也就是说，我们只需要找到video标签即可。<br>思路: 获取video标签,创建a标签下载.所以有了如下代码:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">changeColor.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&quot;click&quot;</span>, <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;click&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> [tab] = <span class=\"keyword\">await</span> chrome.<span class=\"property\">tabs</span>.<span class=\"title function_\">query</span>(&#123; <span class=\"attr\">active</span>: <span class=\"literal\">true</span>, <span class=\"attr\">currentWindow</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\">  chrome.<span class=\"property\">scripting</span>.<span class=\"title function_\">executeScript</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">target</span>: &#123; <span class=\"attr\">tabId</span>: tab.<span class=\"property\">id</span> &#125;,</span><br><span class=\"line\">    <span class=\"attr\">function</span>: downloadVideo,</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">downloadVideo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;downloadVideo&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> video = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByTagName</span>(<span class=\"string\">&#x27;video&#x27;</span>)[<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;video&gt;&gt;&gt;&#x27;</span>, video)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = video.<span class=\"property\">src</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> aEl = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;a&#x27;</span>)</span><br><span class=\"line\">  aEl.<span class=\"property\">href</span> = url</span><br><span class=\"line\">  aEl.<span class=\"property\">download</span> = <span class=\"string\">&#x27;test.mp4&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>监听点击事件,捕捉到事件,执行注入脚本.获取video标签的src属性,然后就是前端自动下载那一套.</strong><br>这思路,简直一气呵成.然而正所谓理想很丰满,现实却很骨感<br><strong>没反应,不单单没反应,发现注入的脚本连console都无法打印,就是说根本就没法调.试了半天,发现貌似只有改变颜色能起作用,其他啥都没反应….怎么破?</strong><br><img src=\"/img/无奈.webp\" alt=\"借用的网友的图哈\" width=\"500\"></p>\n<!-- \nhttps://vdn6.vzuu.com/SD/715c799a-2f9f-11ee-ad28-52d3306dc2a2-v8_f2_t1_DHg5LXTG.mp4?pkey=AAValer8LWz_2H4E7Y3xBMP-XBu1KAUQXykPmkzBL6EgGrKN4BHhowtOVOn8mxbrytsD44tmYUFJhGGTa_qKGxL8&c=avc.8.0&f=mp4&pu=1513c7c2&bu=http-1513c7c2&expiration=1691386257&v=ks6&pf=Web&pt=zhihu -->","site":{"data":{}},"cover":false,"excerpt":"","more":"<p><strong>在前文中，我们通过一个小例子，简单介绍了谷歌插件的一些规则。那么本文正式尝试着，去实现自己的视频下载器插件的开发。</strong></p>\n<p>目的：能够自动下载知乎上的短视频资源。<br>古语云：知己知彼百战不殆。那么我们首先就去看一看知乎站点的小视频资源是如何加载的。<br><img src=\"/img/zhihu.png\" alt=\"图片描述\" width=\"500\"></p>\n<p>我们发现，video的src属性绑定的是真实的资源地址，也就是说，我们只需要找到video标签即可。<br>思路: 获取video标签,创建a标签下载.所以有了如下代码:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">changeColor.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&quot;click&quot;</span>, <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;click&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> [tab] = <span class=\"keyword\">await</span> chrome.<span class=\"property\">tabs</span>.<span class=\"title function_\">query</span>(&#123; <span class=\"attr\">active</span>: <span class=\"literal\">true</span>, <span class=\"attr\">currentWindow</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\">  chrome.<span class=\"property\">scripting</span>.<span class=\"title function_\">executeScript</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">target</span>: &#123; <span class=\"attr\">tabId</span>: tab.<span class=\"property\">id</span> &#125;,</span><br><span class=\"line\">    <span class=\"attr\">function</span>: downloadVideo,</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">downloadVideo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;downloadVideo&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> video = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByTagName</span>(<span class=\"string\">&#x27;video&#x27;</span>)[<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;video&gt;&gt;&gt;&#x27;</span>, video)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = video.<span class=\"property\">src</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> aEl = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;a&#x27;</span>)</span><br><span class=\"line\">  aEl.<span class=\"property\">href</span> = url</span><br><span class=\"line\">  aEl.<span class=\"property\">download</span> = <span class=\"string\">&#x27;test.mp4&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>监听点击事件,捕捉到事件,执行注入脚本.获取video标签的src属性,然后就是前端自动下载那一套.</strong><br>这思路,简直一气呵成.然而正所谓理想很丰满,现实却很骨感<br><strong>没反应,不单单没反应,发现注入的脚本连console都无法打印,就是说根本就没法调.试了半天,发现貌似只有改变颜色能起作用,其他啥都没反应….怎么破?</strong><br><img src=\"/img/无奈.webp\" alt=\"借用的网友的图哈\" width=\"500\"></p>\n<!-- \nhttps://vdn6.vzuu.com/SD/715c799a-2f9f-11ee-ad28-52d3306dc2a2-v8_f2_t1_DHg5LXTG.mp4?pkey=AAValer8LWz_2H4E7Y3xBMP-XBu1KAUQXykPmkzBL6EgGrKN4BHhowtOVOn8mxbrytsD44tmYUFJhGGTa_qKGxL8&c=avc.8.0&f=mp4&pu=1513c7c2&bu=http-1513c7c2&expiration=1691386257&v=ks6&pf=Web&pt=zhihu -->"},{"title":"设计模式：单例模式","date":"2023-08-03T08:37:13.000Z","_content":"**所谓单例模式，就是保证类的实例只有一个。思路很清晰，就是在构造函数中置一个标志，或者已存在的实例对象。先来一道简单版：**\n```javascript\nconst f = function(name) {\n  this.single = null\n  this.name =name\n}\n\nf.getObj = function(name) {\n  if(!this.single) {\n    this.single =  new f(name)\n    return this.single\n  } else {\n    return this.single\n  }\n}\n\nconst a = f.getObj('s1')\nconst b = f.getObj('s2')\nconsole.log(a)\nconsole.log(b)\n\n// f { single: null, name: 's1' }\n// f { single: null, name: 's1' }\n```\n这种实现方式其实很简单，实际上就是给构造函数f挂在了一个单独属性single，初次new时挂在上去之后，之后的每次new都是无效的，都会返回初次的那位。但是上述方法很是变扭，因为我们实例化通常都是用new而不是调用一个方法。为此，进行改进。\n```javascript\nconst f = function(html) {\n  this.html = html\n  this.single = null\n}\n\nf.prototype.init = function() {\n  let div = document.createElement('div')\n  div.innerHTML = this.html\n  this.single = div\n}\n\nconst proxy = (function() {\n  let instance\n  return function(html) {\n    if(!instance) {\n      instance = new f(html)\n    }\n    return instance  \n  }\n})()\n\nconst a = new proxy('s1')\nconst b = new proxy('s2')\nconsole.log('a:', a)\nconsole.log('b:', b)\n\n// a: f {html: \"s1\", single: div}\n// b: f {html: \"s1\", single: div}\n```\n因为闭包结构，使得只要调用proxy时，instance始终存在于当前环境，即唯一的那个实例。完美！","source":"_posts/设计模式：单例模式.md","raw":"---\ntitle: 设计模式：单例模式\ncategory: 大前端气宗专栏\ndate: 2023-08-03 16:37:13\ntags:\n---\n**所谓单例模式，就是保证类的实例只有一个。思路很清晰，就是在构造函数中置一个标志，或者已存在的实例对象。先来一道简单版：**\n```javascript\nconst f = function(name) {\n  this.single = null\n  this.name =name\n}\n\nf.getObj = function(name) {\n  if(!this.single) {\n    this.single =  new f(name)\n    return this.single\n  } else {\n    return this.single\n  }\n}\n\nconst a = f.getObj('s1')\nconst b = f.getObj('s2')\nconsole.log(a)\nconsole.log(b)\n\n// f { single: null, name: 's1' }\n// f { single: null, name: 's1' }\n```\n这种实现方式其实很简单，实际上就是给构造函数f挂在了一个单独属性single，初次new时挂在上去之后，之后的每次new都是无效的，都会返回初次的那位。但是上述方法很是变扭，因为我们实例化通常都是用new而不是调用一个方法。为此，进行改进。\n```javascript\nconst f = function(html) {\n  this.html = html\n  this.single = null\n}\n\nf.prototype.init = function() {\n  let div = document.createElement('div')\n  div.innerHTML = this.html\n  this.single = div\n}\n\nconst proxy = (function() {\n  let instance\n  return function(html) {\n    if(!instance) {\n      instance = new f(html)\n    }\n    return instance  \n  }\n})()\n\nconst a = new proxy('s1')\nconst b = new proxy('s2')\nconsole.log('a:', a)\nconsole.log('b:', b)\n\n// a: f {html: \"s1\", single: div}\n// b: f {html: \"s1\", single: div}\n```\n因为闭包结构，使得只要调用proxy时，instance始终存在于当前环境，即唯一的那个实例。完美！","slug":"设计模式：单例模式","published":1,"updated":"2023-08-21T01:52:54.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllk9xxw80022f8v7fgudh0r2","content":"<p><strong>所谓单例模式，就是保证类的实例只有一个。思路很清晰，就是在构造函数中置一个标志，或者已存在的实例对象。先来一道简单版：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"keyword\">function</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">single</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> =name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f.<span class=\"property\">getObj</span> = <span class=\"keyword\">function</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!<span class=\"variable language_\">this</span>.<span class=\"property\">single</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">single</span> =  <span class=\"keyword\">new</span> <span class=\"title function_\">f</span>(name)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">single</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">single</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = f.<span class=\"title function_\">getObj</span>(<span class=\"string\">&#x27;s1&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> b = f.<span class=\"title function_\">getObj</span>(<span class=\"string\">&#x27;s2&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// f &#123; single: null, name: &#x27;s1&#x27; &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// f &#123; single: null, name: &#x27;s1&#x27; &#125;</span></span><br></pre></td></tr></table></figure>\n<p>这种实现方式其实很简单，实际上就是给构造函数f挂在了一个单独属性single，初次new时挂在上去之后，之后的每次new都是无效的，都会返回初次的那位。但是上述方法很是变扭，因为我们实例化通常都是用new而不是调用一个方法。为此，进行改进。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"keyword\">function</span>(<span class=\"params\">html</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">html</span> = html</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">single</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">init</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> div = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;div&#x27;</span>)</span><br><span class=\"line\">  div.<span class=\"property\">innerHTML</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">html</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">single</span> = div</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> proxy = (<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> instance</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\">html</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!instance) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> <span class=\"title function_\">f</span>(html)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance  </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"keyword\">new</span> <span class=\"title function_\">proxy</span>(<span class=\"string\">&#x27;s1&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"keyword\">new</span> <span class=\"title function_\">proxy</span>(<span class=\"string\">&#x27;s2&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;a:&#x27;</span>, a)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;b:&#x27;</span>, b)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// a: f &#123;html: &quot;s1&quot;, single: div&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// b: f &#123;html: &quot;s1&quot;, single: div&#125;</span></span><br></pre></td></tr></table></figure>\n<p>因为闭包结构，使得只要调用proxy时，instance始终存在于当前环境，即唯一的那个实例。完美！</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p><strong>所谓单例模式，就是保证类的实例只有一个。思路很清晰，就是在构造函数中置一个标志，或者已存在的实例对象。先来一道简单版：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"keyword\">function</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">single</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> =name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f.<span class=\"property\">getObj</span> = <span class=\"keyword\">function</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!<span class=\"variable language_\">this</span>.<span class=\"property\">single</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">single</span> =  <span class=\"keyword\">new</span> <span class=\"title function_\">f</span>(name)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">single</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">single</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = f.<span class=\"title function_\">getObj</span>(<span class=\"string\">&#x27;s1&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> b = f.<span class=\"title function_\">getObj</span>(<span class=\"string\">&#x27;s2&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// f &#123; single: null, name: &#x27;s1&#x27; &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// f &#123; single: null, name: &#x27;s1&#x27; &#125;</span></span><br></pre></td></tr></table></figure>\n<p>这种实现方式其实很简单，实际上就是给构造函数f挂在了一个单独属性single，初次new时挂在上去之后，之后的每次new都是无效的，都会返回初次的那位。但是上述方法很是变扭，因为我们实例化通常都是用new而不是调用一个方法。为此，进行改进。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> f = <span class=\"keyword\">function</span>(<span class=\"params\">html</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">html</span> = html</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">single</span> = <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">init</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> div = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;div&#x27;</span>)</span><br><span class=\"line\">  div.<span class=\"property\">innerHTML</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">html</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">single</span> = div</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> proxy = (<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> instance</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\">html</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!instance) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> <span class=\"title function_\">f</span>(html)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance  </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"keyword\">new</span> <span class=\"title function_\">proxy</span>(<span class=\"string\">&#x27;s1&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"keyword\">new</span> <span class=\"title function_\">proxy</span>(<span class=\"string\">&#x27;s2&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;a:&#x27;</span>, a)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;b:&#x27;</span>, b)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// a: f &#123;html: &quot;s1&quot;, single: div&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// b: f &#123;html: &quot;s1&quot;, single: div&#125;</span></span><br></pre></td></tr></table></figure>\n<p>因为闭包结构，使得只要调用proxy时，instance始终存在于当前环境，即唯一的那个实例。完美！</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cllk9xxvf0000f8v75mrpbzet","category_id":"cllk9xxvk0002f8v7f7chhl36","_id":"cllk9xxvp0009f8v74z5y9rp2"},{"post_id":"cllk9xxvo0007f8v742m9hir5","category_id":"cllk9xxvo0006f8v7boeb7qi7","_id":"cllk9xxvr000df8v7h1i66nu5"},{"post_id":"cllk9xxvi0001f8v732j3dxcd","category_id":"cllk9xxvo0006f8v7boeb7qi7","_id":"cllk9xxvs000gf8v761i73und"},{"post_id":"cllk9xxvm0003f8v7eua7bjfb","category_id":"cllk9xxvk0002f8v7f7chhl36","_id":"cllk9xxvt000jf8v72czke652"},{"post_id":"cllk9xxvn0004f8v77jpb6xvl","category_id":"cllk9xxvo0006f8v7boeb7qi7","_id":"cllk9xxvu000nf8v742ybe5bp"},{"post_id":"cllk9xxvn0005f8v7dn2k7vco","category_id":"cllk9xxvo0006f8v7boeb7qi7","_id":"cllk9xxvv000qf8v7c3racgip"},{"post_id":"cllk9xxvu000of8v7ddg2763i","category_id":"cllk9xxvu000mf8v7b1ryhv1r","_id":"cllk9xxvw000uf8v74iwy9g0f"},{"post_id":"cllk9xxvp0008f8v7btj67axj","category_id":"cllk9xxvu000mf8v7b1ryhv1r","_id":"cllk9xxvx000xf8v73v9w32uu"},{"post_id":"cllk9xxvv000pf8v7fy8cgwn3","category_id":"cllk9xxvu000mf8v7b1ryhv1r","_id":"cllk9xxvx000zf8v7d9z3dmy1"},{"post_id":"cllk9xxvq000bf8v75djva9f8","category_id":"cllk9xxvu000mf8v7b1ryhv1r","_id":"cllk9xxvy0012f8v7ae9g1jcu"},{"post_id":"cllk9xxvr000cf8v7g4o7b1al","category_id":"cllk9xxvu000mf8v7b1ryhv1r","_id":"cllk9xxvz0015f8v77dghc7lf"},{"post_id":"cllk9xxvy0011f8v7hk0j81v7","category_id":"cllk9xxvk0002f8v7f7chhl36","_id":"cllk9xxw00018f8v7el1uan4v"},{"post_id":"cllk9xxvs000ff8v72ev6hcka","category_id":"cllk9xxvu000mf8v7b1ryhv1r","_id":"cllk9xxw1001bf8v755331spg"},{"post_id":"cllk9xxvz0016f8v73bjycxhd","category_id":"cllk9xxvo0006f8v7boeb7qi7","_id":"cllk9xxw1001df8v7bus2bibl"},{"post_id":"cllk9xxvs000hf8v71kttadul","category_id":"cllk9xxvu000mf8v7b1ryhv1r","_id":"cllk9xxw2001gf8v78gebar3j"},{"post_id":"cllk9xxw00017f8v7c2pih7oi","category_id":"cllk9xxvk0002f8v7f7chhl36","_id":"cllk9xxw2001if8v71947abl9"},{"post_id":"cllk9xxw0001af8v787yy17nl","category_id":"cllk9xxvk0002f8v7f7chhl36","_id":"cllk9xxw3001lf8v70b7v5kir"},{"post_id":"cllk9xxvt000kf8v727pq7ums","category_id":"cllk9xxvu000mf8v7b1ryhv1r","_id":"cllk9xxw3001nf8v7bwp64n6q"},{"post_id":"cllk9xxvu000lf8v7a29sh17q","category_id":"cllk9xxvu000mf8v7b1ryhv1r","_id":"cllk9xxw4001qf8v76o589a6z"},{"post_id":"cllk9xxw2001hf8v78gu80gnn","category_id":"cllk9xxvo0006f8v7boeb7qi7","_id":"cllk9xxw5001sf8v7dddtefh3"},{"post_id":"cllk9xxvv000sf8v7fyo7ev3f","category_id":"cllk9xxw2001jf8v7dnj8eqvb","_id":"cllk9xxw6001uf8v73s4a8foo"},{"post_id":"cllk9xxvw000tf8v7cdsu6h4j","category_id":"cllk9xxw3001of8v7eo2m5ehk","_id":"cllk9xxw7001zf8v789s7ddvq"},{"post_id":"cllk9xxw5001tf8v7ei1y8x5m","category_id":"cllk9xxvo0006f8v7boeb7qi7","_id":"cllk9xxw80021f8v75b5f38eq"},{"post_id":"cllk9xxvw000wf8v7h7ir7pmf","category_id":"cllk9xxw3001of8v7eo2m5ehk","_id":"cllk9xxw90024f8v777xi4mes"},{"post_id":"cllk9xxw6001xf8v7ez7t0gam","category_id":"cllk9xxvu000mf8v7b1ryhv1r","_id":"cllk9xxw90025f8v7hbe05rkk"},{"post_id":"cllk9xxw80020f8v77c7tfnd4","category_id":"cllk9xxvu000mf8v7b1ryhv1r","_id":"cllk9xxw90027f8v77k130vvh"},{"post_id":"cllk9xxvx000yf8v7axhi85xp","category_id":"cllk9xxw3001of8v7eo2m5ehk","_id":"cllk9xxw90028f8v71w2c4q5f"},{"post_id":"cllk9xxw80022f8v7fgudh0r2","category_id":"cllk9xxvk0002f8v7f7chhl36","_id":"cllk9xxw90029f8v7ezgp1seb"},{"post_id":"cllk9xxvz0013f8v7a12jbwzi","category_id":"cllk9xxw3001of8v7eo2m5ehk","_id":"cllk9xxwa002bf8v7chuyc83j"},{"post_id":"cllk9xxw1001cf8v70u74dnzm","category_id":"cllk9xxw90026f8v7h9u592ek","_id":"cllk9xxwa002df8v7geqg6au6"},{"post_id":"cllk9xxw1001ff8v70bczdu00","category_id":"cllk9xxw90026f8v7h9u592ek","_id":"cllk9xxwa002ef8v74fck872v"},{"post_id":"cllk9xxw2001kf8v7gerj06th","category_id":"cllk9xxwa002cf8v71hjzgocn","_id":"cllk9xxwa002gf8v74z8k7m8t"},{"post_id":"cllk9xxw3001mf8v761vm7vs8","category_id":"cllk9xxwa002ff8v74e1b6fdg","_id":"cllk9xxwb002jf8v7gel95bw3"},{"post_id":"cllk9xxw3001pf8v72s840mxa","category_id":"cllk9xxwa002cf8v71hjzgocn","_id":"cllk9xxwb002lf8v78uj0c7zb"},{"post_id":"cllk9xxw4001rf8v79g5n0twl","category_id":"cllk9xxwa002cf8v71hjzgocn","_id":"cllk9xxwb002mf8v7c3l9ftp5"},{"post_id":"cllk9xxw6001wf8v754m4fnun","category_id":"cllk9xxwa002cf8v71hjzgocn","_id":"cllk9xxwb002nf8v7cxu02y3q"}],"PostTag":[],"Tag":[]}}