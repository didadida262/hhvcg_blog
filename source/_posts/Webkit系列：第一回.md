---
title: Webkit系列：第一回
category: Webkit系列
date: 2023-07-28 01:13:25
tags:
---
本系列的目标：**尝试深入理解当前浏览器（谷歌）的大体逻辑。内容严重参考《Webkit技术内幕》**

现代浏览器的渲染逻辑，就是下图的流程。
![layoput](img/layout.webp)

一个经典的面试题：从输入url到最终页面的呈现，这其中都经历了些啥？
坦白讲这个问题很有深度也很有价值，因为完全可以根据你的描述，看出你对现代浏览器执行机制的整体把握和理解。

总体可分为`网页加载过程（DOMContent事件）`和`渲染过程（onload事件）`。
具体：
1. 浏览器根据输入的内容做识别，如果输入的是网址，调用DNS解析目标IP，建立连接。如果是关键词，调用搜索引擎去搜索。
2. 依赖网络模块，三次握手建立连接后获取到各种资源，包括js、html、css等等。
3. html文件被交给HTML解释器转变成一系列词语，然后构建节点生成DOM树（树形结构的对象`document`），css文件被交给css解释器生成样式树,也就是`stylesheet`。在这过程中，碰到js代码，中断dom树的构建，权限会给到`jscore引擎`解释处理，谷歌浏览器中的就是大名鼎鼎的v8。此处涉及到进程切换。执行完js后权限交回给html解释器。当然碰到的js代码也会根据如async或者defer异步处理。
4. css解释器完成工作后，会在dom树上附加解释后的样式信息。
5. 根据dom树，剔除掉所有不现实的节点，并计算元素的布局信息，生成布局树。
6. 对布局树进行`分层`，并生成分层树。
7. 为每个图层生成`绘制列表`，并将其提交到合成线程。
8. 合成线程将图层分成`图块`，并在光栅化线程池中将图块转换成位图。
9. 合成线程发送绘制图块命令`DrawQuad`给浏览器进程。
10. 浏览器进程根据DrawQuad消息生成页面，并显示到显示器上
<!-- 5. 最后的就是**Paint**和**Composite**两个阶段生成最终的页面。 -->

此时我们已经对布局树进行了分层，知道了每一层应该绘制的东西。此时，主线程会将这些数据给到合成线程，该线程通过栅格化，生成一个个的图块数据，、执行“DrawQuad”命令给到浏览器进程，最后图块数据给到GPU，调用GPU进程依次绘制