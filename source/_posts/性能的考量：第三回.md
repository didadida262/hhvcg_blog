---
title: 性能的考量：第三回
category: 性能的考量
date: 2023-08-03 20:46:07
tags:
---

### 本文主介绍canvas的性能优化策略

关于性能问题,实际上,针对于类似管理系统这样的项目而言,不需要关注太多,也没那必要.但是对于图形编程类的项目而言,则是`至关重要的指标.关乎生死`。
#### 先点名canvas的耗时因素
1. 图形的数量
2. 图形的大小。
3. 高质量、大文件的图片（画在画布上）

图形编程类的项目,关注性能问题的原因,在于交互体验。比如我们废了半天劲写了一个web端的cs射击游戏,当我兴奋的准备往前走两步时,发现页面直接给我来了个帧数级别的慢动作,江湖说法叫做"卡成狗"，用户体验几乎为0。这种完全不能玩的应用,如同垃圾。

#### 我们首先来定义一下, 什么叫做卡?
`卡顿`原理可以解释为,`每一帧js主线程执行的事情过多,导致帧内时间没来得及干完,即当前帧耗时超过分配的帧时间`。那么什么是"分配的帧时间?之前说了,60hz举例,一秒钟60帧,那么一帧的时间大约在`16.7ms`.所以,如果在一帧内的耗时超过了16.7ms,就会出现视觉层面的"卡"。目前主流的屏幕基本都是60hz,也就是显示器,以每秒60次的频率闪频,也就是一秒钟会有60帧,但我们人眼无法察觉。

**在实践的项目中，我们遇到了一个这样的警告：**
<img src="/img/p2.webp" alt="图片描述" width="500">
白话就是，“大哥，您在一帧时间内做的事情太多了，浏览器处理不过来了”。对项目的影响就是，拖拽和缩放视图导致不会很流畅。所以，为了解决卡的问题，我们该做点啥呢？

1. canvas隔离。
canvas画布的更新，是以该节点为基础的，所以将需要重排或者重绘频率较高的图形,用单独的canvas隔离开,这样避免不必要的重绘成本。
2. 事件的防抖节流处理。绘制的动作，不要频繁触发, 该屏蔽的操作一律屏蔽。
3. 避免浮点运算
> 虽然javascript提供了很方便的一些取整方法，像Math.floor，Math.ceil,parseInt，但是，国外友人做过测试，parseInt这个方法做了一些额外的工作（比如检测数据是不是有效
> 的数值，parseInt 甚至先将参数转换成了字符串!），所以，直接用parseInt的话相对来说比较消耗性能。
4. 局部渲染
第一点中我们说过，canvas更新时以canvas节点为基础的，实际上这话说的不够严谨，因为我们可以有方法可以局部操作渲染，来避免这种更新方式，但需要做些额外的设置。具体参考canvas的clipAPI
