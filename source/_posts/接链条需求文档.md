---
title: 接链条需求文档
date: 2024-05-17 10:27:22
category:
---


### 接链（arbitrum举例）的需求开发文档--老版本的整体逻辑


#### 一. 前端样式部分

在`getChainModules`函数中，根据不同的链，动态插入对应的页面模块（opensumi中称之为`Contribution`）

#### 二. 编译模块

老版本的实现：
```javascript
  const _compile = useCallback(async () => {
    try {
      if (uri && activeFilePath) {
        const content =
          await chainIDEProxyImpl.fileSystemService.readFileString(uri);
        console.log('content>>>', content)
        const args = resolveCompilePayload(form, uri, content, solcVersionsMap);
        console.log('args>>>', args)
        if (args) {
          outputService.handleInfoSingle(
            formatMessage({
              id: 'COMPILE_LOG_COMPILING_CONTRACT'
            }),
            LogSource.COMPILE,
          );
          // log “编译合约”
          console.log('solidityCompilerActions.compileContract(args)>>>', solidityCompilerActions.compileContract(args))
          dispatch(solidityCompilerActions.compileContract(args));
        }
      }
    } catch (e) {
      console.error(e);
    }
  }, [uri, activeFilePath, form, solcVersionsMap, formatMessage, dispatch]);
```

<!-- 编译合约... -->
1. `uri`为入参，调用`readFileString`读取文件内容`content`
2. `form, uri, content, solcVersionsMap`为入参,调用`resolveCompilePayload`生成`args`
3. 以`args`为输入，执行编译函数`compileContract`
<!-- 请求编译... -->
4. 开启worker，

```javascript
    const worker = compile(localCompileInput);
...
...
const compile = (body: SolidityCompiler.ICompilerInput) => {
  const worker = new Worker(new URL('./compiler.worker.ts', import.meta.url));
  worker.postMessage({
    type: 'compile',
    body
  });
  return worker;
};

// 核心代码
    importScripts(
      `https://binaries.soliditylang.org/wasm/soljson-${version}.js`
    );
    ...
    ...
    JSON.parse(compiler.compile(JSON.stringify(input)))

// 核心函数compileContract
async function compileContract(body) {
  console.log('compileContract>>>', body)
  const compiler_pool = {};
  const version = body.version || 'latest';
  let compiler;
  if (typeof compiler === 'undefined') {
    importScripts(
      `https://binaries.soliditylang.org/wasm/soljson-${version}.js`
    );
    compiler = wrapper(self.Module);
  }
  const response = new Promise((resolve, reject) => {
    try {
      const sources = body.sources;
      const settings = body.settings || {};
      // contract input
      const input = {
        ...template_input,
        sources: sources,
        settings: { ...settings, ...template_input.settings }
      };
      if (compiler_pool[version]) {
        const solcSnapshot = compiler_pool[version];
        resolve(JSON.parse(solcSnapshot.compile(JSON.stringify(input))));
      } else {
        resolve(JSON.parse(compiler.compile(JSON.stringify(input))));
      }
    } catch (e) {
      /* handle error */
      reject(new Error(`Compiler arguments error - ${e.message}`));
    }
  });
  return await response;
}
// 该函数主要是导入wasm文件，用该文件modulecompile入参数据，返回结果
```
编译成功：
<!-- 编译成功... -->
调用   `fileServiceClient.createFile`生成文件，写入数据
完成编译阶段任务。
<!-- .compiled -->
<!-- .compiled] successfully  -->
5. `setCompileResults`存储编译结果

#### 三. 部署模块  

1. 点击deploy：`onDeploy`,执行`_deploy(compiledContractList)`
其中`compiledContractList`结构如下：
```javascript
[
  {
    contractName: "Storage"
    fileName: "fs://f1052f34d9be46888c735d954158c859/stroage.sol"
    path: ".build/stroage.sol.compiled"
    solcSelectedContractOutput: {
      abi: [...],
      devdoc: ...
      evm: ...
    }
  }
  ...
  ...
]
```
**就是下拉框选中项的所有信息**


2. 执行核心函数`_deploy`,代码如下：

```javascript
  const _deploy = useCallback(
    (compiledContractList: web3Solidity.ICompiledContract[]) => {
      if (!checkChromeChainPlugin(currentAccounts)) {
        return;
      }
      form
        .validateFields()
        .then((data: IDeployFormDetail) => {
          const { solcSelectedContractOutput } =
            compiledContractList[data.compiled];
          const linkReferences =
            solcSelectedContractOutput.evm.bytecode.linkReferences;
          const libraryDeployedStatus =
            libraryHelper.validContractLibraryDeployedStatus(
              currentChainID,
              linkReferences,
              deployLibraryJson
            );
          // deploy pending
          dispatch(
            web3SolidityActions.updateDeployStatus(DeployStatus.PENDING)
          );
          switch (libraryDeployedStatus) {
            // 合约没有library，直接部署
            case EContractLinkReferenceStatus.NOT_EXIST_LINKREFERENCE: {
              callDeployAction(
                data,
                solcSelectedContractOutput,
                compiledContractList[data.compiled]
              );
              break;
            }
            // 合约有library且library尚未部署，先部署library
            case EContractLinkReferenceStatus.NOT_EXIST_DEPLOYED_LIBRARY: {
              deployContractAndLibrary(
                data,
                linkReferences,
                compiledContractList[data.compiled]
              );
              break;
            }
            // 合约有library且所有library均已部署，使用library地址调整合约
            case EContractLinkReferenceStatus.ALL_LIBRARIES_HAVE_DEPLOYED: {
              deployContractWithLibrary(
                data,
                linkReferences,
                compiledContractList[data.compiled]
              );
              break;
            }
            default: {
              break;
            }
          }
        })
        .catch((e: Error) => {
          console.log(e);
        });
    },
    [
      currentAccounts,
      currentChainID,
      form,
      deployLibraryJson,
      dispatch,
      callDeployAction,
      deployContractAndLibrary,
      deployContractWithLibrary
    ]
  );
```

#### 2.1 校验`checkChromeChainPlugin(currentAccounts)`

```javascript
function checkChromeChainPlugin(
  currentAccounts: web3Solidity.IWalletAccount[]
) {
  const wallet = walletService.wallet;
  let checkResult = false;
  if (wallet) {
    switch (wallet.walletId) {
      case WalletIdMap.BinanceWallet:
        checkResult = checkChains.checkBinance(currentAccounts);
        break;
      case WalletIdMap.MetamaskWallet:
        checkResult = checkChains.checkMetaMask(currentAccounts);
        break;
      case WalletIdMap.NervosWallet:
        checkResult = checkChains.checkNervos(currentAccounts);
        break;
      default:
        checkResult = checkChains.checkWallet(currentAccounts);
        break;
    }
  } else {
    outputService.handleErrorSingle(
      getLocaleMsgFromKey('WALLET_LOG_NO_WALLET_CONNECTED'),
      LogSource.DEPLOY
    );
  }
  return checkResult;
}
```

以`currentAccounts`为输入，做了一些钱包相关的逻辑判断，输出`checkResult`,连接`jvm`会走到`default`的逻辑.

```javascript
// currentAccounts结构如下
0: {address: '0x5B38Da6a701c568545dCfcB03FcB875f56beddC4', balance: 100000000000000000000}
1: {address: '0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2', balance: 100000000000000000000}
2: {address: '0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db', balance: 100000000000000000000}
...
...
...
```

#### 2.2 表单校验
```javascript
// 表单数据data，实际就是下拉框选中项的下标
{
  compiled: 0
}

// 整理几个数据
  const { solcSelectedContractOutput } = compiledContractList[data.compiled];
  const linkReferences = solcSelectedContractOutput.evm.bytecode.linkReferences;
  const libraryDeployedStatus = libraryHelper.validContractLibraryDeployedStatus(
      currentChainID,
      linkReferences,
      deployLibraryJson
    );
// 连接jvm走storage的逻辑打印如下：
// currentChainID>>> JavaScript VM Network
// linkReferences>>> {}
// deployLibraryJson>>> {}
// libraryDeployedStatus>>> not exist linkReference
```

#### 2.3
根据`libraryDeployedStatus`，该字段决定部署时会存在三种情况：
```javascript
  switch (libraryDeployedStatus) {
    // 合约没有library，直接部署
    case EContractLinkReferenceStatus.NOT_EXIST_LINKREFERENCE: {
      console.warn(1)
      callDeployAction(
        data,
        solcSelectedContractOutput,
        compiledContractList[data.compiled]
      );
      break;
    }
    // 合约有library且library尚未部署，先部署library
    case EContractLinkReferenceStatus.NOT_EXIST_DEPLOYED_LIBRARY: {
      console.warn(2)

      deployContractAndLibrary(
        data,
        linkReferences,
        compiledContractList[data.compiled]
      );
      break;
    }
    // 合约有library且所有library均已部署，使用library地址调整合约
    case EContractLinkReferenceStatus.ALL_LIBRARIES_HAVE_DEPLOYED: {
      console.warn(3)

      deployContractWithLibrary(
        data,
        linkReferences,
        compiledContractList[data.compiled]
      );
      break;
    }
    default: {
      break;
    }
  }
```
新创建arbitrum会走1，调用`callDeployAction`，具体代码如下：
```javascript
// 其中的几个入参：
// data: {
//   compiled: 0
// }
// solcCompiledOutput: selectedContract.solcCompiledOutput
// selectedContract: 下拉框选中合约

  const callDeployAction = useCallback(
    (
      data: IDeployFormDetail,
      solcCompiledOutput: web3Solidity.ISolcSelectedContractOutput,
      selectedContract: web3Solidity.ICompiledContract
    ) => {
      console.warn('callDeployAction>>>', {
        data,
        solcCompiledOutput,
        selectedContract
      })
      const {
        payableValue = '0',
        payableUnit = 'wei',
        gasValue = '0',
        gasUnit = 'wei'
      } = data;
      const payPrice = Web3.utils.toHex(
        transformToWei(payableValue, payableUnit)
      );
      const gasPrice = Web3.utils.toHex(transformToWei(gasValue, gasUnit));
      console.warn('callDeployAction')
      if (currentAccount) {
        dispatch(
          web3SolidityActions.deployContract({
            solcCompiledOutput,
            currentChainID,
            account: currentAccount,
            deployOptions: {
              // storageLimit: parseInt(data?.storageLimit || '0'),
              gasLimit: parseInt(data?.gasLimit || '0'),
              payPrice,
              gasPrice
            },
            constructorArgs: data.constructorArgs,
            path: selectedContract.path,
            contractName: selectedContract.contractName,
            fileName: selectedContract.fileName
          })
        );
      }
    },
    [currentAccount, currentChainID, dispatch]
  );
```

#### 2.4 以一坨参数为入参，执行web3SolidityActions.deployContract
代码如下：
```javascript
  deployContract = (
    actionData: Wallet.IDeployContractActionData
  ): Observable<IEvent<EEventType>> => {
    console.log('deployContract>>>>>5', actionData)

    return new Observable((observer: Observer<IEvent<EEventType>>) => {
      const { abi } = actionData.solcCompiledOutput;
      const constructorFunc = abi.find((o) => o.type === 'constructor');

      let params: string | undefined = '';
      try {
        params = this.abiHelper?.encodeParameters(
          constructorFunc?.inputs || [],
          actionData.constructorArgs
        );
        const bytecode = `0x${actionData.solcCompiledOutput.evm.bytecode.object}`;
        let transactionHash: string;
        const contract = new this.web3.eth.Contract(abi as AbiItem[]);
        const deployTx = contract.deploy({
          data: `${bytecode}${params?.slice(2) || ''}`,
          arguments: actionData.constructorArgs ? [...Object.values(actionData.constructorArgs)] : []
        });

        deployTx.send({
          from: actionData.account.address,
        })
          .on('transactionHash', (hash: string) => {
            transactionHash = hash;
            observer.next({
              type: EEventType.TRANSACTION_HASH,
              data: { hash }
            });
          })
          .on('receipt', (receipt: TransactionReceipt) => {
            this.getHardhatLogsFromTx(transactionHash);
            this.web3.eth.getTransaction(transactionHash).then((tx) => {
              observer.next({
                type: EEventType.RECEIPT,
                data: { receipt: { ...receipt, ...tx } }
              });
              observer.complete();
            });
          })
          .on(
            'confirmation',
            (confNumber: number, receipt: TransactionReceipt) => {
              observer.next({
                type: EEventType.CONFIRMATION,
                data: { receipt, confirmationNumber: confNumber }
              });
            }
          )
          .on('error', (error) => {
            if (transactionHash) {
              observer.next({
                type: EEventType.TRANSACTION_ERROR,
                data: { transactionHash }
              });
            }
            observer.error(error);
            observer.complete();
          })
          .catch((e) => {
            if (transactionHash) {
              observer.next({
                type: EEventType.TRANSACTION_ERROR,
                data: { transactionHash }
              });
            }
            observer.error(e);
            observer.complete();
          });
      } catch (err) {
        observer.error(err);
      }
    });
  };
```
完成部署。

### 四：interact模块
1. `查询和调用`方法触发`onCall`

以helloworld模版的test方法举例：
`点击`--> `onCall` --> `dispatchInteractAction` ---> `interactContract` --> 核心函数`this.web3?.eth.sendTransaction`



#### 四：新版本编译

在`getChainModules`函数中，根据不同的链，动态插入对应的页面模块。

#### 4.1 编译

整体逻辑： 
- 开启worker（`CompilerWorker`）
- `postMessage`入参数据
- `message`接受结果打印相关信息

`handleCompile`触发,具体代码如下：
```javascript
  const handleCompile = async () => {
    const worker = new CompilerWorker();
    if (!activeResource?.title) return;
    setCompileLoading(true);
    appendOutput('Compiling...');
    const fileMap = {
      [activeResource.title]: {
        content: activeResourceContent
      }
    };
    await compileAndDeployService.resolveFileMap(fileMap, false);
    appendOutput('Request compile...');
    worker.postMessage({
      type: 'compile',
      sources: fileMap,
      version: compileVersion,
      language: "Solidity",
      settings: {
        outputSelection: {
          '*': {
            '': ['ast'],
            '*': ['*']
          }
        },
        optimizer: {
          enabled: OptimizationVal
        }
      }
    });
    // const localCompileInput = 
    worker.onmessage = async function (event) {
      if (event.data.type === 'success') {
        setCompileLoading(false);
        appendOutput('Compile contract success');
        appendOutput(
          `Uploading [${FS_PROJECT_DIR}/.build${activeResource.title?.replace(
            `~/chainide/${workspaceId}`,
            ''
          )}.compiled] `
        );
        await fileServiceClient.createFile(
          `${FS_PROJECT_DIR}/.build${activeResource.title?.replace(
            `~/chainide/${workspaceId}`,
            ''
          )}.compiled`,
          {
            content: JSON.stringify(event.data.result)
          }
        );
        appendOutput('Compile contract success');
        appendOutput(
          `Upload [${FS_PROJECT_DIR}/.build${activeResource.title?.replace(
            `~/chainide/${workspaceId}`,
            ''
          )}.compiled] successfully `
        );
        setCompileResults({
          ...compileResults,
          [activeResource.name]: event.data.result
        });
        setTimeout(() => handleNextStep(), 100);
      }

      if (event.data.type === 'error') {
        setCompileLoading(false);
        event.data.errors.forEach((error: any) => {
          appendOutput(`\x1b[31m${error.formattedMessage}\x1b[0m`);
        });
      }
    };
  };
```

`activeResource`当前选中文件。
核心函数`compileContract`,代码如下：
```javascript
// 编译核心函数
async function compileContract(body) {
  const compiler_pool = {};
  const version = body.version || 'latest';
  let compiler;
  if (typeof compiler === 'undefined') {
    importScripts(
      `https://binaries.soliditylang.org/wasm/soljson-${version}.js`
    );
    compiler = wrapper(self.Module);
  }
  const response = new Promise((resolve, reject) => {
    try {
      const sources = body.sources;
      const settings = body.settings || {};
      // contract input
      const input = {
        ...template_input,
        sources: sources,
        settings: { ...settings, ...template_input.settings }
      };

      if (compiler_pool[version]) {
        console.warn(1)
        const solcSnapshot = compiler_pool[version];
        resolve(JSON.parse(solcSnapshot.compile(JSON.stringify(input))));
      } else {
        resolve(JSON.parse(compiler.compile(JSON.stringify(input))));
      }
    } catch (e) {
      /* handle error */
      reject(new Error(`Compiler arguments error - ${e.message}`));
    }
  });
  return await response;
}
```
以编译资源为输入，通过`importScripts`赋值compiler，然后`compiler.compile`执行编译并返回结果给到worker的message。
返回的结果数据结构：

```javascript
{
  result: {
    contracts: {
      HelloWorld: {
        abi: [],
        devdoc: {},
        evm: {},
        ewasm: {},
        storageLayout: {},
        userdoc: {}
      }

    },
    sources: {
      // 编译结果文件
      '~/chainide/184a155d8320418590d3652fd7ec8e68/HelloWorld.sol': {
        ast: ...,
        id: ...
      }

    }
  },
  type: "success"
}
```



#### 4.2 部署
`handleDeploy`触发
```javascript
  async function handleDeploy(values) {
    if (!account) {
      messageService.error('Please connect wallet first!');
      return;
    }
    setDeployLoading(true);
    try {
      const abi = compiledData.data.abi;
      const bytecode = compiledData.data.evm.bytecode.object;
      const contract = await metamaskWalletService.deploy(
        abi,
        bytecode,
        Object.values(values)
      );

      const [, name] = selectedContract.split('-');
      handleShowTransactionPanel();
      setTimeout(() => {
        compileAndDeployService.updateTransaction(contract.transaction);
      }, 100);

      await fileServiceClient.createFile(
        `${FS_PROJECT_DIR}/.build/${name}.${contract.address}.deployed`,
        {
          content: JSON.stringify({
            address: contract.address,
            abi,
            contractName: name,
            chainId: window.ethereum.chainId,
            isJSVM: metamaskWalletService.isJSVM
          })
        }
      );
    } catch (e: any) {
      messageService.error(e.message);
    }
    setDeployLoading(false);
  }
```

#### 4.3 交互模块逻辑handleCallContractMethod

请求参数：
```javascript
{
  abis: [],
  contractAddress: '',
  method: ''
}
```
`metamaskWalletService.get`接口返回对应数据


#### 4.4 文件修改保存


`activeResource`变化做两件事： 
- 更新`ActiveResourceContent`, setActiveResourceContent
- 更新`compileResults`, setCompileResults


